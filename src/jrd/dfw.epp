/*
 *	PROGRAM:	JRD Access Method
 *	MODULE:		dfw.epp
 *	DESCRIPTION:	Deferred Work handler
 *
 * The contents of this file are subject to the Interbase Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.Inprise.com/IPL.html
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code was created by Inprise Corporation
 * and its predecessors. Portions created by Inprise Corporation are
 * Copyright (C) Inprise Corporation.
 *
 * All Rights Reserved.
 * Contributor(s): ______________________________________.
 *
 * 2001.6.25 Claudio Valderrama: Implement deferred check for udf usage
 * inside a procedure before dropping the udf and creating stub for future
 * processing of dependencies from dropped generators.
 *
 * 2001.8.12 Claudio Valderrama: find_depend_in_dfw() and other functions
 *   should respect identifiers with embedded blanks instead of chopping them
 *.
 * 2001.10.01 Claudio Valderrama: check constraints should fire AFTER the
 *   BEFORE <action> triggers; otherwise they allow invalid data to be stored.
 *   This is a quick fix for SF Bug #444463 until a more robust one is devised
 *   using trigger's rdb$flags or another mechanism.
 *
 * 2001.10.10 Ann Harrison:  Don't increment the format version unless the
 *   table is actually reformatted.  At the same time, break out some of
 *   the parts of make_version making some new subroutines with the goal
 *   of making make_version readable.
 *
 * 2001.10.18 Ann Harrison: some cleanup of trigger & constraint handling.
 *   it now appears to work correctly on new Firebird databases with lots
 *   of system types and on InterBase databases, without checking for
 *   missing source.
 *
 * 23-Feb-2002 Dmitry Yemanov - Events wildcarding
 *
 * 2002-02-24 Sean Leyne - Code Cleanup of old Win 3.1 port (WINDOWS_ONLY)
 *
 * Adriano dos Santos Fernandes
 *
 * 2008-03-16 Alex Peshkoff - avoid most of data modifications in system transaction.
 *	Problems took place when same data was modified in user transaction, and later -
 *	in system transaction. System transaction always performs updates in place,
 *	but when between RPB setup and actual modification garbage was collected (this
 *	was noticed with GC thread active, but may happen due to any read of the record),
 *	BUGCHECK(291) took place. To avoid that issue, it was decided not to modify data
 *	in system transaction. Also an aspect of 'dirty' access from system transaction was
 *	taken into an account in make_version() and create_index().
 *
 */

#include "firebird.h"
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <algorithm>

#include "../common/classes/fb_string.h"
#include "../common/classes/VaryStr.h"
#include "../jrd/SystemPrivileges.h"
#include "../jrd/jrd.h"
#include "../jrd/val.h"
#include "../jrd/irq.h"
#include "../jrd/tra.h"
#include "../jrd/os/pio.h"
#include "../jrd/ods.h"
#include "../jrd/btr.h"
#include "../jrd/req.h"
#include "../jrd/Statement.h"
#include "../jrd/exe.h"
#include "../jrd/scl.h"
#include "../jrd/blb.h"
#include "../jrd/met.h"
#include "../jrd/lck.h"
#include "../jrd/sdw.h"
#include "../jrd/flags.h"
#include "../jrd/intl.h"
#include "../intl/charsets.h"
#include "../jrd/align.h"
#include "../dsql/DsqlStatementCache.h"
#include "../dsql/DdlNodes.h"
#include "../common/gdsassert.h"
#include "../jrd/blb_proto.h"
#include "../jrd/btr_proto.h"
#include "../jrd/cch_proto.h"
#include "../jrd/cmp_proto.h"
#include "../jrd/dfw_proto.h"
#include "../jrd/dpm_proto.h"
#include "../common/dsc_proto.h"
#include "../jrd/err_proto.h"
#include "../jrd/evl_proto.h"
#include "../jrd/exe_proto.h"
#include "../jrd/ext_proto.h"
#include "../yvalve/gds_proto.h"
#include "../jrd/grant_proto.h"
#include "../jrd/idx_proto.h"
#include "../jrd/intl_proto.h"
#include "../common/isc_f_proto.h"

#include "../jrd/lck.h"
#include "../jrd/met_proto.h"
#include "../jrd/mov_proto.h"
#include "../jrd/par_proto.h"
#include "../jrd/pag_proto.h"
#include "../jrd/os/pio_proto.h"
#include "../jrd/rlck_proto.h"
#include "../jrd/scl_proto.h"
#include "../jrd/sdw_proto.h"
#include "../jrd/tra_proto.h"
#include "../jrd/event_proto.h"
#include "../jrd/nbak.h"
#include "../jrd/trig.h"
#include "../jrd/GarbageCollector.h"
#include "../jrd/IntlManager.h"
#include "../jrd/UserManagement.h"
#include "../jrd/Function.h"
#include "../jrd/PreparedStatement.h"
#include "../jrd/ResultSet.h"
#include "../common/utils_proto.h"
#include "../common/classes/Hash.h"
#include "../jrd/CryptoManager.h"
#include "../jrd/Mapping.h"
#include "../jrd/shut_proto.h"
#include "../jrd/ProtectRelations.h"

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#include "iberror.h"

// Pick up system relation ids
#include "../jrd/ini.h"

inline constexpr int COMPUTED_FLAG = 128;
inline constexpr int WAIT_PERIOD = -1;

DATABASE DB = FILENAME "ODS.RDB";

using namespace Jrd;
using namespace Firebird;

namespace Jrd {

typedef HashTable<
	DeferredWork,
	DEFAULT_HASH_SIZE,
	DeferredWork,
	DefaultKeyValue<DeferredWork>,
	DeferredWork
> DfwHash;

// NS: This needs careful refactoring.
//
// Deferred work item:
// * Encapsulates deferred invocation of the task routine with a given set of
//   arguments.
// * Has code to maintain a doubly linked list of itself.
//
// These two functions need to be split, and linked list of custom entries can
// become generic.
//

class DeferredWork : public pool_alloc<type_dfw>,
					 public DfwHash::Entry
{
private:
	DeferredWork(const DeferredWork&);

public:
	enum dfw_t 		dfw_type;		// type of work deferred

private:
	DeferredWork***	dfw_end;
	DeferredWork**	dfw_prev;
	DeferredWork*	dfw_next;

public:
	Lock*			dfw_lock;		// relation creation lock
	Array<DeferredWork*>  dfw_args;	// arguments
	SavNumber		dfw_sav_number;	// save point number
	USHORT			dfw_id;			// object id, if appropriate
	USHORT			dfw_count;		// count of block posts
	string			dfw_name;		// name of object
	MetaName		dfw_schema;		// schema name
	MetaName		dfw_package;	// package name
	SortedArray<int> dfw_ids;		// list of identifiers (or any numbers) needed by an action

public:
	DeferredWork(MemoryPool& p, DeferredWork*** end,
				 enum dfw_t t, USHORT id, SavNumber sn, const string& name,
				 const MetaName& schema, const MetaName& package)
	  : dfw_type(t), dfw_end(end), dfw_prev(dfw_end ? *dfw_end : NULL),
		dfw_next(dfw_prev ? *dfw_prev : NULL), dfw_lock(NULL), dfw_args(p),
		dfw_sav_number(sn), dfw_id(id), dfw_count(1), dfw_name(p, name),
		dfw_schema(p, schema), dfw_package(p, package),
		dfw_ids(p)
	{
		// make previous element point to us
		if (dfw_prev)
		{
			*dfw_prev = this;
			// make next element (if present) to point to us
			if (dfw_next)
			{
				dfw_next->dfw_prev = &dfw_next;
			}
		}
	}

	~DeferredWork()
	{
		// if we are linked
		if (dfw_prev)
		{
			if (dfw_next)
			{
				// adjust previous pointer in next element ...
				dfw_next->dfw_prev = dfw_prev;
			}
			// adjust next pointer in previous element
			*dfw_prev = dfw_next;

			// Adjust end marker of the list
			if (*dfw_end == &dfw_next)
			{
				*dfw_end = dfw_prev;
			}
		}

		for (DeferredWork** itr = dfw_args.begin(); itr < dfw_args.end(); ++itr)
		{
			delete *itr;
		}

		if (dfw_lock)
		{
			LCK_release(JRD_get_thread_data(), dfw_lock);
			delete dfw_lock;
		}
	}

	DeferredWork* findArg(dfw_t type) const
	{
		for (DeferredWork* const* itr = dfw_args.begin(); itr < dfw_args.end(); ++itr)
		{
			DeferredWork* const arg = *itr;

			if (arg->dfw_type == type)
			{
				return arg;
			}
		}

		return NULL;
	}

	DeferredWork** getNextPtr()
	{
		return &dfw_next;
	}

	DeferredWork* getNext() const
	{
		return dfw_next;
	}

	QualifiedName getQualifiedName() const
	{
		return QualifiedName(dfw_name, dfw_schema, dfw_package);
	}

	// hash interface
	bool isEqual(const DeferredWork& work) const
	{
		if (dfw_type == work.dfw_type &&
			dfw_id == work.dfw_id &&
			dfw_name == work.dfw_name &&
			dfw_schema == work.dfw_schema &&
			dfw_package == work.dfw_package &&
			dfw_sav_number == work.dfw_sav_number)
		{
			return true;
		}
		return false;
	}

	DeferredWork* get() { return this; }

	static FB_SIZE_T hash(const DeferredWork& work, FB_SIZE_T hashSize)
	{
		constexpr int nameLimit = 32;
		char key[sizeof work.dfw_type + sizeof work.dfw_id + nameLimit + nameLimit];
		memset(key, 0, sizeof key);
		char* place = key;

		memcpy(place, &work.dfw_type, sizeof work.dfw_type);
		place += sizeof work.dfw_type;

		memcpy(place, &work.dfw_id, sizeof work.dfw_id);
		place += sizeof work.dfw_id;

		work.dfw_name.copyTo(place, nameLimit);	// It's good enough to have first 32 bytes
		place += nameLimit;

		work.dfw_schema.copyTo(place, nameLimit);	// It's good enough to have first 32 bytes

		return DefaultHash<DeferredWork>::hash(key, sizeof key, hashSize);
	}
};

class DfwSavePoint;

typedef HashTable<
	DfwSavePoint,
	DEFAULT_HASH_SIZE,
	SavNumber,
	DfwSavePoint
> DfwSavePointHash;

class DfwSavePoint : public DfwSavePointHash::Entry
{
	SavNumber dfw_sav_number;

public:
	DfwHash hash; // Deferred work items posted under this savepoint

	explicit DfwSavePoint(SavNumber number) : dfw_sav_number(number) { }

	// hash interface
	bool isEqual(const SavNumber& number) const
	{
		return dfw_sav_number == number;
	}

	DfwSavePoint* get() { return this; }

	static SavNumber generate(const DfwSavePoint& item)
	{
		return item.dfw_sav_number;
	}
};

// List of deferred work items (with per-savepoint break-down)
class DeferredJob
{
public:
	DfwSavePointHash hash; // Hash set of savepoints, that posted work
	DeferredWork* work;
	DeferredWork** end;

	DeferredJob() : work(NULL), end(&work) { }
};

} // namespace Jrd


/*==================================================================
 *
 * NOTE:
 *
 *	The following functions required the same number of
 *	parameters to be passed.
 *
 *==================================================================
 */
static bool add_shadow(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool delete_shadow(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool compute_security(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool create_index(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool modify_ltt_index(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool delete_index(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool create_ltt_index(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool delete_ltt_index(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool commit_relation(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool create_relation(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool delete_relation(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool create_trigger(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool delete_trigger(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool modify_trigger(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool create_collation(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool delete_collation(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool delete_exception(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool set_generator(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool delete_generator(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool create_field(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool delete_field(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool modify_field(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool delete_global(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool delete_parameter(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool delete_rfr(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool make_ltt_version(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool add_difference(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool delete_difference(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool begin_backup(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool end_backup(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool check_not_null(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool store_view_context_type(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool user_management(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool drop_package_header(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool modify_package_header(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool drop_package_body(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool grant_privileges(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool db_crypt(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool set_linger(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool clear_cache(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool change_repl_state(thread_db*, SSHORT, DeferredWork*, jrd_tra*);
static bool set_statistics(thread_db*, SSHORT, DeferredWork*, jrd_tra*);

// ----------------------------------------------------------------

static void check_computed_dependencies(thread_db* tdbb, jrd_tra* transaction,
	const QualifiedName& fieldName);
static void check_filename(thread_db*, const Firebird::string&, bool);
static bool	find_depend_in_dfw(thread_db*, const QualifiedName&, USHORT, USHORT, jrd_tra*);
static void get_trigger_dependencies(DeferredWork*, bool, jrd_tra*);

static string get_string(const dsc* desc);
static void setupSpecificCollationAttributes(thread_db*, jrd_tra*, const CSetId, const QualifiedName&, bool);

static ISC_STATUS getErrorCodeByObjectType(int obj_type)
{
	ISC_STATUS err_code = 0;

	switch (obj_type)
	{
	case obj_relation:
		err_code = isc_table_name;
		break;
	case obj_view:
		err_code = isc_view_name;
		break;
	case obj_procedure:
		err_code = isc_proc_name;
		break;
	case obj_collation:
		err_code = isc_collation_name;
		break;
	case obj_exception:
		err_code = isc_exception_name;
		break;
	case obj_field:
		err_code = isc_domain_name;
		break;
	case obj_generator:
		err_code = isc_generator_name;
		break;
	case obj_udf:
		err_code = isc_udf_name;
		break;
	case obj_index:
		err_code = isc_index_name;
		break;
	case obj_package_header:
	case obj_package_body:
		err_code = isc_package_name;
		break;
	default:
		fb_assert(false);
	}

	return err_code;
}

static ISC_STATUS getErrorNotFound(int obj_type)
{
	ISC_STATUS err_code = 0;

	switch (obj_type)
	{
	case obj_procedure:
		err_code = isc_dyn_proc_not_found;
		break;
	case obj_udf:
		err_code = isc_dyn_func_not_found;
		break;
	default:
		fb_assert(false);
	}

	return err_code;
}

static void raiseDatabaseInUseError(bool timeout)
{
	if (timeout)
	{
		ERR_post(Arg::Gds(isc_no_meta_update) <<
				 Arg::Gds(isc_lock_timeout) <<
				 Arg::Gds(isc_obj_in_use) << Arg::Str("DATABASE"));
	}

	ERR_post(Arg::Gds(isc_no_meta_update) <<
			 Arg::Gds(isc_obj_in_use) << Arg::Str("DATABASE"));
}

static void raiseObjectInUseError(const string& obj_type, const QualifiedName& obj_name)
{
	string name;
	name.printf("%s %s", obj_type.c_str(), obj_name.toQuotedString().c_str());

	ERR_post(Arg::Gds(isc_no_meta_update) <<
			 Arg::Gds(isc_obj_in_use) << name);
}

void DFW_raiseRelationInUseError(const Cached::Relation* relation)
{
	const string obj_type =
		relation->isView() ? "VIEW" : "TABLE";

	raiseObjectInUseError(obj_type, relation->getName());
}

void Jrd::ProtectRelations::relLock::takeLock(thread_db* tdbb, jrd_tra* transaction)
{
	m_lock = RLCK_transaction_relation_lock(tdbb, transaction, m_relation);

	m_release = (m_lock->lck_logical == LCK_none);

	bool inUse = false;

	if (!m_release)
	{
		if ((m_lock->lck_logical < LCK_PR) &&
			!LCK_convert(tdbb, m_lock, LCK_PR, transaction->getLockWait()))
		{
			inUse = true;
		}
	}
	else
	{
		if (!LCK_lock(tdbb, m_lock, LCK_PR, transaction->getLockWait()))
			inUse = true;
	}

	if (inUse)
		DFW_raiseRelationInUseError(m_relation);
}


void Jrd::ProtectRelations::relLock::releaseLock(thread_db* tdbb, jrd_tra* transaction)
{
	if (!m_release)
		return;

	vec<Lock*>* vector = transaction->tra_relation_locks;
	if (vector)
	{
		vec<Lock*>::iterator lock = vector->begin();
		for (ULONG i = 0; i < vector->count(); ++i, ++lock)
		{
			if (*lock == m_lock)
			{
				LCK_release(tdbb, m_lock);
				*lock = NULL;
				break;
			}
		}
	}
}

static inline constexpr UCHAR nonnull_validation_blr[] =
{
	blr_version5,
	blr_not,
	blr_missing,
	blr_fid, 0, 0, 0,
	blr_eoc
};

static void check_dependencies(thread_db* tdbb,
							   const QualifiedName& dpdo_name,
							   const MetaName& field_name,
							   int dpdo_type,
							   jrd_tra* transaction);

typedef bool (*dfw_task_routine) (thread_db*, SSHORT, DeferredWork*, jrd_tra*);
struct deferred_task
{
	enum dfw_t task_type;
	dfw_task_routine task_routine;
};


namespace
{
	template <typename Self, typename T, int objType,
		T* (*lookupById)(thread_db*, MetaId, ObjectBase::Flag),
		T* (*lookupByName)(Jrd::thread_db*, const QualifiedName&, ObjectBase::Flag)
	>
	class RoutineManager
	{
	public:
		// Create a new routine.
		static bool createRoutine(thread_db* tdbb, SSHORT phase, DeferredWork* work,
			jrd_tra* transaction)
		{
			SET_TDBB(tdbb);
			const bool compile = !work->findArg(dfw_arg_check_blr);
			ObjectBase::Flag flag = compile ? CacheFlag::MINISCAN : 0;

			switch (phase)
			{
				case 0:
				{
					T* routine = lookupById(tdbb, work->dfw_id, CacheFlag::NOSCAN);
					if (routine)
						routine->rollback(tdbb);

					return false;
				}

				case 1:
				case 2:
					return true;

				case 3:
				{
					const bool compile = !work->findArg(dfw_arg_check_blr);
					getDependencies(work, compile, transaction);

					T* routine = lookupByName(tdbb, work->getQualifiedName(), compile);
					if (!routine)
						return false;

					return true;
				}

				case 4:
				{
					T* routine = lookupById(tdbb, work->dfw_id, flag);
					if (!routine)
					{
						ERR_post(Arg::Gds(isc_no_meta_update) <<
							Arg::Gds(getErrorNotFound(routine->getObjectType())) << Arg::Num(work->dfw_id));
					}

					return true;
				}

				case 5:
				case 6:
					return true;

				case 7:
				{
					T* routine = lookupById(tdbb, work->dfw_id, flag);
					fb_assert(routine);
					if (routine)
						routine->commit(tdbb);

					return false;
				}
			}

			return false;
		}

		// Perform required actions when modifying a routine.
		static bool modifyRoutine(thread_db* tdbb, SSHORT phase, DeferredWork* work,
			jrd_tra* transaction)
		{
			SET_TDBB(tdbb);
			T* routine;
			const QualifiedName name(work->dfw_name);

			switch (phase)
			{
				case 0:
					routine = lookupById(tdbb, work->dfw_id, CacheFlag::NOSCAN);
					if (routine)
						routine->rollback(tdbb);

					return false;

				case 1:
				case 2:
					return true;

				case 3:
					routine = lookupById(tdbb, work->dfw_id, CacheFlag::MINISCAN);
					if (!routine)
						return false;

					return true;

				case 4:
				{
					routine = lookupById(tdbb, work->dfw_id, 0);
					if (!routine)
						return false;

					// delete dependency lists

					if (work->dfw_package.isEmpty())
						MET_delete_dependencies(tdbb, work->getQualifiedName(), objType);

					// Now handle the new definition
					bool compile = !work->findArg(dfw_arg_check_blr);
					getDependencies(work, compile, transaction);

					return true;
				}

				case 5:
					if (work->findArg(dfw_arg_check_blr))
					{
						SSHORT validBlr = FALSE;

						Jrd::Database* dbb = tdbb->getDatabase();
						MemoryPool* newPool = dbb->createPool();
						try
						{
							Jrd::ContextPoolHolder context(tdbb, newPool);

							// compile the routine to know if the BLR is still valid
							if (lookupById(tdbb, work->dfw_id, CacheFlag::AUTOCREATE))
								validBlr = TRUE;
						}
						catch (const Firebird::Exception&)
						{
							fb_utils::init_status(tdbb->tdbb_status_vector);
						}

						dbb->deletePool(newPool);

						Self::validate(tdbb, transaction, work, validBlr);
					}
					return true;

				case 6:
					Self::checkParamDependencies(tdbb, work, transaction);
					return true;

				case 7:
				{
					T* routine = lookupById(tdbb, work->dfw_id, CacheFlag::NOSCAN);
					fb_assert(routine);
					if (routine)
						routine->commit(tdbb);

					return false;
				}
			}

			return false;
		}

		// Check if it is allowed to delete a routine, and if so, clean up after it.
		static bool deleteRoutine(thread_db* tdbb, SSHORT phase, DeferredWork* work,
			jrd_tra* transaction)
		{
			SET_TDBB(tdbb);
			const QualifiedName name(work->dfw_name);
			T* routine;

			switch (phase)
			{
				case 0:
					routine = lookupById(tdbb, work->dfw_id, CacheFlag::NOSCAN);
					if (routine)
						routine->rollback(tdbb);

					return false;

				case 1:
					check_dependencies(tdbb, work->getQualifiedName(), NULL, objType, transaction);
					return true;

				case 2:
					routine = lookupById(tdbb, work->dfw_id, CacheFlag::NOSCAN);
					if (!routine)
						return false;

					return true;

				case 3:
					return true;

				case 4:
				{
					routine = lookupById(tdbb, work->dfw_id, CacheFlag::ERASED | CacheFlag::NOSCAN);
					if (!routine)
						return false;

					// delete dependency lists

					if (work->dfw_package.isEmpty())
						MET_delete_dependencies(tdbb, work->getQualifiedName(), objType);

					return true;
				}

				case 5:
				case 6:
					return true;

				case 7:
					routine = lookupById(tdbb, work->dfw_id, CacheFlag::ERASED | CacheFlag::NOSCAN);
					fb_assert(routine);
					if (routine)
						routine->commit(tdbb);

					return false;
			}	// switch

			return false;
		}

	private:
		// Get relations and fields on which this routine depends, either when it's being
		// created or when it's modified.
		static Routine* getDependencies(DeferredWork* work, bool compile, jrd_tra* transaction)
		{
			thread_db* tdbb = JRD_get_thread_data();
			Jrd::Database* dbb = tdbb->getDatabase();

			if (compile)
				compile = !tdbb->getAttachment()->isGbak();

			bid blobId;
			blobId.clear();
			Routine* routine = Self::lookupBlobId(tdbb, work, blobId, compile);

			MetadataCache::verify_cache(tdbb);

			// get any dependencies now by parsing the blr

			if (!routine)
				return nullptr;

			const QualifiedName depName(work->dfw_package.isEmpty() ?
				work->getQualifiedName() :
				QualifiedName(work->dfw_package, work->dfw_schema));

			if (!blobId.isEmpty())
			{
				Statement* statement = NULL;
				// Nickolay Samofatov: allocate statement memory pool...
				MemoryPool* new_pool = dbb->createPool();
				// block is used to ensure verify_cache()
				// works in not deleted context
				{
					Jrd::ContextPoolHolder context(tdbb, new_pool);
					MET_get_dependencies(tdbb, nullptr, NULL, 0, NULL, &blobId,
						(compile ? &statement : NULL),
						NULL, depName,
						(work->dfw_package.isEmpty() ? objType : obj_package_body),
						0, transaction);

					if (statement)
						statement->release(tdbb);
					else
						dbb->deletePool(new_pool);
				}
			}
			else
			{
				Array<Dependency> dependencies;

				const auto allParameters = {&routine->getInputFields(), &routine->getOutputFields()};

				for (const auto parameters : allParameters)
				{
					for (const auto parameter : *parameters)
					{
						if (parameter->prm_type_of_table.object.hasData())
						{
							Dependency dependency(obj_relation);
							dependency.relation = MetadataCache::getPerm<Cached::Relation>(tdbb,
								parameter->prm_type_of_table, CacheFlag::AUTOCREATE);
							dependency.subName = &parameter->prm_type_of_column;
							dependencies.push(dependency);
						}
						else if (!fb_utils::implicit_domain(parameter->prm_field_source.object.c_str()))
						{
							Dependency dependency(obj_field);
							dependency.name = &parameter->prm_field_source;
							dependencies.push(dependency);
						}

						if (parameter->prm_text_type.has_value())
						{
							Dependency dependency(obj_collation);
							dependency.number = parameter->prm_text_type.value();
							dependencies.push(dependency);
						}
					}
				}

				MET_store_dependencies(tdbb, dependencies, nullptr, depName,
					(work->dfw_package.isEmpty() ? objType : obj_package_header),
					transaction);
			}

			MetadataCache::verify_cache(tdbb);
			return routine;
		}
	};

	class FunctionManager : public RoutineManager<FunctionManager, Cached::Function, obj_udf,
		MetadataCache::getPerm<Cached::Function>, MetadataCache::getPerm<Cached::Function>>
	{
	public:
		static const char* const getTypeStr()
		{
			return "function";
		}

		static Routine* lookupBlobId(thread_db* tdbb, DeferredWork* work, bid& blobId, bool compile);
		static void validate(thread_db* tdbb, jrd_tra* transaction, DeferredWork* work,
			SSHORT validBlr);
		static void checkParamDependencies(thread_db* tdbb, DeferredWork* work, jrd_tra* transaction);
	};

	class ProcedureManager : public RoutineManager<ProcedureManager, Cached::Procedure, obj_procedure,
		MetadataCache::getPerm<Cached::Procedure>, MetadataCache::getPerm<Cached::Procedure>>
	{
	public:
		static const char* const getTypeStr()
		{
			return "procedure";
		}

		static Routine* lookupBlobId(thread_db* tdbb, DeferredWork* work, bid& blobId, bool compile);
		static void validate(thread_db* tdbb, jrd_tra* transaction, DeferredWork* work,
			SSHORT validBlr);
		static void checkParamDependencies(thread_db* tdbb, DeferredWork* work, jrd_tra* transaction);
	};

	// These methods cannot be defined inline, because GPRE generates wrong code.

	Routine* FunctionManager::lookupBlobId(thread_db* tdbb, DeferredWork* work, bid& blobId,
		bool compile)
	{
		Jrd::Attachment* attachment = tdbb->getAttachment();
		AutoCacheRequest handle(tdbb, irq_c_fun_dpd, IRQ_REQUESTS);
		Routine* routine = nullptr;

		FOR(REQUEST_HANDLE handle)
			X IN RDB$FUNCTIONS
			WITH X.RDB$SCHEMA_NAME EQ work->dfw_schema.c_str() AND
				 X.RDB$FUNCTION_NAME EQ work->dfw_name.c_str() AND
				 X.RDB$PACKAGE_NAME EQUIV NULLIF(work->dfw_package.c_str(), '')
		{
			blobId = X.RDB$FUNCTION_BLR;
			routine = Function::lookup(tdbb,  work->getQualifiedName(),
				(compile ? 0 : CacheFlag::MINISCAN) | CacheFlag::AUTOCREATE);
		}
		END_FOR

		return routine;
	}

	void FunctionManager::validate(thread_db* tdbb, jrd_tra* transaction, DeferredWork* work,
		SSHORT validBlr)
	{
		Jrd::Attachment* attachment = tdbb->getAttachment();
		AutoCacheRequest request(tdbb, irq_fun_validate, IRQ_REQUESTS);

		FOR(REQUEST_HANDLE request TRANSACTION_HANDLE transaction)
			FUN IN RDB$FUNCTIONS
			WITH FUN.RDB$FUNCTION_ID EQ work->dfw_id AND
				 FUN.RDB$FUNCTION_BLR NOT MISSING
		{
			MODIFY FUN USING
				FUN.RDB$VALID_BLR = validBlr;
				FUN.RDB$VALID_BLR.NULL = FALSE;
			END_MODIFY
		}
		END_FOR
	}

	void FunctionManager::checkParamDependencies(thread_db* tdbb, DeferredWork* work, jrd_tra* transaction)
	{
		Jrd::Attachment* attachment = tdbb->getAttachment();
		AutoCacheRequest handle(tdbb, irq_func_param_dep, IRQ_REQUESTS);
		ObjectsArray<string> names;
		int depCount = 0;

		FOR (REQUEST_HANDLE handle)
			DEP IN RDB$DEPENDENCIES
			WITH DEP.RDB$DEPENDED_ON_SCHEMA_NAME EQ work->dfw_schema.c_str() AND
				 DEP.RDB$DEPENDED_ON_NAME EQ work->dfw_name.c_str() AND
				 DEP.RDB$PACKAGE_NAME EQUIV NULLIF(work->dfw_package.c_str(), '') AND
				 DEP.RDB$DEPENDED_ON_TYPE = obj_udf AND
				 NOT DEP.RDB$FIELD_NAME MISSING AND
				 NOT ANY ARG IN RDB$FUNCTION_ARGUMENTS
						 WITH ARG.RDB$SCHEMA_NAME EQ DEP.RDB$DEPENDED_ON_SCHEMA_NAME AND
							  ARG.RDB$FUNCTION_NAME EQ DEP.RDB$DEPENDED_ON_NAME AND
							  ARG.RDB$PACKAGE_NAME EQUIV DEP.RDB$PACKAGE_NAME AND
							  ARG.RDB$ARGUMENT_NAME EQ DEP.RDB$FIELD_NAME
		{
			// If the found object is also being deleted, there's no dependency

			if (!find_depend_in_dfw(tdbb,
					QualifiedName(DEP.RDB$DEPENDENT_NAME, DEP.RDB$DEPENDENT_SCHEMA_NAME),
					DEP.RDB$DEPENDENT_TYPE, 0, transaction))
			{
				string& name = names.add();
				name.printf("%s.%s", work->getQualifiedName().toQuotedString().c_str(), DEP.RDB$FIELD_NAME);

				++depCount;
			}
		}
		END_FOR

		if (names.hasData())
		{
			Arg::StatusVector status;
			status << Arg::Gds(isc_no_meta_update) << Arg::Gds(isc_no_delete);

			for (auto& name : names)
				status << Arg::Gds(isc_parameter_name) << name;

			status << Arg::Gds(isc_dependency) << Arg::Num(depCount);

			ERR_post(status);
		}
	}

	Routine* ProcedureManager::lookupBlobId(thread_db* tdbb, DeferredWork* work, bid& blobId,
		bool compile)
	{
		Attachment* attachment = tdbb->getAttachment();
		AutoCacheRequest handle(tdbb, irq_c_prc_dpd, IRQ_REQUESTS);
		Routine* routine = nullptr;

		FOR(REQUEST_HANDLE handle)
			X IN RDB$PROCEDURES
			WITH X.RDB$SCHEMA_NAME EQ work->dfw_schema.c_str() AND
				 X.RDB$PROCEDURE_NAME EQ work->dfw_name.c_str() AND
				 X.RDB$PACKAGE_NAME EQUIV NULLIF(work->dfw_package.c_str(), '')
		{
			blobId = X.RDB$PROCEDURE_BLR;
			routine = MetadataCache::getVersioned<Cached::Procedure>(tdbb,
				work->getQualifiedName(), compile ? 0 : CacheFlag::MINISCAN);
		}
		END_FOR

		return routine;
	}

	void ProcedureManager::validate(thread_db* tdbb, jrd_tra* transaction, DeferredWork* work,
		SSHORT validBlr)
	{
		Jrd::Attachment* attachment = tdbb->getAttachment();
		AutoCacheRequest request(tdbb, irq_prc_validate, IRQ_REQUESTS);

		FOR(REQUEST_HANDLE request TRANSACTION_HANDLE transaction)
			PRC IN RDB$PROCEDURES
			WITH PRC.RDB$PROCEDURE_ID EQ work->dfw_id AND
				 PRC.RDB$PROCEDURE_BLR NOT MISSING
		{
			MODIFY PRC USING
				PRC.RDB$VALID_BLR = validBlr;
				PRC.RDB$VALID_BLR.NULL = FALSE;
			END_MODIFY
		}
		END_FOR
	}

	void ProcedureManager::checkParamDependencies(thread_db* tdbb, DeferredWork* work, jrd_tra* transaction)
	{
		Jrd::Attachment* attachment = tdbb->getAttachment();
		AutoCacheRequest handle(tdbb, irq_proc_param_dep, IRQ_REQUESTS);
		ObjectsArray<string> names;
		int depCount = 0;

		FOR (REQUEST_HANDLE handle)
			DEP IN RDB$DEPENDENCIES
			WITH DEP.RDB$DEPENDED_ON_SCHEMA_NAME EQ work->dfw_schema.c_str() AND
				 DEP.RDB$DEPENDED_ON_NAME EQ work->dfw_name.c_str() AND
				 DEP.RDB$PACKAGE_NAME EQUIV NULLIF(work->dfw_package.c_str(), '') AND
				 DEP.RDB$DEPENDED_ON_TYPE = obj_procedure AND
				 NOT DEP.RDB$FIELD_NAME MISSING AND
				 NOT ANY PP IN RDB$PROCEDURE_PARAMETERS
						 WITH PP.RDB$SCHEMA_NAME EQ DEP.RDB$DEPENDED_ON_SCHEMA_NAME AND
							  PP.RDB$PROCEDURE_NAME EQ DEP.RDB$DEPENDED_ON_NAME AND
							  PP.RDB$PACKAGE_NAME EQUIV DEP.RDB$PACKAGE_NAME AND
							  PP.RDB$PARAMETER_NAME EQ DEP.RDB$FIELD_NAME
		{
			// If the found object is also being deleted, there's no dependency

			if (!find_depend_in_dfw(tdbb,
					QualifiedName(DEP.RDB$DEPENDENT_NAME, DEP.RDB$DEPENDENT_SCHEMA_NAME),
					DEP.RDB$DEPENDENT_TYPE, 0, transaction))
			{
				string& name = names.add();
				name.printf("%s.%s", work->getQualifiedName().toQuotedString().c_str(), DEP.RDB$FIELD_NAME);

				++depCount;
			}
		}
		END_FOR

		if (names.hasData())
		{
			Arg::StatusVector status;
			status << Arg::Gds(isc_no_meta_update) << Arg::Gds(isc_no_delete);

			for (auto& name : names)
				status << Arg::Gds(isc_parameter_name) << name;

			status << Arg::Gds(isc_dependency) << Arg::Num(depCount);

			ERR_post(status);
		}
	}
} // namespace

static inline constexpr deferred_task task_table[] =
{
	{ dfw_add_shadow, add_shadow },
	{ dfw_delete_ltt_index, delete_ltt_index },
	{ dfw_delete_index, delete_index },
	{ dfw_commit_relation, commit_relation },
	{ dfw_delete_rfr, delete_rfr },
	{ dfw_delete_shadow, delete_shadow },
	{ dfw_delete_shadow_nodelete, delete_shadow },
	{ dfw_create_field, create_field },
	{ dfw_delete_field, delete_field },
	{ dfw_modify_field, modify_field },
	{ dfw_delete_global, delete_global },
	{ dfw_create_relation, create_relation },
	{ dfw_delete_relation, delete_relation },
	{ dfw_update_ltt_format, make_ltt_version },
	{ dfw_compute_security, compute_security },
	{ dfw_create_index, create_index },
	{ dfw_create_ltt_index, create_ltt_index },
	{ dfw_modify_ltt_index, modify_ltt_index },
	{ dfw_grant, grant_privileges },
	{ dfw_create_trigger, create_trigger },
	{ dfw_modify_trigger, modify_trigger },
	{ dfw_delete_trigger, delete_trigger },
	{ dfw_drop_package_header, drop_package_header },	// packages should be before procedures
	{ dfw_modify_package_header, modify_package_header },	// packages should be before procedures
	{ dfw_drop_package_body, drop_package_body },		// packages should be before procedures
	{ dfw_create_procedure, ProcedureManager::createRoutine },
	{ dfw_create_function, FunctionManager::createRoutine },
	{ dfw_delete_procedure, ProcedureManager::deleteRoutine },
	{ dfw_delete_function, FunctionManager::deleteRoutine },
	{ dfw_modify_procedure, ProcedureManager::modifyRoutine },
	{ dfw_modify_function, FunctionManager::modifyRoutine },
	{ dfw_delete_prm, delete_parameter },
	{ dfw_create_collation, create_collation },
	{ dfw_delete_collation, delete_collation },
	{ dfw_delete_exception, delete_exception },
	{ dfw_set_generator, set_generator },
	{ dfw_delete_generator, delete_generator },
	{ dfw_add_difference, add_difference },
	{ dfw_delete_difference, delete_difference },
	{ dfw_begin_backup, begin_backup },
	{ dfw_end_backup, end_backup },
	{ dfw_user_management, user_management },
	{ dfw_check_not_null, check_not_null },
	{ dfw_store_view_context_type, store_view_context_type },
	{ dfw_db_crypt, db_crypt },
	{ dfw_set_linger, set_linger },
	{ dfw_clear_cache, clear_cache },
	{ dfw_change_repl_state, change_repl_state },
	{ dfw_set_statistics, set_statistics },
	{ dfw_null, NULL }
};


USHORT DFW_assign_index_type(thread_db* tdbb, const QualifiedName& name, SSHORT field_type, TTypeId ttype)
{
/**************************************
 *
 *	D F W _ a s s i g n _ i n d e x _ t y p e
 *
 **************************************
 *
 * Functional description
 *	Define the index segment type based
 * 	on the field's type and subtype.
 *
 **************************************/
	SET_TDBB(tdbb);

	if (field_type == dtype_varying || field_type == dtype_cstring || field_type == dtype_text)
	{
	    switch (ttype)
	    {
		case ttype_none:
			return idx_string;
		case ttype_binary:
			return idx_byte_array;
		case ttype_metadata:
			return idx_metadata;
		case ttype_ascii:
			return idx_string;
		}

		// Dynamic text cannot occur here as this is for an on-disk
		// index, which must be bound to a text type.

		fb_assert(ttype != ttype_dynamic);

		if (INTL_defined_type(tdbb, ttype))
			return INTL_TEXT_TO_INDEX(ttype);

		ERR_post_nothrow(Arg::Gds(isc_no_meta_update) <<
						 Arg::Gds(isc_random) << name.toQuotedString());
		INTL_texttype_lookup(tdbb, ttype);	// should punt
		ERR_punt(); // if INTL_texttype_lookup hasn't punt
	}

	switch (field_type)
	{
	case dtype_timestamp:
		return idx_timestamp;
	case dtype_timestamp_tz:
		return idx_timestamp_tz;
	case dtype_sql_date:
		return idx_sql_date;
	case dtype_sql_time:
		return idx_sql_time;
	case dtype_sql_time_tz:
		return idx_sql_time_tz;
	// idx_numeric2 used for 64-bit Integer support
	case dtype_int64:
		return idx_numeric2;
	case dtype_boolean:
		return idx_boolean;
	case dtype_dec64:
	case dtype_dec128:
		return idx_decimal;
	case dtype_int128:
		return tdbb->getDatabase()->getEncodedOdsVersion() >= ODS_13_1 ? idx_bcd : idx_decimal;
	default:
		return idx_numeric;
	}
}


void DFW_delete_deferred( jrd_tra* transaction, SavNumber sav_number)
{
/**************************************
 *
 *	D F W _ d e l e t e _ d e f e r r e d
 *
 **************************************
 *
 * Functional description
 *	Get rid of work deferred that was to be done at
 *	COMMIT time as the statement has been rolled back.
 *
 *	if (sav_number == -1), then  remove all entries.
 *
 **************************************/

	// If there is no deferred work, just return

	if (!transaction->tra_deferred_job) {
		return;
	}

	// Remove deferred work and events which are to be rolled back

	if (sav_number == -1)
	{
		DeferredWork* work;
		while ((work = transaction->tra_deferred_job->work))
		{
			delete work;
		}
		transaction->tra_flags &= ~TRA_deferred_meta;
		return;
	}

	DfwSavePoint* h = transaction->tra_deferred_job->hash.lookup(sav_number);
	if (!h)
	{
		return;
	}

	for (DfwHash::iterator i(h->hash); i.hasData();)
	{
		DeferredWork* work(i);
		++i;
		delete work;
	}
}


// Get (by reference) the array of IDs present in a DeferredWork.
SortedArray<int>& DFW_get_ids(DeferredWork* work)
{
	return work->dfw_ids;
}


void DFW_merge_work(jrd_tra* transaction, SavNumber old_sav_number, SavNumber new_sav_number)
{
/**************************************
 *
 *	D F W _ m e r g e _ w o r k
 *
 **************************************
 *
 * Functional description
 *	Merge the deferred work with the previous level.  This will
 *	be called only if there is a previous level.
 *
 **************************************/

	// If there is no deferred work, just return

	DeferredJob *job = transaction->tra_deferred_job;
	if (! job)
		return;

	// Check to see if work is already posted

	DfwSavePoint* oldSp = job->hash.lookup(old_sav_number);
	if (!oldSp)
		return;

	DfwSavePoint* newSp = job->hash.lookup(new_sav_number);

	// Decrement the save point number in the deferred block
	// i.e. merge with the previous level.

	for (DfwHash::iterator itr(oldSp->hash); itr.hasData();)
	{
		if (! newSp)
		{
			newSp = FB_NEW_POOL(*transaction->tra_pool) DfwSavePoint(new_sav_number);
			job->hash.add(newSp);
		}

		DeferredWork* work(itr);
		++itr;
		oldSp->hash.remove(*work); // After ++itr
		work->dfw_sav_number = new_sav_number;

		DeferredWork* newWork = newSp->hash.lookup(*work);

		if (!newWork)
			newSp->hash.add(work);
		else
		{
			SortedArray<int>& workIds = work->dfw_ids;

			for (SortedArray<int>::iterator itr2(workIds.begin()); itr2 != workIds.end(); ++itr2)
			{
				int n = *itr2;
				if (!newWork->dfw_ids.exist(n))
					newWork->dfw_ids.add(n);
			}

			newWork->dfw_count += work->dfw_count;
			delete work;
		}
	}

	job->hash.remove(old_sav_number);
	delete oldSp;
}


void DFW_perform_work(thread_db* tdbb, jrd_tra* transaction)
{
/**************************************
 *
 *	D F W _ p e r f o r m _ w o r k
 *
 **************************************
 *
 * Functional description
 *	Do work deferred to COMMIT time 'cause that time has
 *	come.
 *
 **************************************/

	// If no deferred work or it's all deferred event posting don't bother

	if (!transaction->tra_deferred_job || !(transaction->tra_flags & TRA_deferred_meta))
	{
		return;
	}

	SET_TDBB(tdbb);

	auto* dsql = tdbb->getAttachment()->att_dsql_instance;
	if (dsql && dsql->dbb_statement_cache)
		dsql->dbb_statement_cache->purgeAllAttachments(tdbb);

	Jrd::ContextPoolHolder context(tdbb, transaction->tra_pool);

	/* Loop for as long as any of the deferred work routines says that it has
	more to do.  A deferred work routine should be able to deal with any
	value of phase, either to say that it wants to be called again in the
	next phase (by returning true) or that it has nothing more to do in this
	or later phases (by returning false). By convention, phase 0 has been
	designated as the cleanup phase. If any non-zero phase punts, then phase 0
	is executed for all deferred work blocks to cleanup work-in-progress. */

	bool dump_shadow = false;
	SSHORT phase = 1;
	bool more;
	FbLocalStatus err_status;

	do
	{
		more = false;
		try {
			const auto flags = (TDBB_dont_post_dfw | TDBB_use_db_page_space |
				(phase == 0 ? TDBB_dfw_cleanup : 0));
			AutoSetRestoreFlag<ULONG> dfwFlags(&tdbb->tdbb_flags, flags, true);

			for (const deferred_task* task = task_table; task->task_type != dfw_null; ++task)
			{
				for (DeferredWork* work = transaction->tra_deferred_job->work;
					work; work = work->getNext())
				{
					if (work->dfw_type == task->task_type)
					{
						if (work->dfw_type == dfw_add_shadow)
						{
							dump_shadow = true;
						}
						if ((*task->task_routine)(tdbb, phase, work, transaction))
						{
							more = true;
						}
					}
				}
			}

			if (!phase)
			{
				fb_utils::copyStatus(tdbb->tdbb_status_vector, &err_status);
				ERR_punt();
			}

			++phase;
		}
		catch (const Firebird::Exception& ex)
		{
			// Do any necessary cleanup
			if (!phase)
			{
				ex.stuffException(tdbb->tdbb_status_vector);
				ERR_punt();
			}
			else
				ex.stuffException(&err_status);

			phase = 0;
			more = true;
		}

	} while (more);

	// Remove deferred work blocks so that system transaction and
	// commit retaining transactions don't re-execute them. Leave
	// events to be posted after commit

	for (DeferredWork* itr = transaction->tra_deferred_job->work; itr;)
	{
		DeferredWork* work = itr;
		itr = itr->getNext();

		switch (work->dfw_type)
		{
		case dfw_post_event:
		case dfw_delete_shadow:
			break;

		default:
			delete work;
			break;
		}
	}

	transaction->tra_flags &= ~TRA_deferred_meta;

	if (dump_shadow) {
		SDW_dump_pages(tdbb);
	}
}


void DFW_perform_post_commit_work(jrd_tra* transaction)
{
/**************************************
 *
 *	D F W _ p e r f o r m _ p o s t _ c o m m i t _ w o r k
 *
 **************************************
 *
 * Functional description
 *	Perform any post commit work
 *	1. Post any pending events.
 *	2. Unlink shadow files for dropped shadows
 *
 *	Then, delete it from chain of pending work.
 *
 **************************************/

	if (!transaction->tra_deferred_job)
		return;

	bool pending_events = false;

	Database* dbb = GET_DBB();

	for (DeferredWork* itr = transaction->tra_deferred_job->work; itr;)
	{
		DeferredWork* work = itr;
		itr = itr->getNext();

		switch (work->dfw_type)
		{
		case dfw_post_event:
			EventManager::init(transaction->tra_attachment);

			dbb->eventManager()->postEvent(work->dfw_name.length(),
										   work->dfw_name.c_str(),
										   work->dfw_count);

			delete work;
			pending_events = true;
			break;
		case dfw_delete_shadow:
			if (work->dfw_name.hasData())
				unlink(work->dfw_name.c_str());
			delete work;
			break;
		default:
			break;
		}
	}

	if (pending_events)
	{
		dbb->eventManager()->deliverEvents();
	}
}


DeferredWork* DFW_post_work(jrd_tra* transaction, enum dfw_t type, const dsc* desc, const dsc* schemaDesc, USHORT id,
	const MetaName& package)
{
/**************************************
 *
 *	D F W _ p o s t _ w o r k
 *
 **************************************
 *
 * Functional description
 *	Post work to be deferred to commit time.
 *
 **************************************/

	return DFW_post_work(transaction, type, get_string(desc), get_string(schemaDesc), id, package);
}


DeferredWork* DFW_post_work(jrd_tra* transaction, enum dfw_t type, const string& name, const MetaName& schema,
	USHORT id, const MetaName& package)
{
/**************************************
 *
 *	D F W _ p o s t _ w o r k
 *
 **************************************
 *
 * Functional description
 *	Post work to be deferred to commit time.
 *
 **************************************/

	// get the current save point number

	const SavNumber sav_number = transaction->tra_save_point ?
		transaction->tra_save_point->getNumber() : 0;

	// initialize transaction if needed

	DeferredJob *job = transaction->tra_deferred_job;
	if (! job)
	{
		transaction->tra_deferred_job = job = FB_NEW_POOL(*transaction->tra_pool) DeferredJob;
	}

	// Check to see if work is already posted

	DfwSavePoint* sp = job->hash.lookup(sav_number);
	if (! sp)
	{
		sp = FB_NEW_POOL(*transaction->tra_pool) DfwSavePoint(sav_number);
		job->hash.add(sp);
	}

	DeferredWork tmp(AutoStorage::getAutoMemoryPool(), 0, type, id, sav_number, name, schema, package);
	DeferredWork* work = sp->hash.lookup(tmp);
	if (work)
	{
		work->dfw_count++;
		return work;
	}

	// Not already posted, so do so now.

	work = FB_NEW_POOL(*transaction->tra_pool)
		DeferredWork(*transaction->tra_pool, &(job->end), type, id, sav_number, name, schema, package);
	job->end = work->getNextPtr();
	fb_assert(!(*job->end));
	sp->hash.add(work);

	switch (type)
	{
	case dfw_user_management:
	case dfw_set_generator:
		transaction->tra_flags |= TRA_deferred_meta;
		// fall down ...
	case dfw_post_event:
		if (transaction->tra_save_point)
			transaction->tra_save_point->forceDeferredWork();
		break;
	default:
		transaction->tra_flags |= TRA_deferred_meta;
		break;
	}

	return work;
}


DeferredWork* DFW_post_work_arg(jrd_tra* transaction, DeferredWork* work, const dsc* nameDesc, const dsc* schemaDesc,
	USHORT id)
{
/**************************************
 *
 *	D F W _ p o s t _ w o r k _ a r g
 *
 **************************************
 *
 * Functional description
 *	Post an argument for work to be deferred to commit time.
 *
 **************************************/
	return DFW_post_work_arg(transaction, work, nameDesc, schemaDesc, id, work->dfw_type);
}


DeferredWork* DFW_post_work_arg( jrd_tra* transaction, DeferredWork* work, const dsc* nameDesc, const dsc* schemaDesc,
	USHORT id, Jrd::dfw_t type)
{
/**************************************
 *
 *	D F W _ p o s t _ w o r k _ a r g
 *
 **************************************
 *
 * Functional description
 *	Post an argument for work to be deferred to commit time.
 *
 **************************************/
	DeferredWork* arg = work->findArg(type);

	if (! arg)
	{
		const auto schema = get_string(schemaDesc);
		const auto name = get_string(nameDesc);
		arg = FB_NEW_POOL(*transaction->tra_pool)
			DeferredWork(*transaction->tra_pool, 0, type, id, 0, name, schema, {});
		work->dfw_args.add(arg);
	}

	return arg;
}


void DFW_update_index(const QualifiedName& name, USHORT id, const SelectivityList& selectivity,
	jrd_tra* transaction)
{
/**************************************
 *
 *	D F W _ u p d a t e _ i n d e x
 *
 **************************************
 *
 * Functional description
 *	Update information in the index relation after creation
 *	of the index.
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();

	AutoCacheRequest request(tdbb, irq_m_index_seg, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request TRANSACTION_HANDLE transaction)
		SEG IN RDB$INDEX_SEGMENTS
		WITH SEG.RDB$SCHEMA_NAME EQ name.schema.c_str() AND
			 SEG.RDB$INDEX_NAME EQ name.object.c_str()
		SORTED BY SEG.RDB$FIELD_POSITION
	{
		MODIFY SEG USING
			SEG.RDB$STATISTICS = selectivity[SEG.RDB$FIELD_POSITION];
		END_MODIFY
	}
	END_FOR

	request.reset(tdbb, irq_m_index, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request TRANSACTION_HANDLE transaction)
		IDX IN RDB$INDICES
		WITH IDX.RDB$SCHEMA_NAME EQ name.schema.c_str() AND
			 IDX.RDB$INDEX_NAME EQ name.object.c_str()
	{
		MODIFY IDX USING
			IDX.RDB$INDEX_ID = id + 1;
			IDX.RDB$INDEX_ID.NULL = FALSE;
			IDX.RDB$STATISTICS = selectivity.back();
		END_MODIFY
	}
	END_FOR
}


static bool add_shadow(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra* transaction)
{
/**************************************
 *
 *	a d d _ s h a d o w
 *
 **************************************
 *
 * Functional description
 *	A file or files have been added for shadowing.
 *	Get all files for this particular shadow first
 *	in order of starting page, if specified, then
 *	in sequence order.
 *
 **************************************/

	AutoRequest handle;
	Shadow* shadow;
	bool finished;
	Firebird::PathName expanded_fname;

	SET_TDBB(tdbb);
	Database* const dbb = tdbb->getDatabase();

	switch (phase)
	{
	case 0:
		CCH_release_exclusive(tdbb);
		return false;

	case 1:
	case 2:
	case 3:
		return true;

	case 4:
		check_filename(tdbb, work->dfw_name.c_str(), false);

		/* could have two cases:
		   1) this shadow has already been written to, so add this file using
		   the standard routine to extend a database
		   2) this file is part of a newly added shadow which has already been
		   fetched in totem and prepared for writing to, so just ignore it
		 */

		finished = false;
		handle.reset();
		FOR(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
			F IN RDB$FILES WITH F.RDB$FILE_NAME EQ work->dfw_name.c_str()
		{
			expanded_fname = F.RDB$FILE_NAME;
			ISC_expand_filename(expanded_fname, false);

			MODIFY F USING
				expanded_fname.copyTo(F.RDB$FILE_NAME, sizeof(F.RDB$FILE_NAME));
			END_MODIFY

			for (shadow = dbb->dbb_shadow; shadow; shadow = shadow->sdw_next)
			{
				if ((F.RDB$SHADOW_NUMBER == shadow->sdw_number) && !(shadow->sdw_flags & SDW_IGNORE))
				{
					if (!(F.RDB$FILE_FLAGS & FILE_shadow))
					{
						// We cannot add a file to a shadow that is still
						// in the process of being created.
						raiseDatabaseInUseError(false);
					}

					// This is the case of a bogus duplicate posted
					// work when we added a multi-file shadow
					finished = true;
					break;
				}
			}
		}
		END_FOR

		if (finished)
			return false;

		handle.reset();
		FOR(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
			F IN RDB$FILES WITH F.RDB$FILE_NAME EQ expanded_fname.c_str()
		{
			SDW_add(tdbb, F.RDB$FILE_NAME, F.RDB$SHADOW_NUMBER, F.RDB$FILE_FLAGS);

			MODIFY F
				F.RDB$FILE_FLAGS |= FILE_shadow;
			END_MODIFY
		}
		END_FOR

		break;
	}

	return false;
}

static bool delete_shadow(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra*)
{
/**************************************
 *
 *	d e l e t e _ s h a d o w
 *
 **************************************
 *
 * Functional description
 *	Provide deferred work interface to
 *	MET_delete_shadow.
 *
 **************************************/

	SET_TDBB(tdbb);

	switch (phase)
	{
	case 1:
	case 2:
		return true;

	case 3:
		MET_delete_shadow(tdbb, work->dfw_id);
		break;
	}

	return false;
}

static bool add_difference(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra*)
{
/**************************************
 *
 *	a d d _ d i f f e r e n c e
 *
 **************************************
 *
 * Functional description
 *	Add backup difference file to the database
 *
 **************************************/

	SET_TDBB(tdbb);
	Database* const dbb = tdbb->getDatabase();

	switch (phase)
	{
	case 1:
	case 2:
		return true;

	case 3:
		{
			BackupManager::StateReadGuard stateGuard(tdbb);
			if (dbb->dbb_backup_manager->getState() != Ods::hdr_nbak_normal)
			{
				ERR_post(Arg::Gds(isc_no_meta_update) <<
						 Arg::Gds(isc_wrong_backup_state));
			}
			check_filename(tdbb, work->dfw_name.c_str(), true);
			dbb->dbb_backup_manager->setDifference(tdbb, work->dfw_name.c_str());
		}
		break;
	}

	return false;
}


static bool delete_difference(thread_db* tdbb, SSHORT phase, DeferredWork*, jrd_tra*)
{
/**************************************
 *
 *	d e l e t e _ d i f f e r e n c e
 *
 **************************************
 *
 * Delete backup difference file for database
 *
 **************************************/

	SET_TDBB(tdbb);
	Database* const dbb = tdbb->getDatabase();

	switch (phase)
	{
	case 1:
	case 2:
		return true;

	case 3:
		{
			BackupManager::StateReadGuard stateGuard(tdbb);

			if (dbb->dbb_backup_manager->getState() != Ods::hdr_nbak_normal)
			{
				ERR_post(Arg::Gds(isc_no_meta_update) <<
						 Arg::Gds(isc_wrong_backup_state));
			}
			dbb->dbb_backup_manager->setDifference(tdbb, NULL);
		}
		break;
	}

	return false;
}

static bool begin_backup(thread_db* tdbb, SSHORT phase, DeferredWork*, jrd_tra*)
{
/**************************************
 *
 *	b e g i n _ b a c k u p
 *
 **************************************
 *
 * Begin backup storing changed pages in difference file
 *
 **************************************/

	SET_TDBB(tdbb);
	Database* const dbb = tdbb->getDatabase();

	switch (phase)
	{
	case 1:
	case 2:
		return true;

	case 3:
		dbb->dbb_backup_manager->beginBackup(tdbb);
		break;
	}

	return false;
}

static bool end_backup(thread_db* tdbb, SSHORT phase, DeferredWork*, jrd_tra*)
{
/**************************************
 *
 *	e n d _ b a c k u p
 *
 **************************************
 *
 * End backup and merge difference file if neseccary
 *
 **************************************/

	SET_TDBB(tdbb);
	Database* const dbb = tdbb->getDatabase();

	switch (phase)
	{
	case 1:
	case 2:
		return true;

	case 3:
		// End backup normally
		dbb->dbb_backup_manager->endBackup(tdbb, false);
		break;
	}

	return false;
}

static bool db_crypt(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra*)
{
/**************************************
 *
 *	d b _ c r y p t
 *
 **************************************
 *
 * Encrypt database using plugin dfw_name or decrypt if dfw_name is empty.
 *
 **************************************/

	SET_TDBB(tdbb);
	Database* const dbb = tdbb->getDatabase();

	switch (phase)
	{
	case 1:
	case 2:
		return true;

	case 3:
		dbb->dbb_crypto_manager->changeCryptState(tdbb, work->dfw_name);
		break;
	}

	return false;
}

static bool set_linger(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra*)
{
/**************************************
 *
 *	s e t _ l i n g e r
 *
 **************************************
 *
 * Set linger interval in Database block.
 *
 **************************************/

	SET_TDBB(tdbb);
	Database* const dbb = tdbb->getDatabase();

	switch (phase)
	{
	case 1:
	case 2:
	case 3:
		return true;

	case 4:
		dbb->dbb_linger_seconds = atoi(work->dfw_name.c_str());		// number stored as string
		break;
	}

	return false;
}

static bool set_generator(thread_db* tdbb,
						  SSHORT phase,
						  DeferredWork* work,
						  jrd_tra* transaction)
{
/**************************************
 *
 *	s e t _ g e n e r a t o r
 *
 **************************************
 *
 * Functional description
 *	Set the generator to the given value.
 *
 **************************************/
	SET_TDBB(tdbb);

	switch (phase)
	{
	case 1:
	case 2:
		return true;

	case 3:
		{
			const SLONG id = MET_lookup_generator(tdbb, work->getQualifiedName());
			if (id >= 0)
			{
				fb_assert(id == work->dfw_id);
				SINT64 value = 0;
				if (transaction->getGenIdCache()->get(id, value))
				{
					transaction->getGenIdCache()->remove(id);
					DPM_gen_id(tdbb, id, true, value);
				}
			}
#ifdef DEV_BUILD
			else // This is a test only
				status_exception::raise(Arg::Gds(isc_cant_modify_sysobj) << "generator" << work->getQualifiedName().toQuotedString());
#endif
		}
		break;
	}

	return false;
}

static bool delete_generator(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra* transaction)
{
/**************************************
 *
 *	d e l e t e _ g e n e r a t o r
 *
 **************************************
 *
 * Functional description
 *	Check if it is allowable to delete
 *	a generator, and if so, clean up after it.
 * CVC: This function was modelled after delete_exception.
 *
 **************************************/

	SET_TDBB(tdbb);

	switch (phase)
	{
	case 1:
		check_dependencies(tdbb, work->getQualifiedName(), NULL, obj_generator, transaction);
		break;
	}

	return false;
}

// Store RDB$CONTEXT_TYPE in RDB$VIEW_RELATIONS when restoring legacy backup.
static bool store_view_context_type(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra* transaction)
{
	SET_TDBB(tdbb);

	switch (phase)
	{
	case 1:
		{
			// If RDB$PACKAGE_NAME IS NOT NULL or no record is found in RDB$RELATIONS,
			// the context is a procedure;
			ViewContextType vct = VCT_PROCEDURE;

			AutoRequest handle1;
			FOR (REQUEST_HANDLE handle1 TRANSACTION_HANDLE transaction)
				VRL IN RDB$VIEW_RELATIONS
				CROSS REL IN RDB$RELATIONS
				WITH VRL.RDB$SCHEMA_NAME = work->dfw_schema.c_str() AND
					 VRL.RDB$VIEW_NAME = work->dfw_name.c_str() AND
					 VRL.RDB$VIEW_CONTEXT = work->dfw_id AND
					 VRL.RDB$PACKAGE_NAME MISSING AND
			 		 REL.RDB$SCHEMA_NAME EQ VRL.RDB$RELATION_SCHEMA_NAME AND
			 		 REL.RDB$RELATION_NAME EQ VRL.RDB$RELATION_NAME
			{
				vct = (REL.RDB$VIEW_BLR.NULL ? VCT_TABLE : VCT_VIEW);
			}
			END_FOR

			AutoRequest handle2;
			FOR (REQUEST_HANDLE handle2 TRANSACTION_HANDLE transaction)
				VRL IN RDB$VIEW_RELATIONS
				WITH VRL.RDB$SCHEMA_NAME = work->dfw_schema.c_str() AND
					 VRL.RDB$VIEW_NAME = work->dfw_name.c_str() AND
					 VRL.RDB$VIEW_CONTEXT = work->dfw_id
			{
				MODIFY VRL USING
					VRL.RDB$CONTEXT_TYPE.NULL = FALSE;
					VRL.RDB$CONTEXT_TYPE = (SSHORT) vct;
				END_MODIFY
			}
			END_FOR
		}
		break;
	}

	return false;
}

static bool user_management(thread_db* /*tdbb*/, SSHORT phase, DeferredWork* work, jrd_tra* transaction)
{
/**************************************
 *
 *	u s e r _ m a n a g e m e n t
 *
 **************************************
 *
 * Commit in security database
 *
 **************************************/

	switch (phase)
	{
	case 1:
	case 2:
		return true;

	case 3:
		transaction->getUserManagement()->execute(work->dfw_id);
		return true;

	case 4:
	case 5:
		return true;

	case 6:
		transaction->getUserManagement()->commit();	// safe to be called multiple times
		break;
	}

	return false;
}

// Drop dependencies of a package header.
static bool drop_package_header(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra* transaction)
{
	SET_TDBB(tdbb);

	switch (phase)
	{
	case 1:
		MET_delete_dependencies(tdbb, work->getQualifiedName(), obj_package_body);
		MET_delete_dependencies(tdbb, work->getQualifiedName(), obj_package_header);
		break;
	}

	return false;
}

// Drop dependencies of a package header.
static bool modify_package_header(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra* transaction)
{
	SET_TDBB(tdbb);

	switch (phase)
	{
	case 1:
		MET_delete_dependencies(tdbb, work->getQualifiedName(), obj_package_header);
		break;
	}

	return false;
}

// Drop dependencies of a package body.
static bool drop_package_body(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra* transaction)
{
	SET_TDBB(tdbb);

	switch (phase)
	{
	case 1:
		MET_delete_dependencies(tdbb, work->getQualifiedName(), obj_package_body);
		break;
	}

	return false;
}

static bool change_repl_state(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra*)
{
/**************************************
 *
 *	c h a n g e _ r e p l _ s t a t e
 *
 **************************************
 *
 * Functional description
 *	Signal other processes to refresh their replication state.
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* const dbb = tdbb->getDatabase();
	Attachment* const attachment = tdbb->getAttachment();

	switch (phase)
	{
	case 1:
	case 2:
	case 3:
		return true;

	case 4:
		if (work->dfw_id == 0)
		{
			// replication state is changed
			dbb->invalidateReplState(tdbb, true);
		}
		else
		{
			// replication set is changed
			attachment->invalidateReplSet(tdbb, true);
		}
		break;
	}

	return false;
}

static void check_filename(thread_db* tdbb, const Firebird::string& name, bool shareExpand)
{
/**************************************
 *
 *	c h e c k _ f i l e n a m e
 *
 **************************************
 *
 * Functional description
 *	Make sure that a file path doesn't contain an
 *	inet node name.
 *
 **************************************/
	if (tdbb->tdbb_flags & TDBB_replicator)
		return;

	const Firebird::PathName file_name(name.ToPathName());
	const bool valid = file_name.find("::") == Firebird::PathName::npos;

	if (!valid || ISC_check_if_remote(file_name, shareExpand)) {
		ERR_post(Arg::Gds(isc_no_meta_update) <<
				 Arg::Gds(isc_node_name_err));
		// Msg305: A node name is not permitted in a secondary, shadow, or log file name
	}

	if (!JRD_verify_database_access(file_name)) {
		ERR_post(Arg::Gds(isc_conf_access_denied) << Arg::Str("additional database file") <<
													 Arg::Str(name));
	}
}


//#define DEBUG_REBUILD_INTL

namespace DbgRebuildIntl {

#ifdef DEBUG_REBUILD_INTL
static int ind = 0;
#endif

void out(const char* format, ...)
{
#ifdef DEBUG_REBUILD_INTL
	for (int n = 0; n < ind; ++n)
		putc(' ', stderr);

	va_list params;
	va_start(params, format);
	vfprintf(stderr, format, params);
	va_end(params);
#endif
}

class Lvl
{
public:
	Lvl()
	{
#ifdef DEBUG_REBUILD_INTL
		ind += 2;
#endif
	}

	~Lvl()
	{
#ifdef DEBUG_REBUILD_INTL
		ind -= 2;
#endif
	}
};

} // namespace DbgRebuildIntl


string DFW_remove_icu_info_from_attributes(const QualifiedName& charsetName, const string& specificAttributes)
{
	DbgRebuildIntl::Lvl debLevel;

	Firebird::AutoPtr<charset> cs(FB_NEW charset);
	memset(cs, 0, sizeof(*cs));

	if (IntlManager::lookupCharSet(charsetName, cs))
	{
		DbgRebuildIntl::out("Remove_icu_info_from_attributes for charset '%s'\n", charsetName.toQuotedString().c_str());

		AutoPtr<Firebird::CharSet> charSet(Firebird::CharSet::createInstance(*getDefaultMemoryPool(), 0, cs));
		IntlUtil::SpecificAttributesMap map;
		if (IntlUtil::parseSpecificAttributes(charSet, specificAttributes.length(),
			(const UCHAR*) specificAttributes.begin(), &map))
		{
			map.remove(ATTR_ICU_VERSION);
			map.remove(ATTR_COLL_VERSION);
			return IntlUtil::generateSpecificAttributes(charSet, map);
		}
	}
	else
		DbgRebuildIntl::out("Remove_icu_info_from_attributes - NO CHARSET '%s'\n", charsetName.toQuotedString().c_str());

	return specificAttributes;
}


static void setupSpecificCollationAttributes(thread_db* tdbb, jrd_tra* transaction,
	const CSetId charSetId, const QualifiedName& collationName, bool dropIcuInfo)
{
/**************************************
 *
 *	setupSpecificCollationAttributes
 *
 **************************************
 *
 * Functional description
 *
 **************************************/
	DbgRebuildIntl::Lvl debLevel;

	SET_TDBB(tdbb);
	Jrd::Attachment* const attachment = tdbb->getAttachment();
	AutoCacheRequest handle(tdbb, drq_m_coll_attrs, DYN_REQUESTS);

	DbgRebuildIntl::out("setupSpecificCollationAttributes: dropIcuInfo=%d\n", dropIcuInfo);

	FOR(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
		COLL IN RDB$COLLATIONS
		CROSS CS IN RDB$CHARACTER_SETS OVER RDB$CHARACTER_SET_ID
		WITH COLL.RDB$SCHEMA_NAME EQ collationName.schema.c_str() AND
			 COLL.RDB$COLLATION_NAME EQ collationName.object.c_str() AND
			 COLL.RDB$CHARACTER_SET_ID EQ charSetId
	{
		fb_utils::exact_name(COLL.RDB$COLLATION_NAME);

		if (!COLL.RDB$BASE_COLLATION_NAME.NULL)
			fb_utils::exact_name(COLL.RDB$BASE_COLLATION_NAME);

		SLONG length = 0;
		HalfStaticArray<UCHAR, BUFFER_SMALL> buffer;

		if (!COLL.RDB$SPECIFIC_ATTRIBUTES.NULL)
		{
			blb* blob = blb::open(tdbb, transaction, &COLL.RDB$SPECIFIC_ATTRIBUTES);
			length = blob->blb_length + 10;
			length = blob->BLB_get_data(tdbb, buffer.getBuffer(length), length);
		}

		const string specificAttributes((const char*) buffer.begin(), length);
		DbgRebuildIntl::out("Try collation %s with %s\n", collationName.toQuotedString().c_str(), specificAttributes.c_str());

		QualifiedName charsetName(CS.RDB$CHARACTER_SET_NAME, CS.RDB$SCHEMA_NAME);
		string icuLessAttributes = dropIcuInfo ?
			DFW_remove_icu_info_from_attributes(charsetName, specificAttributes) : specificAttributes;
		DbgRebuildIntl::out("dropIcuInfo %d icuLessAttributes %s\n", dropIcuInfo, icuLessAttributes.c_str());
		string newSpecificAttributes;

		// ASF: If setupCollationAttributes fail we store the original
		// attributes. This should be what we want for new databases
		// and restores. CREATE COLLATION will fail in DYN.
		if (IntlManager::setupCollationAttributes(
				(COLL.RDB$BASE_COLLATION_NAME.NULL ? COLL.RDB$COLLATION_NAME : COLL.RDB$BASE_COLLATION_NAME),
				QualifiedMetaString(CS.RDB$CHARACTER_SET_NAME, CS.RDB$SCHEMA_NAME),
				icuLessAttributes, newSpecificAttributes) &&
			newSpecificAttributes != specificAttributes) // if nothing changed, we do nothing
		{
			DbgRebuildIntl::out("  Recreate collation %s\n", collationName.toQuotedString().c_str());

			MODIFY COLL USING
				if (newSpecificAttributes.isEmpty())
					COLL.RDB$SPECIFIC_ATTRIBUTES.NULL = TRUE;
				else
				{
					COLL.RDB$SPECIFIC_ATTRIBUTES.NULL = FALSE;
					attachment->storeMetaDataBlob(tdbb, transaction,
						&COLL.RDB$SPECIFIC_ATTRIBUTES, newSpecificAttributes);
				}
			END_MODIFY
		}
		else if (newSpecificAttributes == specificAttributes)
			DbgRebuildIntl::out("  nothing changed\n");
		else
			DbgRebuildIntl::out("  setupCollationAttributes() failed\n");
	}
	END_FOR
}


void DFW_reset_icu(thread_db* tdbb)
{
/**************************************
 *
 *	r e s e t I c u
 *
 **************************************
 *
 * Functional description
 *	Fix database for use with other ICU version.
 *	Formally has nothing to do with DFW,
 *	but adding new .epp module is worse.
 *	Next, it's using some DFW code.
 *
 **************************************/
	SET_TDBB(tdbb);

	jrd_tra* transaction = NULL;
	jrd_tra* oldTransaction = tdbb->getTransaction();

	try
	{
		Attachment* attachment = tdbb->getAttachment();
		transaction = TRA_start(tdbb, 0, 0);
		tdbb->setTransaction(transaction);

		SortedArray<QualifiedName> indices;
		ProtectRelations tables(tdbb, transaction);

		// Get list of affected indices & tables
		const char* indSql = R""(
			select ind.RDB$SCHEMA_NAME,
			       ind.RDB$INDEX_NAME,
			       rel.RDB$RELATION_ID,
			       rtrim(coalesce(coll.RDB$BASE_COLLATION_NAME, coll.RDB$COLLATION_NAME)),
			       cs.RDB$SCHEMA_NAME,
			       cs.RDB$CHARACTER_SET_NAME,
			       coll.RDB$SPECIFIC_ATTRIBUTES
			    from SYSTEM.RDB$INDICES ind
			    join SYSTEM.RDB$RELATIONS rel
			        on ind.RDB$SCHEMA_NAME = rel.RDB$SCHEMA_NAME and
			           ind.RDB$RELATION_NAME = rel.RDB$RELATION_NAME
			    join SYSTEM.RDB$INDEX_SEGMENTS seg
			        on ind.RDB$SCHEMA_NAME = seg.RDB$SCHEMA_NAME and
			           ind.RDB$INDEX_NAME = seg.RDB$INDEX_NAME
			    join SYSTEM.RDB$RELATION_FIELDS rfl
			        on rfl.RDB$SCHEMA_NAME = ind.RDB$SCHEMA_NAME and
			           rfl.RDB$RELATION_NAME = ind.RDB$RELATION_NAME and
			           rfl.RDB$FIELD_NAME = seg.RDB$FIELD_NAME
			    join SYSTEM.RDB$FIELDS fld
			        on rfl.RDB$FIELD_SOURCE_SCHEMA_NAME = fld.RDB$SCHEMA_NAME and
			           rfl.RDB$FIELD_SOURCE = fld.RDB$FIELD_NAME
			    join SYSTEM.RDB$COLLATIONS coll
			        on fld.RDB$CHARACTER_SET_ID = coll.RDB$CHARACTER_SET_ID and
			           coalesce(rfl.RDB$COLLATION_ID, fld.RDB$COLLATION_ID) = coll.RDB$COLLATION_ID
			    join SYSTEM.RDB$CHARACTER_SETS cs
			        on coll.RDB$CHARACTER_SET_ID = cs.RDB$CHARACTER_SET_ID
			    where coll.RDB$SPECIFIC_ATTRIBUTES like '%COLL-VERSION=%' and
			          coalesce(ind.RDB$INDEX_INACTIVE, 0) = 0 and
			          coalesce(rel.RDB$RELATION_TYPE, 0) = 0  -- rel_persistent
			    group by ind.RDB$SCHEMA_NAME,
			             ind.RDB$INDEX_NAME,
			             rel.RDB$RELATION_ID,
			             rtrim(coalesce(coll.RDB$BASE_COLLATION_NAME, coll.RDB$COLLATION_NAME)),
			             coll.RDB$SCHEMA_NAME,
			             coll.RDB$COLLATION_NAME,
			             cs.RDB$SCHEMA_NAME,
			             cs.RDB$CHARACTER_SET_NAME,
			             coll.RDB$SPECIFIC_ATTRIBUTES
		)"";
		{	// scope
			AutoPreparedStatement ps(attachment->prepareStatement(tdbb, transaction, indSql));
			AutoResultSet rs(ps->executeQuery(tdbb, transaction));

			while (rs->fetch(tdbb))
			{
				const QualifiedName indexName(rs->getMetaName(tdbb, 2), rs->getMetaName(tdbb, 1));
				const USHORT rel_id = rs->getInt(tdbb, 3);
				const string collationName(rs->getMetaName(tdbb, 4));
				const QualifiedName charsetName(rs->getMetaName(tdbb, 6), rs->getMetaName(tdbb, 5));
				const string specificAttributes(rs->getString(tdbb, 7));

				string icuLessAttributes = DFW_remove_icu_info_from_attributes(charsetName, specificAttributes);
				string newSpecificAttributes;

				DbgRebuildIntl::out("check index %s SA:'%s' ILA:'%s'\n",
					indexName.toQuotedString().c_str(), specificAttributes.c_str(), icuLessAttributes.c_str());

				if (!IntlManager::setupCollationAttributes(collationName,
						charsetName, icuLessAttributes, newSpecificAttributes))
				{
					DbgRebuildIntl::out("setupCollationAttributes failed for %s\n", collationName.c_str());
					continue;
				}

				DbgRebuildIntl::out("newSpecificAttributes '%s'\n", newSpecificAttributes.c_str());
				if (newSpecificAttributes == specificAttributes)
					continue;

				DbgRebuildIntl::out("Add index\n");
				if (!indices.exist(indexName))
					indices.add(indexName);

				if (!tables.exists(rel_id))
				{
					if (auto* relation = MetadataCache::getPerm<Cached::Relation>(tdbb, rel_id, CacheFlag::AUTOCREATE))
						tables.addRelation(relation);
				}
			}
		}

		DbgRebuildIntl::out("locking tables\n");

		// Lock the tables
		tables.lock();

		// Change collation's attributes
		const char* collSql =
			"select coll.RDB$SCHEMA_NAME, coll.RDB$COLLATION_NAME, coll.RDB$CHARACTER_SET_ID from RDB$COLLATIONS coll "
			"where coll.RDB$SPECIFIC_ATTRIBUTES like '%COLL-VERSION=%'";
		{	// scope
			AutoPreparedStatement ps(attachment->prepareStatement(tdbb, transaction, collSql));
			AutoResultSet rs(ps->executeQuery(tdbb, transaction));
			while(rs->fetch(tdbb))
			{
				QualifiedName collName(rs->getMetaName(tdbb, 2), rs->getMetaName(tdbb, 1));
				const CSetId charSetId(rs->getSmallInt(tdbb, 3));

				setupSpecificCollationAttributes(tdbb, transaction, charSetId, collName, true);
			}
		}

		// Reactivate indices
		{	// scope
			for (const auto& idx : indices)
			{
				AutoRequest request;

				FOR(REQUEST_HANDLE request TRANSACTION_HANDLE transaction)
					IDX IN RDB$INDICES
					WITH IDX.RDB$SCHEMA_NAME EQ idx.schema.c_str() AND
						 IDX.RDB$INDEX_NAME EQ idx.object.c_str()
				{
					MODIFY IDX
						DbgRebuildIntl::out("Re-activate index %s\n", idx.toQuotedString().c_str());
						IDX.RDB$INDEX_INACTIVE.NULL = FALSE;
						IDX.RDB$INDEX_INACTIVE = FALSE;
					END_MODIFY
				}
				END_FOR
			}
		}

		// Commit
		TRA_commit(tdbb, transaction, false);
		transaction = NULL;
		tdbb->setTransaction(oldTransaction);
	}
	catch (const Firebird::Exception&)
	{
		if (transaction)
		{
			TRA_rollback(tdbb, transaction, false, true);
		}
		tdbb->setTransaction(oldTransaction);

		throw;
	}
}


static string get_string(const dsc* desc)
{
/**************************************
 *
 *  g e t _ s t r i n g
 *
 **************************************
 *
 * Get string for a given descriptor.
 *
 **************************************/
	const char* str;
	VaryStr<MAXPATHLEN> temp;// Must hold largest metadata field or filename

	if (!desc)
	{
		return string();
	}

	// Find the actual length of the string, searching until the claimed
	// end of the string, or the terminating \0, whichever comes first.

	USHORT length = MOV_make_string(JRD_get_thread_data(), desc, ttype_metadata, &str, &temp, sizeof(temp));

	const char* p = str;
	const char* const q = str + length;
	while (p < q && *p)
	{
		++p;
	}

	// Trim trailing blanks (bug 3355)

	while (--p >= str && *p == ' ')
		;
	length = (p + 1) - str;

	return string(str, length);
}


static void check_computed_dependencies(thread_db* tdbb, jrd_tra* transaction,
	const QualifiedName& fieldName)
{
/**************************************
 *
 *	c h e c k _ c o m p u t e d _ d e p e n d e n c i e s
 *
 **************************************
 *
 * Functional description
 *	Checks if a computed field has circular dependencies.
 *
 **************************************/
	SET_TDBB(tdbb);

	bool err = false;
	Firebird::SortedObjectsArray<QualifiedName> sortedNames(*tdbb->getDefaultPool());
	Firebird::ObjectsArray<QualifiedName> names;

	sortedNames.add(fieldName);
	names.add(fieldName);

	for (FB_SIZE_T pos = 0; !err && pos < names.getCount(); ++pos)
	{
		AutoCacheRequest request(tdbb, irq_comp_circ_dpd, IRQ_REQUESTS);

		FOR(REQUEST_HANDLE request TRANSACTION_HANDLE transaction)
			DEP IN RDB$DEPENDENCIES
			CROSS RFL IN RDB$RELATION_FIELDS
			WITH DEP.RDB$DEPENDENT_SCHEMA_NAME EQ names[pos].schema.c_str() AND
				 DEP.RDB$DEPENDENT_NAME EQ names[pos].object.c_str() AND
				 DEP.RDB$DEPENDENT_TYPE EQ obj_computed AND
				 DEP.RDB$DEPENDED_ON_TYPE = obj_relation AND
				 RFL.RDB$SCHEMA_NAME = DEP.RDB$DEPENDED_ON_SCHEMA_NAME AND
				 RFL.RDB$RELATION_NAME = DEP.RDB$DEPENDED_ON_NAME AND
				 RFL.RDB$FIELD_NAME = DEP.RDB$FIELD_NAME
		{
			const QualifiedName fieldSource(RFL.RDB$FIELD_SOURCE, RFL.RDB$FIELD_SOURCE_SCHEMA_NAME);

			if (fieldName == fieldSource)
			{
				err = true;
				break;
			}

			if (!sortedNames.exist(fieldSource))
			{
				sortedNames.add(fieldSource);
				names.add(fieldSource);
			}
		}
		END_FOR
	}

	if (err)
	{
		ERR_post(Arg::Gds(isc_no_meta_update) <<
				 Arg::Gds(isc_circular_computed));
	}
}


static bool find_depend_in_dfw(thread_db*	tdbb,
							   const QualifiedName& object_name,
							   USHORT	dep_type,
							   USHORT	rel_id,
							   jrd_tra*		transaction)
{
/**************************************
 *
 *	f i n d _ d e p e n d _ i n _ d f w
 *
 **************************************
 *
 * Functional description
 *	Check the object to see if it is being
 *	deleted as part of the deferred work.
 *	Return true if it is, false otherwise.
 *
 **************************************/
	SET_TDBB(tdbb);
	Jrd::Attachment* attachment = tdbb->getAttachment();

	enum dfw_t dfw_type;

	switch (dep_type)
	{
	case obj_view:
		dfw_type = dfw_delete_relation;
		break;
	case obj_trigger:
		dfw_type = dfw_delete_trigger;
		break;
	case obj_computed:
		dfw_type = rel_id ? dfw_delete_rfr : dfw_delete_global;
		break;
	case obj_validation:
		dfw_type = dfw_delete_global;
		break;
	case obj_procedure:
		dfw_type = dfw_delete_procedure;
		break;
	case obj_index_expression:
	case obj_index_condition:
		dfw_type = dfw_delete_index;
		break;
	case obj_package_header:
		dfw_type = dfw_drop_package_header;
		break;
	case obj_package_body:
		dfw_type = dfw_drop_package_body;
		break;
	case obj_udf:
		dfw_type = dfw_delete_function;
		break;
	default:
		fb_assert(false);
		break;
	}

	// Look to see if an object of the desired type is being deleted or modified.
	// For an object being modified we verify dependencies separately when we parse its BLR.
	for (const DeferredWork* work = transaction->tra_deferred_job->work; work; work = work->getNext())
	{
		if ((work->dfw_type == dfw_type ||
			(work->dfw_type == dfw_modify_procedure && dfw_type == dfw_delete_procedure) ||
			(work->dfw_type == dfw_modify_field && dfw_type == dfw_delete_global) ||
			(work->dfw_type == dfw_modify_trigger && dfw_type == dfw_delete_trigger) ||
			(work->dfw_type == dfw_modify_function && dfw_type == dfw_delete_function)) &&
			work->dfw_schema == object_name.schema &&
			work->dfw_name == object_name.object.c_str() && work->dfw_package.isEmpty() &&
			(!rel_id || rel_id == work->dfw_id))
		{
			if (work->dfw_type == dfw_modify_procedure || work->dfw_type == dfw_modify_function)
			{
				// Don't consider that routine is in DFW if we are only checking the BLR
				if (!work->findArg(dfw_arg_check_blr))
					return true;
			}
			else
			{
				return true;
			}
		}

		if (work->dfw_type == dfw_type && dfw_type == dfw_delete_index &&
			QualifiedName(work->dfw_name, work->dfw_schema) == object_name)
		{
			return true;
		}
	}

	if (dfw_type == dfw_delete_global)
	{
		if (dep_type == obj_computed)
		{
			// Computed fields are more complicated.  If the global field isn't being
			// deleted, see if all of the fields it is the source for, are.

			AutoCacheRequest request(tdbb, irq_ch_cmp_dpd, IRQ_REQUESTS);

			FOR(REQUEST_HANDLE request)
				FLD IN RDB$FIELDS CROSS
				RFR IN RDB$RELATION_FIELDS CROSS
				REL IN RDB$RELATIONS
				WITH FLD.RDB$SCHEMA_NAME EQ object_name.schema.c_str() AND
					 FLD.RDB$FIELD_NAME EQ object_name.object.c_str() AND
					 RFR.RDB$FIELD_SOURCE_SCHEMA_NAME EQ FLD.RDB$SCHEMA_NAME AND
					 RFR.RDB$FIELD_SOURCE EQ FLD.RDB$FIELD_NAME AND
					 REL.RDB$SCHEMA_NAME EQ RFR.RDB$SCHEMA_NAME AND
					 REL.RDB$RELATION_NAME EQ RFR.RDB$RELATION_NAME
			{
				if (!find_depend_in_dfw(tdbb, QualifiedName(RFR.RDB$FIELD_NAME), obj_computed,
										REL.RDB$RELATION_ID, transaction))
				{
					return false;
				}
			}
			END_FOR

			return true;
		}

		if (dep_type == obj_validation)
		{
			// Maybe it's worth caching in the future?
			AutoRequest request;

			FOR(REQUEST_HANDLE request)
				FLD IN RDB$FIELDS
				WITH FLD.RDB$SCHEMA_NAME EQ object_name.schema.c_str() AND
					 FLD.RDB$FIELD_NAME EQ object_name.object.c_str()
			{
				if (!FLD.RDB$VALIDATION_BLR.NULL)
					return false;
			}
			END_FOR

			return true;
		}
	}

	return false;
}




//
// Per-type create/alter/drop support.
//


static bool create_field(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra* transaction)
{
/**************************************
 *
 *	c r e a t e _ f i e l d
 *
 **************************************
 *
 * Functional description
 *	Store dependencies of a field.
 *
 **************************************/

	SET_TDBB(tdbb);
	Jrd::Attachment* attachment = tdbb->getAttachment();

	switch (phase)
	{
	case 1:
		{
			const auto depName(work->getQualifiedName());
			AutoRequest handle;
			bid validation;
			validation.clear();

			FOR(REQUEST_HANDLE handle)
				FLD IN RDB$FIELDS
				WITH FLD.RDB$SCHEMA_NAME EQ depName.schema.c_str() AND
					 FLD.RDB$FIELD_NAME EQ depName.object.c_str()
			{
				if (!FLD.RDB$VALIDATION_BLR.NULL)
					validation = FLD.RDB$VALIDATION_BLR;
			}
			END_FOR

			if (!validation.isEmpty())
			{
				Jrd::Database* dbb = tdbb->getDatabase();
				MemoryPool* new_pool = dbb->createPool();
				Jrd::ContextPoolHolder context(tdbb, new_pool);

				MET_get_dependencies(tdbb, nullptr, NULL, 0, NULL, &validation,
					NULL, NULL, depName, obj_validation, 0, transaction, depName);

				dbb->deletePool(new_pool);
			}
		}
		// fall through

	case 2:
	case 3:
		return true;

	case 4:	// after scan_relation (phase 3)
		check_computed_dependencies(tdbb, transaction, work->getQualifiedName());
		break;
	}

	return false;
}


static bool delete_field(thread_db*	tdbb, SSHORT phase, DeferredWork* work, jrd_tra* transaction)
{
/**************************************
 *
 *	d e l e t e _ f i e l d
 *
 **************************************
 *
 * Functional description
 *	This whole routine exists just to
 *	return an error if someone attempts to
 *	delete a global field that is in use
 *
 **************************************/

	int field_count;
	AutoRequest handle;

	SET_TDBB(tdbb);
	Jrd::Attachment* const attachment = tdbb->getAttachment();

	switch (phase)
	{
	case 1:
		// Look up the field in RFR.  If we can't find the field, go ahead with the delete.

		handle.reset();
		field_count = 0;

		FOR(REQUEST_HANDLE handle)
			RFR IN RDB$RELATION_FIELDS
			CROSS REL IN RDB$RELATIONS OVER RDB$SCHEMA_NAME, RDB$RELATION_NAME
			WITH RFR.RDB$FIELD_SOURCE_SCHEMA_NAME EQ work->dfw_schema.c_str() AND
				 RFR.RDB$FIELD_SOURCE EQ work->dfw_name.c_str()
		{
			// If the rfr field is also being deleted, there's no dependency
			if (!find_depend_in_dfw(tdbb, QualifiedName(RFR.RDB$FIELD_NAME), obj_computed, REL.RDB$RELATION_ID,
									transaction))
			{
				field_count++;
			}
		}
		END_FOR

		if (field_count)
		{
			ERR_post(Arg::Gds(isc_no_meta_update) <<
					 Arg::Gds(isc_no_delete) <<								// Msg353: can not delete
					 Arg::Gds(isc_domain_name) << work->getQualifiedName().toQuotedString() <<
					 Arg::Gds(isc_dependency) << Arg::Num(field_count)); 	// Msg310: there are %ld dependencies
		}

		check_dependencies(tdbb, work->getQualifiedName(), NULL, obj_field, transaction);

	case 2:
		return true;

	case 3:
		MET_delete_dependencies(tdbb, work->getQualifiedName(), obj_computed);
		MET_delete_dependencies(tdbb, work->getQualifiedName(), obj_validation);
		break;
	}

	return false;
}


static bool modify_field(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra* transaction)
{
/**************************************
 *
 *	m o d i f y _ f i e l d
 *
 **************************************
 *
 * Functional description
 *	Handle constraint dependencies of a field.
 *
 **************************************/

	SET_TDBB(tdbb);
	Jrd::Attachment* attachment = tdbb->getAttachment();

	switch (phase)
	{
	case 1:
		{
			const auto depName(work->getQualifiedName());
			AutoRequest handle;

			// If a domain is being changed to NOT NULL, schedule validation of involved relations.
			if (work->findArg(dfw_arg_field_not_null))
			{
				FOR(REQUEST_HANDLE handle)
					RFL IN RDB$RELATION_FIELDS CROSS
					REL IN RDB$RELATIONS
					WITH REL.RDB$SCHEMA_NAME EQ RFL.RDB$SCHEMA_NAME AND
						 REL.RDB$RELATION_NAME EQ RFL.RDB$RELATION_NAME AND
						 RFL.RDB$FIELD_SOURCE_SCHEMA_NAME EQ depName.schema.c_str() AND
						 RFL.RDB$FIELD_SOURCE EQ depName.object.c_str() AND
						 (RFL.RDB$NULL_FLAG MISSING OR RFL.RDB$NULL_FLAG = FALSE) AND
						 REL.RDB$VIEW_BLR MISSING
					REDUCED TO RFL.RDB$SCHEMA_NAME, RFL.RDB$RELATION_NAME, RFL.RDB$FIELD_ID
				{
					dsc schemaDesc;
					schemaDesc.makeText(static_cast<USHORT>(strlen(RFL.RDB$SCHEMA_NAME)), CS_METADATA,
						(UCHAR*) RFL.RDB$SCHEMA_NAME);

					dsc nameDesc;
					nameDesc.makeText(static_cast<USHORT>(strlen(RFL.RDB$RELATION_NAME)), CS_METADATA,
						(UCHAR*) RFL.RDB$RELATION_NAME);

					DeferredWork* work = DFW_post_work(transaction, dfw_check_not_null, &nameDesc, &schemaDesc, 0);
					SortedArray<int>& ids = DFW_get_ids(work);

					FB_SIZE_T pos;
					if (!ids.find(RFL.RDB$FIELD_ID, pos))
						ids.insert(pos, RFL.RDB$FIELD_ID);
				}
				END_FOR
			}

			bid validation;
			validation.clear();

			handle.reset();

			FOR(REQUEST_HANDLE handle)
				FLD IN RDB$FIELDS
				WITH FLD.RDB$SCHEMA_NAME EQ depName.schema.c_str() AND
					 FLD.RDB$FIELD_NAME EQ depName.object.c_str()
			{
				if (!FLD.RDB$VALIDATION_BLR.NULL)
					validation = FLD.RDB$VALIDATION_BLR;
			}
			END_FOR

			const DeferredWork* const arg = work->findArg(dfw_arg_new_name);

			// ASF: If there are procedures depending on the domain, it can't be renamed.
			if (arg && depName != arg->getQualifiedName())
				check_dependencies(tdbb, depName, NULL, obj_field, transaction);

			MET_delete_dependencies(tdbb, depName, obj_validation);

			if (!validation.isEmpty())
			{
				Jrd::Database* dbb = tdbb->getDatabase();
				MemoryPool* new_pool = dbb->createPool();
				Jrd::ContextPoolHolder context(tdbb, new_pool);

				MET_get_dependencies(tdbb, nullptr, NULL, 0, NULL, &validation,
					NULL, NULL, depName, obj_validation, 0, transaction, depName);

				dbb->deletePool(new_pool);
			}
		}
		// fall through

	case 2:
	case 3:
		return true;

	case 4:	// after scan_relation (phase 3)
		check_computed_dependencies(tdbb, transaction, work->getQualifiedName());
		break;
	}

	return false;
}


static bool grant_privileges(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra* transaction)
{
/**************************************
 *
 *	g r a n t _ p r i v i l e g e s
 *
 **************************************
 *
 * Functional description
 *	Compute access control list from SQL privileges.
 *
 **************************************/
	switch (phase)
	{
	case 1:
		return true;

	case 2:
		GRANT_privileges(tdbb, work->getQualifiedName(), work->dfw_id, transaction);
		break;

	default:
		break;
	}

	return false;
}


static bool create_collation(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra* transaction)
{
/**************************************
 *
 *	c r e a t e _ c o l l a t i o n
 *
 **************************************
 *
 * Functional description
 *	Get collation id or setup specific attributes.
 *
 **************************************/

	SET_TDBB(tdbb);
	TTypeId id(work->dfw_id);

	switch (phase)
	{
	case 1:
		setupSpecificCollationAttributes(tdbb, transaction, id,
			work->getQualifiedName(), false);
		return true;

	case 2:
	case 3:
	case 4:
	case 5:
	case 6:
		return true;

	case 7:
		{
			auto* cs = MetadataCache::getPerm<Cached::CharSet>(tdbb, id, 0);
			// fb_assert(cs);	--------------	breaks INI_ini()
			if (cs)
				cs->commit(tdbb);
		}
		return false;

	case 0:
		{
			auto* cs = MetadataCache::getPerm<Cached::CharSet>(tdbb, id, CacheFlag::NOSCAN);
			if (cs)
				cs->rollback(tdbb);
		}
		return false;
	}

	return false;
}


static bool delete_collation(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra* transaction)
{
/**************************************
 *
 *	d e l e t e _ c o l l a t i o n
 *
 **************************************
 *
 * Functional description
 *	Check if it is allowable to delete
 *	a collation, and if so, clean up after it.
 *
 **************************************/

	SET_TDBB(tdbb);

	switch (phase)
	{
	case 1:
		check_dependencies(tdbb, work->getQualifiedName(), NULL, obj_collation, transaction);
		return true;

	case 2:
		return true;

	case 3:
		//full reload instead INTL_texttype_unload(tdbb, work->dfw_id);
		break;
	}

	return false;
}


static bool delete_parameter(thread_db* tdbb, SSHORT phase, DeferredWork*, jrd_tra*)
{
/**************************************
 *
 *	d e l e t e _ p a r a m e t e r
 *
 **************************************
 *
 * Functional description
 *	Return an error if someone attempts to
 *	delete a field from a procedure and it is
 *	used by a view or procedure.
 *
 **************************************/

	SET_TDBB(tdbb);

	switch (phase)
	{
	case 1:
		/* hvlad: temporary disable procedure parameters dependency check
		  until proper solution (something like dyn_mod_parameter)
		  will be implemented. This check never worked properly
		  so no harm is done

		if (MetadataCache::getVersioned<Cached::Procedure>(tdbb, work->dfw_id, CacheFlag::NOSCAN))
		{
			const DeferredWork* arg = work->dfw_args;
			fb_assert(arg && (arg->dfw_type == dfw_arg_proc_name));

			check_dependencies(tdbb, arg->dfw_name, work->dfw_name.c_str(),
							   obj_procedure, transaction);
		}
		*/
		break;
	}

	return false;
}


/*
 * In index-related DFW dfw_id is relation id, dfw_name is index name
 */

static bool create_index(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra* transaction)
{
/**************************************
 *
 *	c r e a t e _ i n d e x
 *
 **************************************
 *
 * Functional description
 *	Create a new index or change the state of an index between active/inactive.
 *
 **************************************/
	jrd_rel* relation = nullptr;

	SET_TDBB(tdbb);
	Jrd::Attachment* attachment = tdbb->getAttachment();
	Database* dbb = tdbb->getDatabase();
	AutoRequest request;

	switch (phase)
	{
	case 0:
		return false;

	case 1:
	case 2:
	case 3:
	case 4:
	case 5:
	case 6:
		return true;

	case 7:
		{
			auto* relation = MetadataCache::getPerm<Cached::Relation>(tdbb, work->dfw_id, 0);
			if (relation)
			{
				fb_assert(work->dfw_ids.getCount() == 1);
				auto* index = relation->lookupIndex(tdbb, work->dfw_ids[0], 0);
				if (index)
					index->commit(tdbb);
			}
		}
		break;
	}

	return false;
}


/*
 * In index-related DFW dfw_id is relation id, dfw_name is index name
 */

static bool set_statistics(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra* transaction)
{
/**************************************
 *
 *	c r e a t e _ i n d e x
 *
 **************************************
 *
 * Functional description
 *	set statistics on index
 *
 **************************************/
	jrd_rel* relation = nullptr;

	SET_TDBB(tdbb);
	Jrd::Attachment* attachment = tdbb->getAttachment();
	Database* dbb = tdbb->getDatabase();
	AutoRequest request;

	switch (phase)
	{
	case 0:
		return false;

	case 1:
	case 2:
		return true;

	case 3:
		// set statistics support
		FOR(REQUEST_HANDLE request TRANSACTION_HANDLE transaction)
			IDX IN RDB$INDICES
			WITH IDX.RDB$SCHEMA_NAME EQ work->dfw_schema.c_str() AND
				 IDX.RDB$INDEX_NAME EQ work->dfw_name.c_str()
		{
			// Request to recalculate statistics?
			if (IDX.RDB$INDEX_ID && IDX.RDB$STATISTICS < 0.0)
			{
				// we need to know if this relation is temporary or not
				Cached::Relation* relation =
					MetadataCache::getPerm<Cached::Relation>(tdbb, work->dfw_id, CacheFlag::AUTOCREATE);

				// no need to recalculate statistics for base instance of GTT
				RelationPages* relPages = relation->getPages(tdbb, MAX_TRA_NUMBER, false);
				const bool isTempInstance = relation->isTemporary() &&
					relPages && (relPages->rel_instance_id != 0);

				if (isTempInstance || !relation->isTemporary())
				{
					SelectivityList selectivity(*tdbb->getDefaultPool());
					const USHORT id = IDX.RDB$INDEX_ID - 1;
					IDX_statistics(tdbb, relation, id, selectivity);
					DFW_update_index(work->getQualifiedName(), id, selectivity, transaction);
				}
			}
		}
		END_FOR

		break;
	}

	return false;
}


static bool delete_index(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra* transaction)
{
/**************************************
 *
 *	d e l e t e _ i n d e x
 *
 **************************************
 *
 * Functional description
 *
 **************************************/
	SET_TDBB(tdbb);

	switch (phase)
	{
	case 0:
		return false;

	case 1:
		check_dependencies(tdbb, work->getQualifiedName(), NULL, obj_index, transaction);
		return true;

	case 2:
	case 3:
		return true;

	case 4:
		{
			auto* relation = MetadataCache::getPerm<Cached::Relation>(tdbb, work->dfw_id, CacheFlag::ERASED);
			if (!relation)
				break;

			RelationPages* relPages = relation->getPages(tdbb, MAX_TRA_NUMBER, false);
			if (!relPages)
				break;

			// we need to special handle temp tables with ON PRESERVE ROWS only
			const bool isTempIndex = (relation->rel_flags & REL_temp_conn) &&
				(relPages->rel_instance_id != 0);
			if (isTempIndex)
				return true;

			fb_assert(work->dfw_ids.getCount() == 1);
			auto* index = relation->lookup_index(tdbb, work->dfw_ids[0], CacheFlag::NOERASED);
			fb_assert(index);
			if (!index)
				break;

			if (index->getForeignKey().hasData())
			{
				if (relation->rel_flags & REL_check_partners)
					relation->scanPartners(tdbb);

				if (relation->rel_foreign_refs)		// may be missing in a case of self-reference
				{
					const auto& foreign(*relation->rel_foreign_refs);
					Cached::Relation* partner = nullptr;
					for (auto dep : foreign)
					{
						if (dep.dep_reference_id == index->getId())
						{
							partner = MetadataCache::getPerm<Cached::Relation>(tdbb, dep.dep_relation, CacheFlag::ERASED | CacheFlag::AUTOCREATE);
							break;
						}
					}

					fb_assert(partner);
					if (partner)
					{
						relation->checkPartners(tdbb);
						if (relation != partner)
							partner->checkPartners(tdbb);
					}
					else {
						// partner relation was not found
						// we must check partners of all relations in database
						MetadataCache::update_partners(tdbb);
					}
				}
			}
		}
		MET_delete_dependencies(tdbb, work->getQualifiedName(), obj_index_expression);
		MET_delete_dependencies(tdbb, work->getQualifiedName(), obj_index_condition);
		return true;

	case 5:
	case 6:
		return true;

	case 7:
		{
			auto* relation = MetadataCache::getPerm<Cached::Relation>(tdbb, work->dfw_id, CacheFlag::ERASED);
			if (relation)
			{
				fb_assert(work->dfw_ids.getCount() == 1);
				auto* index = relation->lookupIndex(tdbb, work->dfw_ids[0], CacheFlag::ERASED);
				if (index)
					index->commit(tdbb);
			}
		}
		break;
	}

	return false;
}


static bool create_relation(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra* transaction)
{
/**************************************
 *
 *	c r e a t e _ r e l a t i o n
 *
 **************************************
 *
 * Functional description
 *	Create a new relation.
 *
 **************************************/
	SET_TDBB(tdbb);

	switch (phase)
	{
	case 1:
	case 2:
	case 3:
	case 4:
	case 5:
	case 6:
		return true;

	case 7:
		{
			auto* relation = MetadataCache::getPerm<Cached::Relation>(tdbb, work->getQualifiedName(), 0);
			if (relation)
				relation->commit(tdbb);
		}
		break;
	}

	return false;
}


static bool delete_relation(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra* transaction)
{
/**************************************
 *
 *	d e l e t e _ r e l a t i o n
 *
 **************************************
 *
 * Functional description
 *	Check if it is allowable to delete
 *	a relation, and if so, clean up after it.
 *
 **************************************/
	AutoRequest request;
	jrd_rel* relation;
	USHORT view_count;
	bool adjusted;

	SET_TDBB(tdbb);
	Jrd::Attachment* attachment = tdbb->getAttachment();
	Database* dbb = tdbb->getDatabase();

	switch (phase)
	{
	case 0:
		{
			auto* relation = MetadataCache::getPerm<Cached::Relation>(tdbb, work->dfw_id, CacheFlag::ERASED);
			if (relation)
			{
				if (relation->isDropped())
					relation->rollback(tdbb);
			}
		}

		return false;

	case 1:
		// check if any views use this as a base relation

		request.reset();
		view_count = 0;
		FOR(REQUEST_HANDLE request)
			X IN RDB$VIEW_RELATIONS
			WITH X.RDB$RELATION_SCHEMA_NAME EQ work->dfw_schema.c_str() AND
				 X.RDB$RELATION_NAME EQ work->dfw_name.c_str()
		{
			// If the view is also being deleted, there's no dependency
			if (!find_depend_in_dfw(tdbb, QualifiedName(X.RDB$VIEW_NAME, X.RDB$SCHEMA_NAME), obj_view, 0, transaction))
			{
				view_count++;
			}
		}
		END_FOR

		if (view_count)
		{
			ERR_post(Arg::Gds(isc_no_meta_update) <<
					 Arg::Gds(isc_no_delete) << // Msg353: can not delete
					 Arg::Gds(isc_table_name) << work->getQualifiedName().toQuotedString() <<
					 Arg::Gds(isc_dependency) << Arg::Num(view_count));
					 // Msg310: there are %ld dependencies
		}

		{
			auto* relation = MetadataCache::getPerm<Cached::Relation>(tdbb, work->dfw_id, CacheFlag::ERASED);
			if (!relation)
				return false;

			check_dependencies(tdbb, work->getQualifiedName(), NULL,
				(relation->isView() ? obj_view : obj_relation), transaction);
		}
		return true;

	case 2:
	case 3:
	case 4:
	case 5:
	case 6:
		return true;

	case 7:
		{
			auto* relation = MetadataCache::getPerm<Cached::Relation>(tdbb, work->dfw_id, CacheFlag::ERASED);
			if (relation)
				relation->commit(tdbb);
		}
		break;
	}

	return false;
}

static bool commit_relation(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra* transaction)
{
/**************************************
 *
 *	c o m m i t _ r e l a t i o n
 *
 **************************************
 *
 * Functional description
 *	Commit changes in relation at phase 7.
 *
 **************************************/
	SET_TDBB(tdbb);

	switch (phase)
	{
	case 1:
	case 2:
		return true;

	case 3:
		MetadataCache::getPerm<Cached::Relation>(tdbb, work->dfw_id, 0);
/*		{
			auto* relation = MetadataCache::getPerm<Cached::Relation>(tdbb, work->dfw_id, 0);
			if (relation)
				relation->removeDepends(tdbb);
		} */
		return true;

	case 4:
	case 5:
	case 6:
		return true;

	case 7:
		{
			auto* relation = MetadataCache::getPerm<Cached::Relation>(tdbb, work->dfw_id, 0);
			if (relation)
				relation->commit(tdbb);
		}
		break;
	}

	return false;
}


static bool delete_rfr(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra* transaction)
{
/**************************************
 *
 *	d e l e t e _ r f r
 *
 **************************************
 *
 * Functional description
 *	This whole routine exists just to
 *	return an error if someone attempts to
 *	1. delete a field from a relation if the relation
 *		is used in a view and the field is referenced in
 *		the view.
 *	2. drop the last column of a table
 *
 **************************************/
	int rel_exists, field_count;
	AutoRequest handle;
	MetaName f;

	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	switch (phase)
	{
	case 1:
		jrd_rel* relation = nullptr;
		try
		{
			relation = MetadataCache::getVersioned<Cached::Relation>(tdbb, work->dfw_id,
				CacheFlag::NOERASED | CacheFlag::AUTOCREATE | CacheFlag::NOCOMMIT);

			// check - may be relation currently contains deleted field once again
			if (relation && (MET_lookup_field(tdbb, relation, work->dfw_name) >= 0))
				break;
		}
		catch(const Exception& ex)
		{
			LocalStatus x;
			ex.stuffException(&x);
			if (!fb_utils::containsErrorCode(x.getErrors(), isc_invalid_blr))
				throw;

			tdbb->tdbb_status_vector->init();
		}

		// first check if there are any fields used explicitly by the view
		handle.reset();
		field_count = 0;
		FOR(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
			REL IN RDB$RELATIONS
			CROSS VR IN RDB$VIEW_RELATIONS
			CROSS VFLD IN RDB$RELATION_FIELDS
			WITH REL.RDB$RELATION_ID EQ work->dfw_id AND
				 VR.RDB$RELATION_SCHEMA_NAME EQ REL.RDB$SCHEMA_NAME AND
				 VR.RDB$RELATION_NAME EQ REL.RDB$RELATION_NAME AND
				 VFLD.RDB$VIEW_CONTEXT EQ VR.RDB$VIEW_CONTEXT AND
				 VFLD.RDB$SCHEMA_NAME EQ VR.RDB$SCHEMA_NAME AND
				 VFLD.RDB$RELATION_NAME EQ VR.RDB$VIEW_NAME AND
				 VFLD.RDB$BASE_FIELD EQ work->dfw_name.c_str()
		{
			// If the view is also being deleted, there's no dependency
			if (!find_depend_in_dfw(tdbb, QualifiedName(VR.RDB$VIEW_NAME, VR.RDB$SCHEMA_NAME),
				obj_view, 0, transaction))
			{
				f = VFLD.RDB$BASE_FIELD;
				field_count++;
			}
		}
		END_FOR

		if (field_count)
		{
			ERR_post(Arg::Gds(isc_no_meta_update) <<
					 Arg::Gds(isc_no_delete) <<	// Msg353: can not delete
					 Arg::Gds(isc_field_name) << Arg::Str(f) <<
					 Arg::Gds(isc_dependency) << Arg::Num(field_count));
					 // Msg310: there are %ld dependencies
		}

		// now check if there are any dependencies generated through the blr
		// that defines the relation

		if (!relation)
		{
			relation = MetadataCache::getVersioned<Cached::Relation>(tdbb, work->dfw_id,
				CacheFlag::NOERASED | CacheFlag::MINISCAN | CacheFlag::NOCOMMIT);
		}

		if (relation)
		{
			check_dependencies(tdbb, relation->getName(), work->dfw_name.c_str(),
							   (relation->isView() ? obj_view : obj_relation),
							   transaction);
		}

		// see if the relation itself is being dropped

		handle.reset();
		rel_exists = 0;
		FOR(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
			REL IN RDB$RELATIONS WITH REL.RDB$RELATION_ID EQ work->dfw_id
		{
			rel_exists++;
		}
		END_FOR

		// if table exists, check if this is the last column in the table

		if (rel_exists)
		{
			field_count = 0;
			handle.reset();

			FOR(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
				REL IN RDB$RELATIONS CROSS
					RFLD IN RDB$RELATION_FIELDS OVER RDB$RELATION_NAME
					WITH REL.RDB$RELATION_ID EQ work->dfw_id
				field_count++;
			END_FOR

			if (!field_count)
			{
				ERR_post(Arg::Gds(isc_no_meta_update) <<
						 Arg::Gds(isc_del_last_field));
				// Msg354: last column in a relation cannot be deleted
			}
		}

		break;
	}

	return false;
}


static bool clear_cache(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra*)
{
/**************************************
 *
 *	c l e a r _ c a c h e
 *
 **************************************
 *
 * Clear security names mapping cache
 *
 **************************************/

	SET_TDBB(tdbb);
	Database* const dbb = tdbb->getDatabase();

	switch (phase)
	{
	case 1:
	case 2:
		return true;

	case 3:
		Mapping::clearCache(dbb->dbb_filename.c_str(), work->dfw_id);
		break;
	}

	return false;
}


static bool delete_exception(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra* transaction)
{
/**************************************
 *
 *	d e l e t e _ e x c e p t i o n
 *
 **************************************
 *
 * Functional description
 *	Check if it is allowable to delete
 *	an exception, and if so, clean up after it.
 *
 **************************************/

	SET_TDBB(tdbb);

	switch (phase)
	{
	case 1:
		check_dependencies(tdbb, work->getQualifiedName(), NULL, obj_exception, transaction);
		break;
	}

	return false;
}


static bool compute_security(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra*)
{
/**************************************
 *
 *	c o m p u t e _ s e c u r i t y
 *
 **************************************
 *
 * Functional description
 *	There was a change in a security class.  Recompute everything
 *	it touches.
 *
 **************************************/
	SET_TDBB(tdbb);
	Jrd::Attachment* attachment = tdbb->getAttachment();

	switch (phase)
	{
	case 1:
	case 2:
		return true;

	case 3:
		{
			fb_assert(work->dfw_schema.isEmpty());

			// Get security class.  This may return NULL if it doesn't exist

			SCL_clear_classes(tdbb, work->dfw_name);

			static const CachedRequestId requestHandleId;
			AutoCacheRequest requestHandle(tdbb, requestHandleId);

			FOR(REQUEST_HANDLE requestHandle)
				X IN RDB$DATABASE
				WITH X.RDB$SECURITY_CLASS EQ work->dfw_name.c_str()
			{
				attachment->att_security_class = SCL_get_class(tdbb, work->dfw_name);
			}
			END_FOR
		}
		break;
	}

	return false;
}


static bool delete_global(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra* transaction)
{
/**************************************
 *
 *	d e l e t e _ g l o b a l
 *
 **************************************
 *
 * Functional description
 *	If a local field has been deleted,
 *	check to see if its global field
 *	is computed. If so, delete all its
 *	dependencies under the assumption
 *	that a global computed field has only
 *	one local field.
 *
 **************************************/
	SET_TDBB(tdbb);
	Jrd::Attachment* attachment = tdbb->getAttachment();

	switch (phase)
	{
	case 1:
	case 2:
		return true;

	case 3:
		{
			AutoRequest handle;
			FOR(REQUEST_HANDLE handle)
				FLD IN RDB$FIELDS
				WITH FLD.RDB$SCHEMA_NAME EQ work->dfw_schema.c_str() AND
					 FLD.RDB$FIELD_NAME EQ work->dfw_name.c_str() AND
					 FLD.RDB$COMPUTED_BLR NOT MISSING
			{
				MET_delete_dependencies(tdbb, work->getQualifiedName(), obj_computed);
			}
			END_FOR
		}
		break;
	}

	return false;
}


static void triggerCommitRollback(thread_db* tdbb, USHORT id, bool doCommit)
{
	switch (id & TRIGGER_TYPE_MASK)		// id is RDB$TRIGGER_TYPE truncated to USHORT
	{
	case TRIGGER_TYPE_DB:
	case TRIGGER_TYPE_DDL:
		{
			auto* triggersSet = MetadataCache::get(tdbb)->getTriggersSet(tdbb, id);
			if (triggersSet)
			{
				if (doCommit)
					triggersSet->commit(tdbb);
				else
					triggersSet->rollback(tdbb);
			}
		}
		break;

	case TRIGGER_TYPE_DML:
		break;
	}
}


static bool create_trigger(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra* transaction)
{
/**************************************
 *
 *	c r e a t e _ t r i g g e r
 *
 **************************************
 *
 * Functional description
 *	Perform required actions on creation of trigger.
 *
 **************************************/

	SET_TDBB(tdbb);

	switch (phase)
	{
	case 0:
		triggerCommitRollback(tdbb, work->dfw_id, false);
		break;

	case 1:
	case 2:
		return true;

	case 3:
		{
			const bool compile = !work->findArg(dfw_arg_check_blr);
			get_trigger_dependencies(work, compile, transaction);
		}
		return true;

	case 4:
	case 5:
	case 6:
		return true;

	case 7:
		triggerCommitRollback(tdbb, work->dfw_id, true);
		break;
	}

	return false;
}


static bool modify_trigger(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra* transaction)
{
/**************************************
 *
 *	m o d i f y _ t r i g g e r
 *
 **************************************
 *
 * Functional description
 *	Perform required actions when modifying trigger.
 *
 **************************************/

	SET_TDBB(tdbb);
	Database* dbb = tdbb->getDatabase();
	Attachment* attachment = tdbb->getAttachment();

	switch (phase)
	{
	case 0:
		triggerCommitRollback(tdbb, work->dfw_id, false);
		break;

	case 1:
	case 2:
		return true;

	case 3:
		{
			bool compile = !work->findArg(dfw_arg_check_blr);

			// get rid of old dependencies, bring in the new
			MET_delete_dependencies(tdbb, work->getQualifiedName(), obj_trigger);
			get_trigger_dependencies(work, compile, transaction);
		}
		return true;

	case 4:
		{ // scope
			const DeferredWork* arg = work->findArg(dfw_arg_check_blr);
			if (arg)
			{
				const auto relation_name(arg->getQualifiedName());
				fb_assert(relation_name.hasData());

				auto* relation = MetadataCache::getPerm<Cached::Relation>(tdbb, relation_name, 0);
				fb_assert(relation);	// must be scanned earlier
				if (relation)
				{
					AutoSetRestore2<jrd_tra*, thread_db> tempTrans(tdbb,
						&thread_db::getTransaction,
						&thread_db::setTransaction,
						transaction);
					relation->newVersion(tdbb);
					DFW_post_work(transaction, dfw_commit_relation, nullptr, nullptr, relation->getId());
				}
			}
		} // scope
		return true;

	case 5:
		{ // scope
			const DeferredWork* arg = work->findArg(dfw_arg_check_blr);
			if (arg)
			{
				const auto relation_name(arg->getQualifiedName());
				fb_assert(relation_name.hasData());
				SSHORT valid_blr = FALSE;

				try
				{
					auto* relation = MetadataCache::getPerm<Cached::Relation>(tdbb, relation_name, 0);
					fb_assert(relation);	// must be scanned earlier

					if (relation)
					{
						if (relation->isAvailable(tdbb) == Cached::Relation::MODIFIED)
							relation->commit(tdbb);

						auto* rel = relation->getVersioned(tdbb, 0);

						MemoryPool* new_pool = dbb->createPool();
						TrigArray triggers(*new_pool);

						try
						{
							Jrd::ContextPoolHolder context(tdbb, new_pool);

							MET_load_trigger(tdbb, rel, work->getQualifiedName(),
								[&triggers](int t)->Triggers& {return triggers[t];});

							for (int i = 1; i < TRIGGER_MAX; ++i)
							{
								if (triggers[i])
								{
									for (auto t : triggers[i])
										t->compile(tdbb);

									triggers[i].release(tdbb, true);
								}
							}

							valid_blr = TRUE;
						}
						catch (const Firebird::Exception&)
						{
							dbb->deletePool(new_pool);
							throw;
						}

						dbb->deletePool(new_pool);
					}
				}
				catch (const Firebird::Exception&)
				{
				}

				AutoCacheRequest request(tdbb, irq_trg_validate, IRQ_REQUESTS);

				FOR(REQUEST_HANDLE request TRANSACTION_HANDLE transaction)
					TRG IN RDB$TRIGGERS
					WITH TRG.RDB$SCHEMA_NAME EQ work->dfw_schema.c_str() AND
						 TRG.RDB$TRIGGER_NAME EQ work->dfw_name.c_str() AND
						 TRG.RDB$TRIGGER_BLR NOT MISSING
				{
					MODIFY TRG USING
						TRG.RDB$VALID_BLR = valid_blr;
						TRG.RDB$VALID_BLR.NULL = FALSE;
					END_MODIFY
				}
				END_FOR
			}
		} // scope
		return true;

	case 6:
		return true;

	case 7:
		triggerCommitRollback(tdbb, work->dfw_id, true);
		break;
	}

	return false;
}


static bool delete_trigger(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra* transaction)
{
/**************************************
 *
 *	d e l e t e _ t r i g g e r
 *
 **************************************
 *
 * Functional description
 *	Cleanup after a deleted trigger.
 *
 **************************************/

	SET_TDBB(tdbb);

	switch (phase)
	{
	case 0:
		triggerCommitRollback(tdbb, work->dfw_id, false);
		break;

	case 1:
	case 2:
		return true;

	case 3:
		// get rid of dependencies
		MET_delete_dependencies(tdbb, work->getQualifiedName(), obj_trigger);
		return true;

	case 4:
	case 5:
	case 6:
		return true;

	case 7:
		triggerCommitRollback(tdbb, work->dfw_id, true);
		break;
	}

	return false;
}


static void get_trigger_dependencies(DeferredWork* work, bool compile, jrd_tra* transaction)
{
/**************************************
 *
 *	g e t _ t r i g g e r _ d e p e n d e n c i e s
 *
 **************************************
 *
 * Functional description
 *	Get relations and fields on which this
 *	trigger depends, either when it's being
 *	created or when it's modified.
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();
	Attachment* attachment = tdbb->getAttachment();
	Database* dbb = tdbb->getDatabase();

	if (compile)
		compile = !tdbb->getAttachment()->isGbak();

	jrd_rel* relation = NULL;
	bid blob_id;
	blob_id.clear();

	ISC_UINT64 type = 0;

	AutoCacheRequest handle(tdbb, irq_c_trigger, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE handle)
		X IN RDB$TRIGGERS
		WITH X.RDB$SCHEMA_NAME EQ work->dfw_schema.c_str() AND
			 X.RDB$TRIGGER_NAME EQ work->dfw_name.c_str()
	{
		blob_id = X.RDB$TRIGGER_BLR;
		type = (ISC_UINT64) X.RDB$TRIGGER_TYPE;
		relation = MetadataCache::getVersioned<Cached::Relation>(tdbb, QualifiedName(X.RDB$RELATION_NAME, X.RDB$SCHEMA_NAME),
			CacheFlag::AUTOCREATE);
	}
	END_FOR

	// get any dependencies now by parsing the blr

	if ((relation || (type & TRIGGER_TYPE_MASK) != TRIGGER_TYPE_DML) && !blob_id.isEmpty())
	{
		Statement* statement = NULL;
		// Nickolay Samofatov: allocate statement memory pool...
		MemoryPool* new_pool = dbb->createPool();
		USHORT par_flags;

		Cleanup mem([&]
		{
			if (statement)
				statement->release(tdbb);
			else
				dbb->deletePool(new_pool);
		});

		if ((type & TRIGGER_TYPE_MASK) == TRIGGER_TYPE_DML)
			par_flags = (USHORT) ((type & 1) ? csb_pre_trigger : csb_post_trigger);
		else
			par_flags = 0;

		Jrd::ContextPoolHolder context(tdbb, new_pool);
		const auto depName(work->getQualifiedName());
		MET_get_dependencies(tdbb, relation, NULL, 0, NULL, &blob_id, (compile ? &statement : NULL),
							 NULL, depName, obj_trigger, par_flags, transaction);
	}
}


static bool check_not_null(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra* transaction)
{
/**************************************
 *
 *	c h e c k _ n o t _ n u l l
 *
 **************************************
 *
 * Scan relation to detect NULLs in fields being changed to NOT NULL.
 *
 **************************************/

	SET_TDBB(tdbb);

	Jrd::Attachment* attachment = tdbb->getAttachment();

	switch (phase)
	{
	case 1:
	case 2:
		return true;

	case 3:
		{
			if (work->dfw_ids.isEmpty())
				break;
			jrd_rel* relation = MetadataCache::getVersioned<Cached::Relation>(tdbb, work->getQualifiedName(), CacheFlag::AUTOCREATE);
			if ((!relation) || relation->isView())
				break;

			// This function is not working correctly for GTTs and LTTs
			if (relation->isTemporary())
				break;

			// Protect relation from modification
			ProtectRelations protectRelation(tdbb, transaction, relation->getPermanent());

			SortedArray<int> fields;
			AutoRequest handle;

			if (relation->getPermanent()->rel_flags & REL_temp_ltt)	// Not used currently
			{
				if (const auto lttPtr = attachment->att_local_temporary_tables.get(work->getQualifiedName()))
				{
					const auto ltt = *lttPtr;

					for (const auto fieldId : work->dfw_ids)
					{
						if (std::any_of(ltt->fields.begin(), ltt->fields.end(),
								[fieldId](const auto& lttField) {
									return lttField.id == (USHORT) fieldId && lttField.notNullFlag;
								}))
						{
							fields.add(fieldId);
						}
					}
				}
			}
			else
			{
				for (SortedArray<int>::iterator itr(work->dfw_ids.begin());
					 itr != work->dfw_ids.end();
					 ++itr)
				{
					FOR(REQUEST_HANDLE handle)
						RFL IN RDB$RELATION_FIELDS CROSS
						FLD IN RDB$FIELDS
						WITH RFL.RDB$SCHEMA_NAME EQ work->dfw_schema.c_str() AND
							 RFL.RDB$RELATION_NAME EQ work->dfw_name.c_str() AND
							 FLD.RDB$SCHEMA_NAME EQ RFL.RDB$FIELD_SOURCE_SCHEMA_NAME AND
							 FLD.RDB$FIELD_NAME EQ RFL.RDB$FIELD_SOURCE AND
							 RFL.RDB$FIELD_ID EQ *itr AND
							 (RFL.RDB$NULL_FLAG = TRUE OR FLD.RDB$NULL_FLAG = TRUE)
					{
						fields.add(RFL.RDB$FIELD_ID);
					}
					END_FOR
				}
			}

			if (fields.hasData())
			{
				UCharBuffer blr;

				blr.add(blr_version5);
				blr.add(blr_begin);
				blr.add(blr_message);
				blr.add(1);	// message number
				blr.add(fields.getCount() & 0xFF);
				blr.add(fields.getCount() >> 8);

				for (FB_SIZE_T i = 0; i < fields.getCount(); ++i)
				{
					blr.add(blr_short);
					blr.add(0);
				}

				blr.add(blr_for);
				blr.add(blr_stall);
				blr.add(blr_rse);
				blr.add(1);
				blr.add(blr_rid);
				blr.add(relation->getId() & 0xFF);
				blr.add(relation->getId() >> 8);
				blr.add(0);	// stream
				blr.add(blr_boolean);

				for (FB_SIZE_T i = 0; i < fields.getCount(); ++i)
				{
					if (i != fields.getCount() - 1)
						blr.add(blr_or);

					blr.add(blr_missing);
					blr.add(blr_fid);
					blr.add(0);	// stream
					blr.add(USHORT(fields[i]) & 0xFF);
					blr.add(USHORT(fields[i]) >> 8);
				}

				blr.add(blr_end);

				blr.add(blr_send);
				blr.add(1);
				blr.add(blr_begin);

				for (FB_SIZE_T i = 0; i < fields.getCount(); ++i)
				{
					blr.add(blr_assignment);

					blr.add(blr_value_if);
					blr.add(blr_missing);
					blr.add(blr_fid);
					blr.add(0);	// stream
					blr.add(USHORT(fields[i]) & 0xFF);
					blr.add(USHORT(fields[i]) >> 8);

					blr.add(blr_literal);
					blr.add(blr_short);
					blr.add(0);
					blr.add(1);
					blr.add(0);

					blr.add(blr_literal);
					blr.add(blr_short);
					blr.add(0);
					blr.add(0);
					blr.add(0);

					blr.add(blr_parameter);
					blr.add(1);	// message number
					blr.add(i & 0xFF);
					blr.add(i >> 8);
				}

				blr.add(blr_end);

				blr.add(blr_send);
				blr.add(1);
				blr.add(blr_begin);

				for (FB_SIZE_T i = 0; i < fields.getCount(); ++i)
				{
					blr.add(blr_assignment);
					blr.add(blr_literal);
					blr.add(blr_short);
					blr.add(0);
					blr.add(0);
					blr.add(0);
					blr.add(blr_parameter);
					blr.add(1);	// message number
					blr.add(i & 0xFF);
					blr.add(i >> 8);
				}

				blr.add(blr_end);
				blr.add(blr_end);
				blr.add(blr_eoc);

				AutoRequest request;
				request.compile(tdbb, blr.begin(), blr.getCount());

				HalfStaticArray<USHORT, 5> hasRecord;

				EXE_start(tdbb, request, transaction);
				EXE_receive(tdbb, request, 1, fields.getCount() * sizeof(USHORT),
					(UCHAR*) hasRecord.getBuffer(fields.getCount()));

				Arg::Gds errs(isc_no_meta_update);
				bool hasError = false;

				for (FB_SIZE_T i = 0; i < fields.getCount(); ++i)
				{
					if (hasRecord[i])
					{
						hasError = true;
						errs << Arg::Gds(isc_cannot_make_not_null) <<
								(*relation->rel_fields)[fields[i]]->fld_name.toQuotedString() <<
								relation->getName().toQuotedString();
					}
				}

				if (hasError)
					ERR_post(errs);
			}
		}

		break;
	}

	return false;
}


static void check_dependencies(thread_db* tdbb,
							   const QualifiedName& dpdo_name,
							   const MetaName& field_name,
							   int dpdo_type,
							   jrd_tra* transaction)
{
/**************************************
 *
 *	c h e c k _ d e p e n d e n c i e s
 *
 **************************************
 *
 * Functional description
 *	Check the dependency list for relation or relation.field
 *	before deleting such.
 *
 **************************************/
	SET_TDBB(tdbb);
	Jrd::Attachment* attachment = tdbb->getAttachment();

	SLONG dep_counts[obj_type_MAX] = {0};

	if (field_name.hasData())
	{
		AutoCacheRequest request(tdbb, irq_ch_f_dpd, IRQ_REQUESTS);

		FOR(REQUEST_HANDLE request)
			DEP IN RDB$DEPENDENCIES
			WITH DEP.RDB$DEPENDED_ON_SCHEMA_NAME EQUIV NULLIF(dpdo_name.schema.c_str(), '') AND
				 DEP.RDB$DEPENDED_ON_NAME EQ dpdo_name.object.c_str() AND
				 DEP.RDB$DEPENDED_ON_TYPE = dpdo_type AND
				 DEP.RDB$FIELD_NAME EQ field_name.c_str() AND
				 DEP.RDB$PACKAGE_NAME EQUIV NULLIF(dpdo_name.package.c_str(), '')
			REDUCED TO DEP.RDB$DEPENDENT_SCHEMA_NAME, DEP.RDB$DEPENDENT_NAME, DEP.RDB$DEPENDENT_TYPE
		{
			// If the found object is also being deleted, there's no dependency

			if (!find_depend_in_dfw(tdbb,
					QualifiedName(DEP.RDB$DEPENDENT_NAME, DEP.RDB$DEPENDENT_SCHEMA_NAME),
					DEP.RDB$DEPENDENT_TYPE, 0, transaction))
			{
				++dep_counts[DEP.RDB$DEPENDENT_TYPE];
			}
		}
		END_FOR
	}
	else
	{
		AutoCacheRequest request(tdbb, irq_ch_dpd, IRQ_REQUESTS);

		FOR(REQUEST_HANDLE request)
			DEP IN RDB$DEPENDENCIES
			WITH DEP.RDB$DEPENDED_ON_SCHEMA_NAME EQUIV NULLIF(dpdo_name.schema.c_str(), '') AND
				 DEP.RDB$DEPENDED_ON_NAME EQ dpdo_name.object.c_str() AND
				 DEP.RDB$DEPENDED_ON_TYPE = dpdo_type AND
				 DEP.RDB$PACKAGE_NAME EQUIV NULLIF(dpdo_name.package.c_str(), '')
			REDUCED TO DEP.RDB$DEPENDENT_SCHEMA_NAME, DEP.RDB$DEPENDENT_NAME, DEP.RDB$DEPENDENT_TYPE
		{
			// If the found object is also being deleted, there's no dependency

			if (!find_depend_in_dfw(tdbb,
					QualifiedName(DEP.RDB$DEPENDENT_NAME, DEP.RDB$DEPENDENT_SCHEMA_NAME),
					DEP.RDB$DEPENDENT_TYPE,
									0, transaction))
			{
				++dep_counts[DEP.RDB$DEPENDENT_TYPE];
			}
		}
		END_FOR
	}

	SLONG total = 0;
	for (int i = 0; i < obj_type_MAX; i++)
		total += dep_counts[i];

	if (!total)
		return;

	if (field_name.hasData())
	{
		string fld_name(dpdo_name.toQuotedString());
		fld_name.append(".");
		fld_name.append(field_name.toQuotedString());

		ERR_post(Arg::Gds(isc_no_meta_update) <<
				 Arg::Gds(isc_no_delete) <<						// Msg353: can not delete
				 Arg::Gds(isc_field_name) << Arg::Str(fld_name) <<
				 Arg::Gds(isc_dependency) << Arg::Num(total));	// Msg310: there are %ld dependencies
	}
	else
	{
		ERR_post(Arg::Gds(isc_no_meta_update) <<
				 Arg::Gds(isc_no_delete) <<						// can not delete
				 Arg::Gds(getErrorCodeByObjectType(dpdo_type)) <<
				 dpdo_name.toQuotedString() <<
				 Arg::Gds(isc_dependency) << Arg::Num(total));	// there are %ld dependencies
	}
}


// Create an index for a Local Temporary Table.
static bool create_ltt_index(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra* transaction)
{
	switch (phase)
	{
		case 1:
		case 2:
			return true;

		case 3:
			break;

		default:
			return false;
	}

	const auto attachment = tdbb->getAttachment();

	// Find the LTT by looking up the index
	LocalTemporaryTable* ltt = nullptr;
	LocalTemporaryTable::Index* lttIndex = nullptr;

	if (!MET_get_ltt_index(attachment, work->getQualifiedName(), &ltt, &lttIndex))
		return false;  // LTT or index no longer exists (rolled back?)

	const auto relation = ltt->relation;
	if (!relation)
		return false;

	// Skip inactive indexes
	if (lttIndex->inactive)
		return false;

	// Build the index descriptor
	index_desc idx;
	memset(&idx, 0, sizeof(idx));

	idx.idx_id = lttIndex->id;
	idx.idx_count = lttIndex->columns.getCount();
	idx.idx_flags = 0;

	if (lttIndex->unique)
		idx.idx_flags |= idx_unique;
	if (lttIndex->descending)
		idx.idx_flags |= idx_descending;

	// Build the index key descriptors from LTT field info
	int keyPos = 0;

	for (const auto& colName : lttIndex->columns)
	{
		// Find the field in the LTT
		bool found = false;

		for (const auto& field : ltt->fields)
		{
			if (field.name == colName)
			{
				idx.idx_rpt[keyPos].idx_field = field.id;

				// Determine index type based on field type
				const auto idxType = DFW_assign_index_type(tdbb, work->getQualifiedName(),
					field.desc.dsc_dtype,
					DTYPE_IS_TEXT(field.desc.dsc_dtype) ?
						TTypeId(field.charSetId.value_or(CS_NONE), field.collationId.value_or(COLLATE_NONE)) :
						ttype_none);
				idx.idx_rpt[keyPos].idx_itype = idxType;

				found = true;
				break;
			}
		}

		if (!found)
		{
			ERR_post(Arg::Gds(isc_no_meta_update) <<
					 Arg::Gds(isc_idx_seg_err) << work->getQualifiedName().toQuotedString());
		}

		++keyPos;
	}

	{	// scope
		AutoSetRestoreFlag<ULONG> dbPageSpace(&tdbb->tdbb_flags, TDBB_use_db_page_space, true);

		SelectivityList selectivity(*tdbb->getDefaultPool());
		IDX_create_index(tdbb, IdxCreate::AtOnce, relation, &idx, work->getQualifiedName(),
			&lttIndex->id, transaction, selectivity);
	}

	// Update index on the current instance if it exists
	if (relation->getPermanent()->rel_flags & REL_temp_conn)
	{
		AutoSetRestoreFlag<ULONG> dbPageSpace(&tdbb->tdbb_flags, TDBB_use_db_page_space, false);

		if (relation->getPages(tdbb, 0, false))
		{
			SelectivityList selectivity(*tdbb->getDefaultPool());
			idx.idx_root = 0;
			IDX_create_index(tdbb, IdxCreate::AtOnce, relation, &idx, work->getQualifiedName(),
				&lttIndex->id, transaction, selectivity);
		}
	}

	// Create index description in relation
	auto* idp = relation->getPermanent()->rel_indices.ensurePermanent(tdbb, lttIndex->id);

	// create versioned part
	auto& attPool = *attachment->att_pool;
	AutoPtr<IndexVersion> idv = FB_NEW_POOL(attPool) IndexVersion(attPool, idp);
	idv->setLtt(tdbb, lttIndex);

	idp->storeObject(tdbb, idv, 0);
	idv.release();

	return false;
}


// Delete an index for a Local Temporary Table.
static bool delete_ltt_index(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra* transaction)
{
	switch (phase)
	{
		case 1:
		case 2:
			return true;

		case 3:
			break;

		default:
			return false;
	}

	// The index ID is passed in dfw_id, and the relation ID is stored in dfw_ids
	const USHORT indexId = work->dfw_id;
	const auto& ids = work->dfw_ids;

	if (ids.isEmpty())
		return false;

	const USHORT relationId = ids.front();

	const auto relation = MetadataCache::getVersioned<Cached::Relation>(tdbb, relationId, 0);
	if (!relation)
		return false;

	{	// scope
		AutoSetRestoreFlag<ULONG> noDbPageSpace(&tdbb->tdbb_flags, TDBB_use_db_page_space, true);

		// Get the relation pages
		const auto relPages = relation->getPages(tdbb, MAX_TRA_NUMBER, false);
		if (!relPages || !relPages->rel_index_root)
			return false;

		// Delete the index by its ID
		WIN window(relPages->rel_pg_space_id, relPages->rel_index_root);
		CCH_FETCH(tdbb, &window, LCK_write, pag_root);

		BTR_delete_index(tdbb, &window, indexId, false);
	}

	auto* idp = relation->getPermanent()->eraseIndex(tdbb, indexId);
	idp->commit(tdbb);

	return false;
}


static bool modify_ltt_index(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra* transaction)
{
/**************************************
 *
 *	m o d i f y _ l t t _ i n d e x
 *
 **************************************
 *
 * Functional description
 *	Recalculate statistics for an index on a Local Temporary Table.
 *
 **************************************/

	// Recalculate statistics for an index on a Local Temporary Table.
	switch (phase)
	{
		case 1:
		case 2:
			return true;

		case 3:
			break;

		default:
			return false;
	}

	const auto attachment = tdbb->getAttachment();

	// Find the LTT by looking up the index
	LocalTemporaryTable* ltt = nullptr;
	LocalTemporaryTable::Index* lttIndex = nullptr;

	if (!MET_get_ltt_index(attachment, work->getQualifiedName(), &ltt, &lttIndex))
		return false;  // LTT or index no longer exists (rolled back?)

	const auto relation = ltt->relation;
	if (!relation)
		return false;

	// Skip inactive indexes
	if (lttIndex->inactive)
		return false;

	// Only recalculate statistics if the table has been instantiated
	if (!ltt->relationId)
		return false;

	{	// scope
		AutoSetRestoreFlag<ULONG> dbPageSpace(&tdbb->tdbb_flags, TDBB_use_db_page_space, true);

		// Recalculate index statistics
		SelectivityList selectivity(*tdbb->getDefaultPool());
		IDX_statistics(tdbb, relation->getPermanent(), lttIndex->id, selectivity);

		// The selectivity is stored directly in the index root page by IDX_statistics,
		// so we don't need to update any system tables (LTT indexes don't have entries in RDB$INDICES)
	}

	return false;
}


// Make a new format version for a LTT.
static bool make_ltt_version(thread_db* tdbb, SSHORT phase, DeferredWork* work, jrd_tra* transaction)
{
	switch (phase)
	{
		case 1:
		case 2:
			return true;

		case 3:
			break;

		default:
			return false;
	}

	const auto attachment = tdbb->getAttachment();
	const auto dbb = tdbb->getDatabase();
	auto& attPool = *attachment->att_pool;

	const auto lttPtr = attachment->att_local_temporary_tables.get(work->getQualifiedName());
	if (!lttPtr)
		return false;

	const auto ltt = *lttPtr;

	if (!ltt->hasPendingChanges)
		return false;

	fb_assert(ltt->pendingFields.hasData());

	jrd_rel* relation = ltt->relation;
	const bool isAlter = (relation != nullptr);

	if (!isAlter)
	{
		fb_assert(ltt->relationId != 0);

		// CREATE: Create a new relation
		AutoPtr<Cached::Relation> permRel = FB_NEW_POOL(attPool) Cached::Relation(tdbb, attPool, ltt->relationId);
		permRel->rel_name = ltt->name;
		permRel->rel_flags = REL_sql_relation | REL_temp_ltt |
			(ltt->relationType == rel_temp_preserve ? REL_temp_conn : REL_temp_tran);

		// Initialize base pages for LTT to act as a connection-wide blueprint for indexes.
		permRel->getBasePages()->rel_pg_space_id = dbb->dbb_page_manager.getTempPageSpaceID(tdbb);
		DPM_create_relation_pages(tdbb, permRel, permRel->getBasePages());

		// create versioned part
		AutoPtr<jrd_rel> versRel = FB_NEW_POOL(attPool) jrd_rel(attPool, permRel);
		permRel->storeObject(tdbb, versRel, 0);
		permRel.release();
		relation = versRel.release();

		relation->rel_current_fmt = 1;

		// Note: LTTs should NOT be registered in mdc_relations.
		// They are stored only in att_local_temporary_tables and accessed via getXxx<Cached::Relation>.
	}
	else
	{
		// ALTER: Bump the format version
		if (relation->rel_current_fmt == MAX_TABLE_VERSIONS)
			RelationNode::raiseTooManyVersionsError(obj_relation, work->getQualifiedName());

		relation->rel_current_fmt++;
	}

	// Update the fields vector - extend if needed for new fields
	relation->rel_fields = vec<jrd_fld*>::newVector(attPool, relation->rel_fields, ltt->pendingFields.getCount());

	TemporaryField* tempFields = nullptr;

	for (FB_SIZE_T i = 0; i < ltt->pendingFields.getCount(); ++i)
	{
		const auto& lttField = ltt->pendingFields[i];
		auto& relField = (*relation->rel_fields)[i];

		if (!relField)
			relField = FB_NEW_POOL(attPool) jrd_fld(attPool);

		relField->fld_name = lttField.name;
		relField->fld_not_null = nullptr;
		relField->fld_validation = nullptr;

		if (lttField.notNullFlag)
		{
			Jrd::ContextPoolHolder context(tdbb, &attPool);
			relField->fld_not_null = PAR_validation_blr(tdbb, &relation->getName().schema, relation->getPermanent(),
				nonnull_validation_blr, sizeof(nonnull_validation_blr), NULL, NULL, 0);
		}

		const auto tempField = FB_NEW_POOL(attPool) TemporaryField();
		tempField->tfb_next = tempFields;
		tempFields = tempField;

		tempField->tfb_desc = lttField.desc;

		// For text types, set the text type from charset/collation
		if (DTYPE_IS_TEXT(lttField.desc.dsc_dtype))
		{
			const auto charSetId = lttField.charSetId.value_or(CS_NONE);
			const auto collationId = lttField.collationId.value_or(COLLATE_NONE);
			tempField->tfb_desc.setTextType(TTypeId(charSetId, collationId));
		}

		memset(&tempField->tfb_default, 0, sizeof(tempField->tfb_default));
		tempField->tfb_id = lttField.id;
	}

	relation->rel_current_format = RelationNode::makeFormat(tdbb, transaction,
		relation->getPermanent(), &relation->rel_current_fmt, tempFields);

	// Store the runtime relation in the LTT (for CREATE case)
	ltt->relation = relation;

	// Commit the changes: copy pendingFields to fields
	ltt->fields = ltt->pendingFields;
	ltt->pendingFields.clear();
	ltt->hasPendingChanges = false;

	// Now invalidate DSQL cache at commit time
	// METD_drop_relation(transaction, work->getQualifiedName());

	return false;
}


