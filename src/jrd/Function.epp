/*
 * The contents of this file are subject to the Interbase Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.Inprise.com/IPL.html
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code was created by Inprise Corporation
 * and its predecessors. Portions created by Inprise Corporation are
 * Copyright (C) Inprise Corporation.
 *
 * All Rights Reserved.
 * Contributor(s): ______________________________________.
 */

#include "firebird.h"
#include "../common/gdsassert.h"
#include "../jrd/flags.h"
#include "../jrd/jrd.h"
#include "../jrd/val.h"
#include "../jrd/irq.h"
#include "../jrd/tra.h"
#include "../jrd/lck.h"
#include "../jrd/req.h"
#include "../jrd/exe.h"
#include "../jrd/blb.h"
#include "../jrd/met.h"
#include "../jrd/align.h"
#include "../dsql/ExprNodes.h"
#include "../dsql/StmtNodes.h"
#include "../jrd/blb_proto.h"
#include "../jrd/cmp_proto.h"
#include "../common/dsc_proto.h"
#include "../jrd/evl_proto.h"
#include "../jrd/exe_proto.h"
#include "../jrd/flu_proto.h"
#include "../jrd/fun_proto.h"
#include "../jrd/lck.h"
#include "../jrd/met_proto.h"
#include "../jrd/mov_proto.h"
#include "../jrd/par_proto.h"
#include "../jrd/vio_proto.h"
#include "../common/utils_proto.h"
#include "../jrd/DebugInterface.h"
#include "../jrd/QualifiedName.h"
#include "../jrd/Statement.h"
#include "../jrd/trace/TraceJrdHelpers.h"

#include "../jrd/Function.h"

using namespace Firebird;
using namespace Jrd;

DATABASE DB = FILENAME "ODS.RDB";

const char* const Function::EXCEPTION_MESSAGE = "The user defined function: \t%s\n\t   referencing"
	" entrypoint: \t%s\n\t                in module: \t%s\n\tcaused the fatal exception:";


Function* Function::lookup(thread_db* tdbb, MetaId id, ObjectBase::Flag flags)
{
	return MetadataCache::getVersioned<Cached::Function>(tdbb, id, flags);
}


Function* Function::create(thread_db* tdbb, MemoryPool& pool, Cached::Function* perm)
{
	return FB_NEW_POOL(perm->getPool()) Function(perm);
}


Function* Function::lookup(thread_db* tdbb, const QualifiedName& name, ObjectBase::Flag flags)
{
	return MetadataCache::getVersioned<Cached::Function>(tdbb, name, flags);
}

ScanResult Function::scan(thread_db* tdbb, ObjectBase::Flag flags)
{
	Attachment* attachment = tdbb->getAttachment();
	jrd_tra* metaTransaction = attachment->getMetaTransaction(tdbb);
	Database* dbb = tdbb->getDatabase();
	MetadataCache* mdc = dbb->dbb_mdc;

	MemoryPool& pool = getPermanent()->getPool();
	bool found = false;

	//try
	{
		AutoCacheRequest request_fun(tdbb, irq_l_functions, IRQ_REQUESTS);

		FOR(REQUEST_HANDLE request_fun TRANSACTION_HANDLE metaTransaction)
			X IN RDB$FUNCTIONS
			CROSS SCH IN RDB$SCHEMAS
			OVER RDB$SCHEMA_NAME
			WITH X.RDB$FUNCTION_ID EQ getId()
		{
			found = true;

			getPermanent()->setName(QualifiedName(X.RDB$FUNCTION_NAME, X.RDB$SCHEMA_NAME,
				(X.RDB$PACKAGE_NAME.NULL ? nullptr : X.RDB$PACKAGE_NAME)));
			getPermanent()->owner = X.RDB$OWNER_NAME;

			TriState ssDefiner;

			if (!X.RDB$SECURITY_CLASS.NULL)
				getPermanent()->setSecurityName(QualifiedName(X.RDB$SECURITY_CLASS, SCH.RDB$SECURITY_CLASS));
			else if (!X.RDB$PACKAGE_NAME.NULL)
			{
				AutoCacheRequest requestHandle(tdbb, irq_l_procedure_pkg_class, IRQ_REQUESTS);

				FOR (REQUEST_HANDLE requestHandle TRANSACTION_HANDLE metaTransaction)
					PKG IN RDB$PACKAGES
					WITH PKG.RDB$SCHEMA_NAME EQ SCH.RDB$SCHEMA_NAME AND
						 PKG.RDB$PACKAGE_NAME EQ X.RDB$PACKAGE_NAME
				{
					if (!PKG.RDB$SECURITY_CLASS.NULL)
						getPermanent()->setSecurityName(QualifiedName(PKG.RDB$SECURITY_CLASS, SCH.RDB$SECURITY_CLASS));

					// SQL SECURITY of function must be the same if it's defined in package
					if (!PKG.RDB$SQL_SECURITY.NULL)
						ssDefiner = (bool) PKG.RDB$SQL_SECURITY;
				}
				END_FOR
			}

			if (!ssDefiner.isAssigned())
			{
				if (!X.RDB$SQL_SECURITY.NULL)
					ssDefiner = (bool) X.RDB$SQL_SECURITY;
				else
					ssDefiner = MET_get_ss_definer(tdbb, X.RDB$SCHEMA_NAME);
			}

			if (ssDefiner.asBool())
				invoker = dbb->getUserId(getPermanent()->owner);

			size_t count = 0;
			ULONG length = 0;

			fun_inputs = 0;
			setDefaultCount(0);

			getInputFields().clear();
			getOutputFields().clear();

			AutoCacheRequest request_arg(tdbb, irq_l_args, IRQ_REQUESTS);

			FOR(REQUEST_HANDLE request_arg TRANSACTION_HANDLE metaTransaction)
				Y IN RDB$FUNCTION_ARGUMENTS
				WITH Y.RDB$SCHEMA_NAME EQ getName().schema.c_str() AND
					 Y.RDB$FUNCTION_NAME EQ getName().object.c_str() AND
					 Y.RDB$PACKAGE_NAME EQUIV NULLIF(getName().package.c_str(), '')
				SORTED BY Y.RDB$ARGUMENT_POSITION
			{
				Parameter* parameter = FB_NEW_POOL(pool) Parameter(pool);

				if (Y.RDB$ARGUMENT_POSITION != X.RDB$RETURN_ARGUMENT)
				{
					fun_inputs++;
					int newCount = Y.RDB$ARGUMENT_POSITION - getOutputFields().getCount();
					fb_assert(newCount >= 0);

					getInputFields().resize(newCount + 1);
					getInputFields()[newCount] = parameter;
				}
				else
				{
					fb_assert(getOutputFields().isEmpty());
					getOutputFields().add(parameter);
				}

				parameter->prm_fun_mechanism = (FUN_T) Y.RDB$MECHANISM;
				parameter->prm_number = Y.RDB$ARGUMENT_POSITION;
				parameter->prm_name = Y.RDB$ARGUMENT_NAME.NULL ? "" : Y.RDB$ARGUMENT_NAME;
				parameter->prm_nullable = Y.RDB$NULL_FLAG.NULL || Y.RDB$NULL_FLAG == 0;
				parameter->prm_mechanism = Y.RDB$ARGUMENT_MECHANISM.NULL ?
					prm_mech_normal : (prm_mech_t) Y.RDB$ARGUMENT_MECHANISM;

				const SSHORT collation_id_null = Y.RDB$COLLATION_ID.NULL;
				const CollId collation_id(Y.RDB$COLLATION_ID);

				SSHORT default_value_null = Y.RDB$DEFAULT_VALUE.NULL;
				bid default_value = Y.RDB$DEFAULT_VALUE;

				if (!Y.RDB$FIELD_SOURCE.NULL)
				{
					parameter->prm_field_source = QualifiedName(Y.RDB$FIELD_SOURCE, Y.RDB$FIELD_SOURCE_SCHEMA_NAME);

					AutoCacheRequest request_arg_fld(tdbb, irq_l_arg_fld, IRQ_REQUESTS);

					FOR(REQUEST_HANDLE request_arg_fld TRANSACTION_HANDLE metaTransaction)
						F IN RDB$FIELDS
						WITH F.RDB$SCHEMA_NAME = Y.RDB$FIELD_SOURCE_SCHEMA_NAME AND
							 F.RDB$FIELD_NAME = Y.RDB$FIELD_SOURCE
					{
						DSC_make_descriptor(&parameter->prm_desc, F.RDB$FIELD_TYPE,
											F.RDB$FIELD_SCALE, F.RDB$FIELD_LENGTH,
											F.RDB$FIELD_SUB_TYPE, CSetId(F.RDB$CHARACTER_SET_ID),
											(collation_id_null ? CollId(F.RDB$COLLATION_ID) : collation_id));

						if (default_value_null && fb_utils::implicit_domain(F.RDB$FIELD_NAME))
						{
							default_value_null = F.RDB$DEFAULT_VALUE.NULL;
							default_value = F.RDB$DEFAULT_VALUE;
						}
					}
					END_FOR
				}
				else
				{
					DSC_make_descriptor(&parameter->prm_desc, Y.RDB$FIELD_TYPE,
										Y.RDB$FIELD_SCALE, Y.RDB$FIELD_LENGTH,
										Y.RDB$FIELD_SUB_TYPE, CSetId(Y.RDB$CHARACTER_SET_ID),
										(collation_id_null ? CollId(0) : collation_id));
				}

				if (parameter->prm_desc.isText() && parameter->prm_desc.getTextType() != CS_NONE)
				{
					if (!collation_id_null ||
						(!Y.RDB$FIELD_SOURCE.NULL && fb_utils::implicit_domain(Y.RDB$FIELD_SOURCE)))
					{
						parameter->prm_text_type = parameter->prm_desc.getTextType();
					}
				}

				if (!Y.RDB$RELATION_NAME.NULL)
					parameter->prm_type_of_table = QualifiedName(Y.RDB$RELATION_NAME, Y.RDB$RELATION_SCHEMA_NAME);

				if (!Y.RDB$FIELD_NAME.NULL)
					parameter->prm_type_of_column = Y.RDB$FIELD_NAME;

				if (Y.RDB$ARGUMENT_POSITION != X.RDB$RETURN_ARGUMENT && !default_value_null)
				{
					setDefaultCount(getDefaultCount() + 1);

					MemoryPool* const csb_pool = dbb->createPool();
					Jrd::ContextPoolHolder context(tdbb, csb_pool);

					try
					{
						parameter->prm_default_value = static_cast<ValueExprNode*>(MET_parse_blob(tdbb,
							&getName().schema, nullptr, &default_value, nullptr, nullptr, false, false));
					}
					catch (const Exception&)
					{
						dbb->deletePool(csb_pool);
						throw; // an explicit error message would be better
					}
				}

				if (parameter->prm_desc.dsc_dtype == dtype_cstring)
					parameter->prm_desc.dsc_length++;

				length += (parameter->prm_desc.dsc_dtype == dtype_blob) ?
					sizeof(udf_blob) : FB_ALIGN(parameter->prm_desc.dsc_length, FB_DOUBLE_ALIGN);

				count = MAX(count, size_t(Y.RDB$ARGUMENT_POSITION));
			}
			END_FOR

			for (int i = (int) getInputFields().getCount() - 1; i >= 0; --i)
			{
				if (!getInputFields()[i])
					getInputFields().remove(i);
			}

			fun_return_arg = X.RDB$RETURN_ARGUMENT;
			fun_temp_length = length;

			// Prepare the exception message to be used in case this function ever
			// causes an exception.  This is done at this time to save us from preparing
			// (thus allocating) this message every time the function is called.
			fun_exception_message.printf(EXCEPTION_MESSAGE,
				getName().toQuotedString().c_str(), X.RDB$ENTRYPOINT, X.RDB$MODULE_NAME);

			if (!X.RDB$DETERMINISTIC_FLAG.NULL)
				fun_deterministic = (X.RDB$DETERMINISTIC_FLAG != 0);

			setDefined(true);

			fun_entrypoint = nullptr;
			fun_external = nullptr;
			setStatement(nullptr);

			if (!X.RDB$MODULE_NAME.NULL && !X.RDB$ENTRYPOINT.NULL)
			{
				fun_entrypoint =
					Module::lookup(X.RDB$MODULE_NAME, X.RDB$ENTRYPOINT, dbb);

				// Could not find a function with given MODULE, ENTRYPOINT.
				// Try the list of internally implemented functions.
				if (!fun_entrypoint)
				{
					fun_entrypoint =
						BUILTIN_entrypoint(X.RDB$MODULE_NAME, X.RDB$ENTRYPOINT);
				}

				if (!fun_entrypoint)
					setDefined(false);

				setImplemented(true);
			}
			else if (!X.RDB$ENGINE_NAME.NULL || !X.RDB$FUNCTION_BLR.NULL)
			{
				MemoryPool* const csb_pool = dbb->createPool();
				Jrd::ContextPoolHolder context(tdbb, csb_pool);

				try
				{
					AutoPtr<CompilerScratch> csb(FB_NEW_POOL(*csb_pool) CompilerScratch(*csb_pool));

					if (!X.RDB$ENGINE_NAME.NULL)
					{
						HalfStaticArray<UCHAR, 512> body;

						if (!X.RDB$FUNCTION_SOURCE.NULL)
						{
							blb* const blob = blb::open(tdbb, metaTransaction, &X.RDB$FUNCTION_SOURCE);
							const ULONG len = blob->BLB_get_data(tdbb,
								body.getBuffer(blob->blb_length + 1), blob->blb_length + 1);
							body[MIN(blob->blb_length, len)] = 0;
						}
						else
							body.getBuffer(1)[0] = 0;

						dbb->dbb_extManager->makeFunction(tdbb, csb, this, X.RDB$ENGINE_NAME,
							(X.RDB$ENTRYPOINT.NULL ? "" : X.RDB$ENTRYPOINT), (char*) body.begin());

						if (!fun_external)
							setDefined(false);

						setImplemented(true);
					}
					else if (compiling || (flags & CacheFlag::MINISCAN))
						flReload = true;
					else
					{
						fb_assert(!X.RDB$FUNCTION_BLR.NULL);

						const string name = getName().toQuotedString();
						try
						{
							TraceFuncCompile trace(tdbb, name);

							parseBlr(tdbb, csb, &X.RDB$FUNCTION_BLR,
								X.RDB$DEBUG_INFO.NULL ? nullptr : &X.RDB$DEBUG_INFO);

							trace.finish(getStatement(), ITracePlugin::RESULT_SUCCESS);
						}
						catch (const Exception& ex)
						{
							StaticStatusVector temp_status;
							ex.stuffException(temp_status);
							(Arg::StatusVector(temp_status.begin()) <<
								Arg::Gds(isc_bad_fun_BLR) << Arg::Str(name)).raise();
						}
					}
				}
				catch (const Exception&)
				{
					dbb->deletePool(csb_pool);
					throw;
				}

				fb_assert(!isDefined() || flReload || this == getStatement()->function);
			}
			else
			{
				RefPtr<MsgMetadata> inputMetadata(REF_NO_INCR, createMetadata(getInputFields(), false));
				setInputFormat(createFormat(pool, inputMetadata, false));

				RefPtr<MsgMetadata> outputMetadata(REF_NO_INCR, createMetadata(getOutputFields(), false));
				setOutputFormat(createFormat(pool, outputMetadata, true));

				if (compiling || (flags & CacheFlag::MINISCAN))
					flReload = true;
			}

			if (!dbb->readOnly() &&
				!X.RDB$FUNCTION_BLR.NULL &&
				!X.RDB$VALID_BLR.NULL && X.RDB$VALID_BLR == FALSE)
			{
				// If the BLR was marked as invalid but the function was compiled,
				// mark the BLR as valid.

				MODIFY X USING
					X.RDB$VALID_BLR = TRUE;
					X.RDB$VALID_BLR.NULL = FALSE;
				END_MODIFY
			}
		}
		END_FOR
	}

	return found ? (this->flReload ? ScanResult::REPEAT : ScanResult::COMPLETE) : ScanResult::MISS;
}

ScanResult Function::reload(thread_db* tdbb, ObjectBase::Flag /*unused*/)
{
	Attachment* attachment = tdbb->getAttachment();
	Database* dbb = tdbb->getDatabase();
	jrd_tra* metaTransaction = attachment->getMetaTransaction(tdbb);
	AutoCacheRequest request(tdbb, irq_l_funct_blr, IRQ_REQUESTS);

	bool found = false;

	FOR(REQUEST_HANDLE request TRANSACTION_HANDLE metaTransaction)
		X IN RDB$FUNCTIONS
		WITH X.RDB$FUNCTION_ID EQ this->getId()
	{
		// sanity check
		if (compiling || X.RDB$FUNCTION_BLR.NULL)
			return ScanResult::REPEAT;

		found = true;

		MemoryPool* const csb_pool = dbb->createPool();
		Jrd::ContextPoolHolder context(tdbb, csb_pool);

		try
		{
			AutoPtr<CompilerScratch> csb(FB_NEW_POOL(*csb_pool) CompilerScratch(*csb_pool));

			try
			{
				this->parseBlr(tdbb, csb, &X.RDB$FUNCTION_BLR,
					X.RDB$DEBUG_INFO.NULL ? nullptr : &X.RDB$DEBUG_INFO);
			}
			catch (const Exception& ex)
			{
				StaticStatusVector temp_status;
				ex.stuffException(temp_status);

				const string name = this->getName().toQuotedString();
				(Arg::StatusVector(temp_status.begin()) <<
					Arg::Gds(isc_bad_fun_BLR) << Arg::Str(name)).raise();
			}
		}
		catch (const Exception&)
		{
			dbb->deletePool(csb_pool);
			throw;
		}
	}
	END_FOR

	return found ? ScanResult::COMPLETE : ScanResult::MISS;
}

int Function::objectType()
{
	return obj_udf;
}

void Function::checkReload(thread_db* tdbb) const
{
	if (flReload)
		getPermanent()->reload(tdbb, 0);
}

