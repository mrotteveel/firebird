/*
 * The contents of this file are subject to the Interbase Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.Inprise.com/IPL.html
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code was created by Inprise Corporation
 * and its predecessors. Portions created by Inprise Corporation are
 * Copyright (C) Inprise Corporation.
 *
 * All Rights Reserved.
 * Contributor(s): ______________________________________.
 */

#include "firebird.h"
#include "../common/gdsassert.h"
#include "../jrd/flags.h"
#include "../jrd/jrd.h"
#include "../jrd/val.h"
#include "../jrd/irq.h"
#include "../jrd/tra.h"
#include "../jrd/lck.h"
#include "../jrd/req.h"
#include "../jrd/exe.h"
#include "../jrd/blb.h"
#include "../jrd/met.h"
#include "../jrd/align.h"
#include "../dsql/ExprNodes.h"
#include "../dsql/StmtNodes.h"
#include "../jrd/blb_proto.h"
#include "../jrd/cmp_proto.h"
#include "../common/dsc_proto.h"
#include "../jrd/evl_proto.h"
#include "../jrd/exe_proto.h"
#include "../jrd/flu_proto.h"
#include "../jrd/fun_proto.h"
#include "../jrd/lck.h"
#include "../jrd/met_proto.h"
#include "../jrd/mov_proto.h"
#include "../jrd/par_proto.h"
#include "../jrd/vio_proto.h"
#include "../common/utils_proto.h"
#include "../jrd/DebugInterface.h"
#include "../jrd/QualifiedName.h"
#include "../jrd/Statement.h"

#include "../jrd/Function.h"

using namespace Firebird;
using namespace Jrd;

DATABASE DB = FILENAME "ODS.RDB";

const char* const Function::EXCEPTION_MESSAGE = "The user defined function: \t%s\n\t   referencing"
	" entrypoint: \t%s\n\t                in module: \t%s\n\tcaused the fatal exception:";


Function* Function::lookup(thread_db* tdbb, MetaId id, ObjectBase::Flag flags)
{
	Database* const dbb = tdbb->getDatabase();

	Function* function = dbb->dbb_mdc->getFunction(tdbb, id, flags | CacheFlag::AUTOCREATE);
	return function;
}


Function* Function::create(thread_db* tdbb, MemoryPool& pool, Cached::Function* perm)
{
	return FB_NEW_POOL(perm->getPool()) Function(perm);
}


Function* Function::lookup(thread_db* tdbb, const QualifiedName& name, ObjectBase::Flag flags)
{
	Attachment* const attachment = tdbb->getAttachment();
	Database* const dbb = tdbb->getDatabase();

	// See if we already know the function by name
	Function* function = dbb->dbb_mdc->lookup_function(tdbb, name);
	if (function)
		return function;

	// We need to look up the function in RDB$FUNCTIONS
	AutoCacheRequest request(tdbb, irq_l_fun_name, IRQ_REQUESTS);
	FOR(REQUEST_HANDLE request)
		X IN RDB$FUNCTIONS
		WITH X.RDB$FUNCTION_NAME EQ name.identifier.c_str() AND
			 X.RDB$PACKAGE_NAME EQUIV NULLIF(name.package.c_str(), '')
	{
		if (!function)
			function = dbb->dbb_mdc->getFunction(tdbb, X.RDB$FUNCTION_ID, flags);
	}
	END_FOR

	return function;
}

Lock* Function::makeLock(thread_db* tdbb, MemoryPool& p)
{
	return FB_NEW_RPT(p, 0) Lock(tdbb, sizeof(SLONG), LCK_fun_exist, nullptr, blockingAst);
}

int Function::blockingAst(void* ast_object)
{
	auto* const function = static_cast<Cached::Function*>(ast_object);

	try
	{
		Database* const dbb = function->existenceLock->lck_dbb;

		AsyncContextHolder tdbb(dbb, FB_FUNCTION, function->existenceLock);

		LCK_release(tdbb, function->existenceLock);
		function->resetDependentObject(tdbb, ElementBase::ResetType::Mark);
	}
	catch (const Firebird::Exception&)
	{} // no-op

	return 0;
}

void Function::scan(thread_db* tdbb, ObjectBase::Flag)
{
	Attachment* attachment = tdbb->getAttachment();
	jrd_tra* sysTransaction = attachment->getSysTransaction();
	Database* dbb = tdbb->getDatabase();
	MetadataCache* mdc = dbb->dbb_mdc;

	MemoryPool& pool = getPermanent()->getPool();

	//try
	{
		AutoCacheRequest request_fun(tdbb, irq_l_functions, IRQ_REQUESTS);

		FOR(REQUEST_HANDLE request_fun)
			X IN RDB$FUNCTIONS
			WITH X.RDB$FUNCTION_ID EQ getPermanent()->getId()
		{
			getPermanent()->setName(QualifiedName(X.RDB$FUNCTION_NAME,
				(X.RDB$PACKAGE_NAME.NULL ? nullptr : X.RDB$PACKAGE_NAME)));
			getPermanent()->owner = X.RDB$OWNER_NAME;

			Nullable<bool> ssDefiner;

			if (!X.RDB$SECURITY_CLASS.NULL)
			{
				getPermanent()->setSecurityName(X.RDB$SECURITY_CLASS);
			}
			else if (!X.RDB$PACKAGE_NAME.NULL)
			{
				AutoCacheRequest requestHandle(tdbb, irq_l_procedure_pkg_class, IRQ_REQUESTS);

				FOR (REQUEST_HANDLE requestHandle)
					PKG IN RDB$PACKAGES
					WITH PKG.RDB$PACKAGE_NAME EQ X.RDB$PACKAGE_NAME

					if (!PKG.RDB$SECURITY_CLASS.NULL)
					{
						getPermanent()->setSecurityName(PKG.RDB$SECURITY_CLASS);
					}

					// SQL SECURITY of function must be the same if it's defined in package
					if (!PKG.RDB$SQL_SECURITY.NULL)
						ssDefiner = (bool) PKG.RDB$SQL_SECURITY;

				END_FOR
			}

			if (!ssDefiner.specified)
			{
				if (!X.RDB$SQL_SECURITY.NULL)
					ssDefiner = (bool) X.RDB$SQL_SECURITY;
				else
					ssDefiner = MET_get_ss_definer(tdbb);
			}

			if (ssDefiner.orElse(false))
				invoker = attachment->getUserId(getPermanent()->owner);

			size_t count = 0;
			ULONG length = 0;

			fun_inputs = 0;
			setDefaultCount(0);

			getInputFields().clear();
			getOutputFields().clear();

			AutoCacheRequest request_arg(tdbb, irq_l_args, IRQ_REQUESTS);

			FOR(REQUEST_HANDLE request_arg)
				Y IN RDB$FUNCTION_ARGUMENTS
				WITH Y.RDB$FUNCTION_NAME EQ getName().identifier.c_str() AND
					 Y.RDB$PACKAGE_NAME EQUIV NULLIF(getName().package.c_str(), '')
				SORTED BY Y.RDB$ARGUMENT_POSITION
			{
				Parameter* parameter = FB_NEW_POOL(pool) Parameter(pool);

				if (Y.RDB$ARGUMENT_POSITION != X.RDB$RETURN_ARGUMENT)
				{
					fun_inputs++;
					int newCount = Y.RDB$ARGUMENT_POSITION - getOutputFields().getCount();
					fb_assert(newCount >= 0);

					getInputFields().resize(newCount + 1);
					getInputFields()[newCount] = parameter;
				}
				else
				{
					fb_assert(getOutputFields().isEmpty());
					getOutputFields().add(parameter);
				}

				parameter->prm_fun_mechanism = (FUN_T) Y.RDB$MECHANISM;
				parameter->prm_number = Y.RDB$ARGUMENT_POSITION;
				parameter->prm_name = Y.RDB$ARGUMENT_NAME.NULL ? "" : Y.RDB$ARGUMENT_NAME;
				parameter->prm_nullable = Y.RDB$NULL_FLAG.NULL || Y.RDB$NULL_FLAG == 0;
				parameter->prm_mechanism = Y.RDB$ARGUMENT_MECHANISM.NULL ?
					prm_mech_normal : (prm_mech_t) Y.RDB$ARGUMENT_MECHANISM;

				const SSHORT collation_id_null = Y.RDB$COLLATION_ID.NULL;
				const SSHORT collation_id = Y.RDB$COLLATION_ID;

				SSHORT default_value_null = Y.RDB$DEFAULT_VALUE.NULL;
				bid default_value = Y.RDB$DEFAULT_VALUE;

				if (!Y.RDB$FIELD_SOURCE.NULL)
				{
					parameter->prm_field_source = Y.RDB$FIELD_SOURCE;

					AutoCacheRequest request_arg_fld(tdbb, irq_l_arg_fld, IRQ_REQUESTS);

					FOR(REQUEST_HANDLE request_arg_fld)
						F IN RDB$FIELDS
						WITH F.RDB$FIELD_NAME = Y.RDB$FIELD_SOURCE
					{
						DSC_make_descriptor(&parameter->prm_desc, F.RDB$FIELD_TYPE,
											F.RDB$FIELD_SCALE, F.RDB$FIELD_LENGTH,
											F.RDB$FIELD_SUB_TYPE, F.RDB$CHARACTER_SET_ID,
											(collation_id_null ? F.RDB$COLLATION_ID : collation_id));

						if (default_value_null && fb_utils::implicit_domain(F.RDB$FIELD_NAME))
						{
							default_value_null = F.RDB$DEFAULT_VALUE.NULL;
							default_value = F.RDB$DEFAULT_VALUE;
						}
					}
					END_FOR
				}
				else
				{
					DSC_make_descriptor(&parameter->prm_desc, Y.RDB$FIELD_TYPE,
										Y.RDB$FIELD_SCALE, Y.RDB$FIELD_LENGTH,
										Y.RDB$FIELD_SUB_TYPE, Y.RDB$CHARACTER_SET_ID,
										(collation_id_null ? 0 : collation_id));
				}

				if (parameter->prm_desc.isText() && parameter->prm_desc.getTextType() != CS_NONE)
				{
					if (!collation_id_null ||
						(!Y.RDB$FIELD_SOURCE.NULL && fb_utils::implicit_domain(Y.RDB$FIELD_SOURCE)))
					{
						parameter->prm_text_type = parameter->prm_desc.getTextType();
					}
				}

				if (!Y.RDB$RELATION_NAME.NULL)
					parameter->prm_type_of_table = Y.RDB$RELATION_NAME;

				if (!Y.RDB$FIELD_NAME.NULL)
					parameter->prm_type_of_column = Y.RDB$FIELD_NAME;

				if (Y.RDB$ARGUMENT_POSITION != X.RDB$RETURN_ARGUMENT && !default_value_null)
				{
					setDefaultCount(getDefaultCount() + 1);

					MemoryPool* const csb_pool = dbb->createPool();
					Jrd::ContextPoolHolder context(tdbb, csb_pool);

					try
					{
						parameter->prm_default_value = static_cast<ValueExprNode*>(MET_parse_blob(
							tdbb, nullptr, &default_value, nullptr, nullptr, false, false));
					}
					catch (const Exception&)
					{
						dbb->deletePool(csb_pool);
						throw; // an explicit error message would be better
					}
				}

				if (parameter->prm_desc.dsc_dtype == dtype_cstring)
					parameter->prm_desc.dsc_length++;

				length += (parameter->prm_desc.dsc_dtype == dtype_blob) ?
					sizeof(udf_blob) : FB_ALIGN(parameter->prm_desc.dsc_length, FB_DOUBLE_ALIGN);

				count = MAX(count, size_t(Y.RDB$ARGUMENT_POSITION));
			}
			END_FOR

			for (int i = (int) getInputFields().getCount() - 1; i >= 0; --i)
			{
				if (!getInputFields()[i])
					getInputFields().remove(i);
			}

			fun_return_arg = X.RDB$RETURN_ARGUMENT;
			fun_temp_length = length;

			// Prepare the exception message to be used in case this function ever
			// causes an exception.  This is done at this time to save us from preparing
			// (thus allocating) this message every time the function is called.
			fun_exception_message.printf(EXCEPTION_MESSAGE,
				getName().toString().c_str(), X.RDB$ENTRYPOINT, X.RDB$MODULE_NAME);

			if (!X.RDB$DETERMINISTIC_FLAG.NULL)
				fun_deterministic = (X.RDB$DETERMINISTIC_FLAG != 0);

			setImplemented(true);
			setDefined(true);

			fun_entrypoint = nullptr;
			fun_external = nullptr;
			setStatement(nullptr);

			if (!X.RDB$MODULE_NAME.NULL && !X.RDB$ENTRYPOINT.NULL)
			{
				fun_entrypoint =
					Module::lookup(X.RDB$MODULE_NAME, X.RDB$ENTRYPOINT, dbb);

				// Could not find a function with given MODULE, ENTRYPOINT.
				// Try the list of internally implemented functions.
				if (!fun_entrypoint)
				{
					fun_entrypoint =
						BUILTIN_entrypoint(X.RDB$MODULE_NAME, X.RDB$ENTRYPOINT);
				}

				if (!fun_entrypoint)
					setDefined(false);
			}
			else if (!X.RDB$ENGINE_NAME.NULL || !X.RDB$FUNCTION_BLR.NULL)
			{
				MemoryPool* const csb_pool = dbb->createPool();
				Jrd::ContextPoolHolder context(tdbb, csb_pool);

				try
				{
					AutoPtr<CompilerScratch> csb(FB_NEW_POOL(*csb_pool) CompilerScratch(*csb_pool));

					if (!X.RDB$ENGINE_NAME.NULL)
					{
						HalfStaticArray<UCHAR, 512> body;

						if (!X.RDB$FUNCTION_SOURCE.NULL)
						{
							blb* const blob = blb::open(tdbb, sysTransaction, &X.RDB$FUNCTION_SOURCE);
							const ULONG len = blob->BLB_get_data(tdbb,
								body.getBuffer(blob->blb_length + 1), blob->blb_length + 1);
							body[MIN(blob->blb_length, len)] = 0;
						}
						else
							body.getBuffer(1)[0] = 0;

						dbb->dbb_extManager->makeFunction(tdbb, csb, this, X.RDB$ENGINE_NAME,
							(X.RDB$ENTRYPOINT.NULL ? "" : X.RDB$ENTRYPOINT), (char*) body.begin());

						if (!fun_external)
							setDefined(false);
					}
					else if (!X.RDB$FUNCTION_BLR.NULL)
					{
						try
						{
							parseBlr(tdbb, csb, &X.RDB$FUNCTION_BLR,
								X.RDB$DEBUG_INFO.NULL ? nullptr : &X.RDB$DEBUG_INFO);
						}
						catch (const Exception& ex)
						{
							StaticStatusVector temp_status;
							ex.stuffException(temp_status);
							const string name = getName().toString();
							(Arg::Gds(isc_bad_fun_BLR) << Arg::Str(name)
								<< Arg::StatusVector(temp_status.begin())).raise();
						}
					}
				}
				catch (const Exception&)
				{
					dbb->deletePool(csb_pool);
					throw;
				}

				fb_assert(!isDefined() || this == getStatement()->function);
			}
			else
			{
				RefPtr<MsgMetadata> inputMetadata(REF_NO_INCR, createMetadata(getInputFields(), false));
				setInputFormat(createFormat(pool, inputMetadata, false));

				RefPtr<MsgMetadata> outputMetadata(REF_NO_INCR, createMetadata(getOutputFields(), false));
				setOutputFormat(createFormat(pool, outputMetadata, true));

				setImplemented(false);
			}

			if (!dbb->readOnly() &&
				!X.RDB$FUNCTION_BLR.NULL &&
				!X.RDB$VALID_BLR.NULL && X.RDB$VALID_BLR == FALSE)
			{
				// If the BLR was marked as invalid but the function was compiled,
				// mark the BLR as valid.

				MODIFY X USING
					X.RDB$VALID_BLR = TRUE;
					X.RDB$VALID_BLR.NULL = FALSE;
				END_MODIFY
			}
		}
		END_FOR
	}
}

bool Function::reload(thread_db* tdbb)
{
	Attachment* attachment = tdbb->getAttachment();
	Database* dbb = tdbb->getDatabase();
	AutoCacheRequest request(tdbb, irq_l_funct_blr, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		X IN RDB$FUNCTIONS
		WITH X.RDB$FUNCTION_ID EQ this->getId()
	{
		if (X.RDB$FUNCTION_BLR.NULL)
			continue;

		MemoryPool* const csb_pool = dbb->createPool();
		Jrd::ContextPoolHolder context(tdbb, csb_pool);

		try
		{
			AutoPtr<CompilerScratch> csb(FB_NEW_POOL(*csb_pool) CompilerScratch(*csb_pool));

			try
			{
				this->parseBlr(tdbb, csb, &X.RDB$FUNCTION_BLR,
					X.RDB$DEBUG_INFO.NULL ? nullptr : &X.RDB$DEBUG_INFO);
			}
			catch (const Exception& ex)
			{
				StaticStatusVector temp_status;
				ex.stuffException(temp_status);

				const string name = this->getName().toString();
				(Arg::Gds(isc_bad_fun_BLR) << Arg::Str(name)
					<< Arg::StatusVector(temp_status.begin())).raise();
			}
		}
		catch (const Exception&)
		{
			dbb->deletePool(csb_pool);
			throw;
		}
	}
	END_FOR

	return false;
}
