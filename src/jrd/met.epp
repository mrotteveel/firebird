/*
 *	PROGRAM:	JRD Access Method
 *	MODULE:		met.epp
 *	DESCRIPTION:	Meta data handler
 *
 * The contents of this file are subject to the Interbase Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.Inprise.com/IPL.html
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code was created by Inprise Corporation
 * and its predecessors. Portions created by Inprise Corporation are
 * Copyright (C) Inprise Corporation.
 *
 * All Rights Reserved.
 * Contributor(s): ______________________________________.
 *
 * 2001.6.25 Claudio Valderrama: Finish MET_lookup_generator_id() by
 *	assigning it a number in the compiled requests table.
 *
 * 2001.07.06 Sean Leyne - Code Cleanup, removed "#ifdef READONLY_DATABASE"
 *                         conditionals, as the engine now fully supports
 *                         readonly databases.
 * 2001.10.03 Claudio Valderrama: MET_relation_owns_trigger() determines if
 *   there's a row in rdb$triggers with the given relation's and trigger's names.
 * 2001.10.04 Claudio Valderrama: MET_relation_default_class() determines if the
 *   given security class name is the default security class for a relation.
 *   Modify MET_lookup_field() so it can verify the field's security class, too.
 * 2002-02-24 Sean Leyne - Code Cleanup of old Win 3.1 port (WINDOWS_ONLY)
 * 2002-09-16 Nickolay Samofatov - Deferred trigger compilation changes
 * 2002.10.29 Sean Leyne - Removed obsolete "Netware" port
 * 2004.01.16 Vlad Horsun: added support for default parameters
 */

#include "firebird.h"
#include <stdio.h>
#include <string.h>
#include <stdarg.h>

#include "../jrd/jrd.h"
#include "../jrd/val.h"
#include "../jrd/irq.h"
#include "../jrd/tra.h"
#include "../jrd/lck.h"
#include "../jrd/ods.h"
#include "../jrd/btr.h"
#include "../jrd/req.h"
#include "../jrd/Statement.h"
#include "../jrd/exe.h"
#include "../jrd/scl.h"
#include "../jrd/blb.h"
#include "../jrd/met.h"
#include "../jrd/os/pio.h"
#include "../jrd/sdw.h"
#include "../jrd/flags.h"
#include "../jrd/lls.h"
#include "../jrd/intl.h"
#include "../jrd/align.h"
#include "../jrd/flu.h"
#include "../jrd/blob_filter.h"
#include "../dsql/StmtNodes.h"
#include "../intl/charsets.h"
#include "../common/gdsassert.h"
#include "../jrd/blb_proto.h"
#include "../jrd/cmp_proto.h"
#include "../jrd/dfw_proto.h"
#include "../common/dsc_proto.h"
#include "../jrd/err_proto.h"
#include "../jrd/evl_proto.h"
#include "../jrd/exe_proto.h"
#include "../jrd/ext_proto.h"
#include "../jrd/flu_proto.h"
#include "../yvalve/gds_proto.h"
#include "../jrd/idx_proto.h"
#include "../jrd/ini_proto.h"

#include "../jrd/lck.h"
#include "../jrd/met_proto.h"
#include "../jrd/mov_proto.h"
#include "../jrd/par_proto.h"
#include "../jrd/os/pio_proto.h"
#include "../jrd/scl_proto.h"
#include "../jrd/sdw_proto.h"
#include "../jrd/tra_proto.h"
#include "../jrd/intl_proto.h"
#include "../common/utils_proto.h"

#include "../jrd/RecordSourceNodes.h"
#include "../jrd/DebugInterface.h"
#include "../common/classes/Hash.h"
#include "../common/classes/MsgPrint.h"
#include "../jrd/Function.h"
#include "../jrd/trace/TraceJrdHelpers.h"
#include "firebird/impl/msg_helper.h"
#include "../jrd/LocalTemporaryTable.h"


#ifdef HAVE_CTYPE_H
#include <ctype.h>
#endif

// Pick up relation ids
#include "../jrd/ini.h"

DATABASE DB = FILENAME "ODS.RDB";

using namespace Jrd;
using namespace Firebird;

static ULONG get_rel_flags_from_FLAGS(USHORT);
static void get_trigger(thread_db*, jrd_rel*, bid*, bid*, Triggers&, const QualifiedName&, FB_UINT64,
	SSHORT, USHORT, const MetaName&, const string&, const bid*, TriState ssDefiner);
static void lookup_view_contexts(thread_db*, jrd_rel*);
static void make_relation_scope_name(const QualifiedName&, const USHORT, string& str);
static ValueExprNode* parse_field_default_blr(thread_db* tdbb, const MetaName& schema, bid* blob_id);
static BoolExprNode* parse_field_validation_blr(thread_db* tdbb, bid* blob_id, const QualifiedName& name);
static void save_trigger_data(thread_db*, Triggers&, jrd_rel*, Statement*, blb*, blb*,
	const QualifiedName*, FB_UINT64, fb_sysflag, USHORT, const MetaName&, const string&,
	const bid*, TriState ssDefiner);
static bool verify_TRG_ignore_perm(thread_db*, const QualifiedName&);


void MET_get_domain(thread_db* tdbb, MemoryPool& csbPool, const QualifiedName& name, dsc* desc,
	FieldInfo* fieldInfo)
{
/**************************************
 *
 *	M E T _ g e t _ d o m a i n
 *
 **************************************
 *
 * Functional description
 *      Get domain descriptor and informations.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	bool found = false;

	AutoCacheRequest handle(tdbb, irq_l_domain, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE handle)
		FLD IN RDB$FIELDS
		WITH FLD.RDB$SCHEMA_NAME EQ name.schema.c_str() AND
			 FLD.RDB$FIELD_NAME EQ name.object.c_str()
	{
		if (DSC_make_descriptor(desc,
								FLD.RDB$FIELD_TYPE,
								FLD.RDB$FIELD_SCALE,
								FLD.RDB$FIELD_LENGTH,
								FLD.RDB$FIELD_SUB_TYPE,
								CSetId(FLD.RDB$CHARACTER_SET_ID),
								CollId(FLD.RDB$COLLATION_ID)))
		{
			found = true;

			if (fieldInfo)
			{
				fieldInfo->nullable = FLD.RDB$NULL_FLAG.NULL || FLD.RDB$NULL_FLAG == 0;

				Jrd::ContextPoolHolder context(tdbb, &csbPool);

				if (FLD.RDB$DEFAULT_VALUE.NULL)
					fieldInfo->defaultValue = NULL;
				else
					fieldInfo->defaultValue = parse_field_default_blr(tdbb, name.schema, &FLD.RDB$DEFAULT_VALUE);

				if (FLD.RDB$VALIDATION_BLR.NULL)
					fieldInfo->validationExpr = NULL;
				else
				{
					fieldInfo->validationExpr = parse_field_validation_blr(tdbb,
						&FLD.RDB$VALIDATION_BLR, name);
				}
			}
		}
	}
	END_FOR

	if (!found)
		ERR_post(Arg::Gds(isc_domnotdef) << name.toQuotedString());
}


void MET_get_relation_field(thread_db* tdbb, MemoryPool& csbPool, const QualifiedName& relationName,
	const MetaName& fieldName, dsc* desc, FieldInfo* fieldInfo)
{
/**************************************
 *
 *	M E T _ g e t _ r e l a t i o n _ f i e l d
 *
 **************************************
 *
 * Functional description
 *  Get relation field descriptor and informations.
 *  Returns field source name.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	bool found = false;
	MetaName sourceName;

	if (const auto lttPtr = attachment->att_local_temporary_tables.get(relationName))
	{
		const auto ltt = *lttPtr;

		for (const auto& lttField : ltt->fields)
		{
			if (lttField.name == fieldName)
			{
				// Copy descriptor from LTT field
				*desc = lttField.desc;

				// Set text type for text fields
				if (DTYPE_IS_TEXT(lttField.desc.dsc_dtype))
				{
					const auto charSetId = lttField.charSetId.value_or(CS_NONE);
					const auto collationId = lttField.collationId.value_or(COLLATE_NONE);
					desc->setTextType(TTypeId(charSetId, collationId));
				}

				sourceName = lttField.source.object;
				found = true;

				if (fieldInfo)
				{
					fieldInfo->nullable = !lttField.notNullFlag;
					fieldInfo->defaultValue = nullptr;  // LTTs don't support defaults yet
					fieldInfo->validationExpr = nullptr;
				}

				return;
			}
		}

		ERR_post(Arg::Gds(isc_dyn_column_does_not_exist) <<
			fieldName.toQuotedString() <<
			relationName.toQuotedString());
	}

	static const CachedRequestId handle1CacheId;
	AutoCacheRequest handle1(tdbb, handle1CacheId);

	FOR(REQUEST_HANDLE handle1)
		RFL IN RDB$RELATION_FIELDS CROSS
		FLD IN RDB$FIELDS WITH
			RFL.RDB$SCHEMA_NAME EQ relationName.schema.c_str() AND
			RFL.RDB$RELATION_NAME EQ relationName.object.c_str() AND
			RFL.RDB$FIELD_NAME EQ fieldName.c_str() AND
			FLD.RDB$SCHEMA_NAME EQ RFL.RDB$FIELD_SOURCE_SCHEMA_NAME AND
			FLD.RDB$FIELD_NAME EQ RFL.RDB$FIELD_SOURCE
	{
		if (DSC_make_descriptor(desc,
								FLD.RDB$FIELD_TYPE,
								FLD.RDB$FIELD_SCALE,
								FLD.RDB$FIELD_LENGTH,
								FLD.RDB$FIELD_SUB_TYPE,
								CSetId(FLD.RDB$CHARACTER_SET_ID),
								CollId(RFL.RDB$COLLATION_ID.NULL ? FLD.RDB$COLLATION_ID : RFL.RDB$COLLATION_ID)))
		{
			found = true;
			sourceName = RFL.RDB$FIELD_SOURCE;

			if (fieldInfo)
			{
				fieldInfo->nullable = RFL.RDB$NULL_FLAG.NULL ?
					(FLD.RDB$NULL_FLAG.NULL || FLD.RDB$NULL_FLAG == 0) : RFL.RDB$NULL_FLAG == 0;

				Jrd::ContextPoolHolder context(tdbb, &csbPool);
				bid* defaultId = NULL;

				if (!RFL.RDB$DEFAULT_VALUE.NULL)
					defaultId = &RFL.RDB$DEFAULT_VALUE;
				else if (!FLD.RDB$DEFAULT_VALUE.NULL)
					defaultId = &FLD.RDB$DEFAULT_VALUE;

				if (defaultId)
					fieldInfo->defaultValue = parse_field_default_blr(tdbb, relationName.schema, defaultId);
				else
					fieldInfo->defaultValue = NULL;

				if (FLD.RDB$VALIDATION_BLR.NULL)
					fieldInfo->validationExpr = NULL;
				else
				{
					fieldInfo->validationExpr = parse_field_validation_blr(tdbb,
						&FLD.RDB$VALIDATION_BLR, QualifiedName(RFL.RDB$FIELD_SOURCE, RFL.RDB$FIELD_SOURCE_SCHEMA_NAME));
				}
			}
		}
	}
	END_FOR

	if (!found)
	{
		ERR_post(Arg::Gds(isc_dyn_column_does_not_exist) <<
			fieldName.toQuotedString() <<
			relationName.toQuotedString());
	}
}


void MetadataCache::update_partners(thread_db* tdbb)
{
/**************************************
 *
 *      M E T _ u p d a t e _ p a r t n e r s
 *
 **************************************
 *
 * Functional description
 *      Mark all relations to update their links to FK partners
 *      Called when any index is deleted because engine don't know
 *      was it used in any FK or not
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* const dbb = tdbb->getDatabase();

	for (auto relation : dbb->dbb_mdc->mdc_relations)
	{
		if (!relation)
			continue;

		relation->checkPartners(tdbb);
	}
}


// Done before MDC is deleted
void MetadataCache::cleanup(thread_db* tdbb)
{
	mdc_relations.cleanup(tdbb);
	mdc_procedures.cleanup(tdbb);
	mdc_functions.cleanup(tdbb);
	mdc_charsets.cleanup(tdbb);

	for (unsigned i = 0; i < DB_TRIGGERS_COUNT; ++i)
	{
		auto* ptr = mdc_triggers[i].load(atomics::memory_order_relaxed);
		if (ptr)
		{
			Cached::Triggers::cleanup(tdbb, ptr);
			mdc_triggers[i].store(nullptr, atomics::memory_order_relaxed);
		}
	}
}


void MetadataCache::clear(thread_db* tdbb)
{
/**************************************
 *
 *      M E T _ c l e a r _ c a c h e
 *
 **************************************
 *
 * Functional description
 *      Remove all unused objects from metadata cache to
 *      release resources they use
 *
 **************************************/
/* !!!!!!!!!!!!!!!!!!! force remove old versions

	SET_TDBB(tdbb);
#ifdef DEV_BUILD
	MET_verify_cache(tdbb);
#endif

	Attachment* const att = tdbb->getAttachment();

	// Release global (db-level and DDL) triggers

	for (unsigned i = 0; i < DB_TRIGGERS_COUNT; i++)
		MET_release_triggers(tdbb, &att->att_triggers[i], false);

	// Release relation triggers

	vec<jrd_rel*>* const relations = att->att_relations;
	if (relations)
	{
		vec<jrd_rel*>::iterator ptr, end;
		for (ptr = relations->begin(), end = relations->end(); ptr < end; ++ptr)
		{
			jrd_rel* const relation = *ptr;
			if (!relation)
				continue;

			relation->releaseTriggers(tdbb, false);
		}
	}

	const auto walkProcFunc = [&att](std::function<void (Routine*)> func)
	{
		for (const auto routine : att->att_procedures)
		{
			if (routine)
				func(routine);
		}

		for (const auto routine : att->att_functions)
		{
			if (routine)
				func(routine);
		}
	};

	// Walk routines and calculate internal dependencies.

	walkProcFunc([](Routine* routine)
	{
		if (routine->getStatement() &&
			!(routine->flags & Routine::FLAG_OBSOLETE) )
		{
			inc_int_use_count(routine->getStatement());
		}
	});

	// Walk routines again and adjust dependencies for routines which will not be removed.

	walkProcFunc([](Routine* routine)
	{
		if (routine->getStatement() &&
			!(routine->flags & Routine::FLAG_OBSOLETE) &&
			routine->useCount != routine->intUseCount )
		{
			adjust_dependencies(routine);
		}
	});

	// Deallocate all used requests.

	walkProcFunc([&tdbb](Routine* routine)
	{
		if (routine->getStatement() && !(routine->flags & Routine::FLAG_OBSOLETE) &&
			routine->intUseCount >= 0 &&
			routine->useCount == routine->intUseCount)
		{
			routine->releaseStatement(tdbb);

			if (routine->existenceLock)
				LCK_release(tdbb, routine->existenceLock);
			routine->existenceLock = NULL;
			routine->flags |= Routine::FLAG_OBSOLETE;
		}

		// Leave it in state 0 to avoid extra pass next time to clear it
		// Note: we need to adjust intUseCount for all routines
		// in cache because any of them may have been affected from
		// dependencies earlier. Even routines that were not scanned yet !
		routine->intUseCount = 0;
	});

#ifdef DEV_BUILD
	MET_verify_cache(tdbb);
#endif

 */
}


void MET_activate_shadow(thread_db* tdbb)
{
/**************************************
 *
 *      M E T _ a c t i v a t e _ s h a d o w
 *
 **************************************
 *
 * Functional description
 *      Activate the current database, which presumably
 *      was formerly a shadow, by deleting all records
 *      corresponding to the shadow that this database
 *      represents.
 *      Get rid of write ahead log for the activated shadow.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	Database* dbb = tdbb->getDatabase();

	// Erase any secondary files of the primary database of the shadow being activated.

	AutoRequest handle;

	FOR(REQUEST_HANDLE handle) X IN RDB$FILES
		WITH X.RDB$SHADOW_NUMBER NOT MISSING
			AND X.RDB$SHADOW_NUMBER EQ 0
		ERASE X;
	END_FOR

	PageSpace* pageSpace = dbb->dbb_page_manager.findPageSpace(DB_PAGE_SPACE);
	const char* dbb_file_name = pageSpace->file->fil_string;

	// go through files looking for any that expand to the current database name
	SCHAR expanded_name[MAXPATHLEN];
	AutoRequest handle2;
	handle.reset();

	FOR(REQUEST_HANDLE handle) X IN RDB$FILES
		WITH X.RDB$SHADOW_NUMBER NOT MISSING
			AND X.RDB$SHADOW_NUMBER NE 0

		PIO_expand(X.RDB$FILE_NAME, (USHORT)strlen(X.RDB$FILE_NAME),
					expanded_name, sizeof(expanded_name));

		if (!strcmp(expanded_name, dbb_file_name))
		{
			FOR(REQUEST_HANDLE handle2) Y IN RDB$FILES
				WITH X.RDB$SHADOW_NUMBER EQ Y.RDB$SHADOW_NUMBER
				MODIFY Y
					Y.RDB$SHADOW_NUMBER = 0;
				END_MODIFY
			END_FOR

			ERASE X;
		}
	END_FOR
}


ULONG MET_align(const dsc* desc, ULONG value)
{
/**************************************
 *
 *      M E T _ a l i g n
 *
 **************************************
 *
 * Functional description
 *      Align value (presumed offset) on appropriate border
 *      and return.
 *
 **************************************/
	USHORT alignment = desc->dsc_length;
	switch (desc->dsc_dtype)
	{
	case dtype_text:
	case dtype_cstring:
		return value;

	case dtype_varying:
		alignment = sizeof(USHORT);
		break;
	}

	alignment = MIN(alignment, FORMAT_ALIGNMENT);

	return FB_ALIGN(value, alignment);
}


Cached::Relation* MET_change_fields(thread_db* tdbb, jrd_tra* transaction, const dsc* schemaName, const dsc* fieldSource)
{
/**************************************
 *
 *      M E T _ c h a n g e _ f i e l d s
 *
 **************************************
 *
 * Functional description
 *      Somebody is modifying RDB$FIELDS.
 *      Find all relations affected and schedule a format update.
 *      Find all procedures and triggers and schedule a BLR validate.
 *      Find all functions and schedule a BLR validate.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	Cached::Relation* calcFieldRelation = nullptr;
	dsc schemaDesc, nameDesc;

	AutoCacheRequest request(tdbb, irq_m_fields, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		X IN RDB$RELATION_FIELDS
		CROSS R IN RDB$RELATIONS
		OVER RDB$SCHEMA_NAME, RDB$RELATION_NAME
		WITH X.RDB$SCHEMA_NAME EQ schemaName->dsc_address AND
			 X.RDB$FIELD_SOURCE EQ fieldSource->dsc_address
	{
		SCL_check_relation(tdbb, QualifiedName(X.RDB$RELATION_NAME, X.RDB$SCHEMA_NAME), SCL_alter);
		{
			AutoSetRestore2<jrd_tra*, thread_db> tempTrans(tdbb,
				&thread_db::getTransaction,
				&thread_db::setTransaction,
				transaction);

			calcFieldRelation = MetadataCache::newVersion<Cached::Relation>(tdbb, R.RDB$RELATION_ID);
		}
		DFW_post_work(transaction, dfw_commit_relation, nullptr, nullptr, R.RDB$RELATION_ID);

		AutoCacheRequest request2(tdbb, irq_m_fields4, IRQ_REQUESTS);

		FOR(REQUEST_HANDLE request2)
			DEP IN RDB$DEPENDENCIES
			CROSS PRC IN RDB$PROCEDURES
			WITH DEP.RDB$DEPENDED_ON_SCHEMA_NAME EQ X.RDB$SCHEMA_NAME AND
				 DEP.RDB$DEPENDED_ON_NAME EQ X.RDB$RELATION_NAME AND
				 DEP.RDB$FIELD_NAME EQ X.RDB$FIELD_NAME AND
				 DEP.RDB$DEPENDED_ON_TYPE EQ obj_relation AND
				 DEP.RDB$DEPENDENT_TYPE EQ obj_procedure AND
				 DEP.RDB$DEPENDENT_SCHEMA_NAME EQ PRC.RDB$SCHEMA_NAME AND
				 DEP.RDB$DEPENDENT_NAME EQ PRC.RDB$PROCEDURE_NAME AND
				 PRC.RDB$PACKAGE_NAME MISSING
		{
			QualifiedName procName(PRC.RDB$PROCEDURE_NAME, PRC.RDB$SCHEMA_NAME);

			schemaDesc.makeText(procName.schema.length(), CS_METADATA, (UCHAR*) procName.schema.c_str());
			nameDesc.makeText(procName.object.length(), CS_METADATA, (UCHAR*) procName.object.c_str());

			DeferredWork* dw2 =
				DFW_post_work(transaction, dfw_modify_procedure, &nameDesc, &schemaDesc, PRC.RDB$PROCEDURE_ID);
			DFW_post_work_arg(transaction, dw2, nullptr, nullptr, 0, dfw_arg_check_blr);

			MetadataCache::newVersion<Cached::Procedure>(tdbb, PRC.RDB$PROCEDURE_ID);
		}
		END_FOR

		request2.reset(tdbb, irq_m_fields5, IRQ_REQUESTS);

		FOR(REQUEST_HANDLE request2)
			DEP IN RDB$DEPENDENCIES
			CROSS TRG IN RDB$TRIGGERS
			WITH DEP.RDB$DEPENDED_ON_SCHEMA_NAME EQ X.RDB$SCHEMA_NAME AND
				 DEP.RDB$DEPENDED_ON_NAME EQ X.RDB$RELATION_NAME AND
				 DEP.RDB$FIELD_NAME EQ X.RDB$FIELD_NAME AND
				 DEP.RDB$DEPENDED_ON_TYPE EQ obj_relation AND
				 DEP.RDB$DEPENDENT_TYPE EQ obj_trigger AND
				 DEP.RDB$DEPENDENT_SCHEMA_NAME EQ TRG.RDB$SCHEMA_NAME AND
				 DEP.RDB$DEPENDENT_NAME EQ TRG.RDB$TRIGGER_NAME
		{
			QualifiedName triggerName(TRG.RDB$TRIGGER_NAME, TRG.RDB$SCHEMA_NAME);
			MetaName triggerRelationName(TRG.RDB$RELATION_NAME);
			schemaDesc.makeText(triggerName.schema.length(), CS_METADATA, (UCHAR*) triggerName.schema.c_str());
			nameDesc.makeText(triggerName.object.length(), CS_METADATA, (UCHAR*) triggerName.object.c_str());
			DeferredWork* dw2 = DFW_post_work(transaction, dfw_modify_trigger, &nameDesc, &schemaDesc, TRG.RDB$TRIGGER_TYPE);

			nameDesc.dsc_length = triggerRelationName.length();
			nameDesc.dsc_address = (UCHAR*) triggerRelationName.c_str();
			DFW_post_work_arg(transaction, dw2, &nameDesc, &schemaDesc, 0, dfw_arg_check_blr);
		}
		END_FOR

		request2.reset(tdbb, irq_m_fields8, IRQ_REQUESTS);

		FOR(REQUEST_HANDLE request2)
			DEP IN RDB$DEPENDENCIES
			CROSS FUN IN RDB$FUNCTIONS
			WITH DEP.RDB$DEPENDED_ON_SCHEMA_NAME EQ X.RDB$SCHEMA_NAME AND
				 DEP.RDB$DEPENDED_ON_NAME EQ X.RDB$RELATION_NAME AND
				 DEP.RDB$FIELD_NAME EQ X.RDB$FIELD_NAME AND
				 DEP.RDB$DEPENDED_ON_TYPE EQ obj_relation AND
				 DEP.RDB$DEPENDENT_TYPE EQ obj_udf AND
				 DEP.RDB$DEPENDENT_SCHEMA_NAME EQ FUN.RDB$SCHEMA_NAME AND
				 DEP.RDB$DEPENDENT_NAME EQ FUN.RDB$FUNCTION_NAME AND
				 FUN.RDB$PACKAGE_NAME MISSING
		{
			QualifiedName funcName(FUN.RDB$FUNCTION_NAME, FUN.RDB$SCHEMA_NAME);

			schemaDesc.makeText(funcName.schema.length(), CS_METADATA, (UCHAR*) funcName.schema.c_str());
			nameDesc.makeText(funcName.object.length(), CS_METADATA, (UCHAR*) funcName.object.c_str());

			DeferredWork* dw2 =
				DFW_post_work(transaction, dfw_modify_function, &nameDesc, &schemaDesc, FUN.RDB$FUNCTION_ID);
			DFW_post_work_arg(transaction, dw2, nullptr, nullptr, 0, dfw_arg_check_blr);

			MetadataCache::newVersion<Cached::Function>(tdbb, FUN.RDB$FUNCTION_ID);
		}
		END_FOR
	}
	END_FOR

	request.reset(tdbb, irq_m_fields2, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		DEP IN RDB$DEPENDENCIES
		CROSS PRC IN RDB$PROCEDURES
		WITH DEP.RDB$DEPENDED_ON_SCHEMA_NAME EQ schemaName->dsc_address AND
			 DEP.RDB$DEPENDED_ON_NAME EQ fieldSource->dsc_address AND
			 DEP.RDB$DEPENDED_ON_TYPE EQ obj_field AND
			 DEP.RDB$DEPENDENT_TYPE EQ obj_procedure AND
			 DEP.RDB$DEPENDENT_SCHEMA_NAME EQ PRC.RDB$SCHEMA_NAME AND
			 DEP.RDB$DEPENDENT_NAME EQ PRC.RDB$PROCEDURE_NAME AND
			 PRC.RDB$PACKAGE_NAME MISSING
	{
		QualifiedName procName(PRC.RDB$PROCEDURE_NAME, PRC.RDB$SCHEMA_NAME);

		schemaDesc.makeText(procName.schema.length(), CS_METADATA, (UCHAR*) procName.schema.c_str());
		nameDesc.makeText(procName.object.length(), CS_METADATA, (UCHAR*) procName.object.c_str());

		DeferredWork* dw2 =
			DFW_post_work(transaction, dfw_modify_procedure, &nameDesc, &schemaDesc, PRC.RDB$PROCEDURE_ID);
		DFW_post_work_arg(transaction, dw2, nullptr, nullptr, 0, dfw_arg_check_blr);

		MetadataCache::newVersion<Cached::Procedure>(tdbb, PRC.RDB$PROCEDURE_ID);
	}
	END_FOR

	request.reset(tdbb, irq_m_fields6, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		DEP IN RDB$DEPENDENCIES
		CROSS PRC IN RDB$PROCEDURES
		WITH DEP.RDB$DEPENDED_ON_SCHEMA_NAME EQ schemaName->dsc_address AND
			 DEP.RDB$DEPENDED_ON_NAME EQ fieldSource->dsc_address AND
			 DEP.RDB$DEPENDED_ON_TYPE EQ obj_field AND
			 (DEP.RDB$DEPENDENT_TYPE EQ obj_package_header OR
			 	DEP.RDB$DEPENDENT_TYPE EQ obj_package_body) AND
			 DEP.RDB$DEPENDENT_SCHEMA_NAME EQ PRC.RDB$SCHEMA_NAME AND
			 DEP.RDB$DEPENDENT_NAME EQ PRC.RDB$PACKAGE_NAME
	{
		QualifiedName procName(PRC.RDB$PROCEDURE_NAME, PRC.RDB$SCHEMA_NAME);

		schemaDesc.makeText(procName.schema.length(), CS_METADATA, (UCHAR*) procName.schema.c_str());
		nameDesc.makeText(procName.object.length(), CS_METADATA, (UCHAR*) procName.object.c_str());

		DeferredWork* dw2 = DFW_post_work(transaction, dfw_modify_procedure, &nameDesc, &schemaDesc,
			PRC.RDB$PROCEDURE_ID, PRC.RDB$PACKAGE_NAME);
		DFW_post_work_arg(transaction, dw2, nullptr, nullptr, 0, dfw_arg_check_blr);

		MetadataCache::newVersion<Cached::Procedure>(tdbb, PRC.RDB$PROCEDURE_ID);
	}
	END_FOR

	request.reset(tdbb, irq_m_fields3, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		DEP IN RDB$DEPENDENCIES CROSS
		TRG IN RDB$TRIGGERS
		WITH DEP.RDB$DEPENDED_ON_SCHEMA_NAME EQ schemaName->dsc_address AND
			 DEP.RDB$DEPENDED_ON_NAME EQ fieldSource->dsc_address AND
			 DEP.RDB$DEPENDED_ON_TYPE EQ obj_field AND
			 DEP.RDB$DEPENDENT_TYPE EQ obj_trigger AND
			 DEP.RDB$DEPENDENT_SCHEMA_NAME EQ TRG.RDB$SCHEMA_NAME AND
			 DEP.RDB$DEPENDENT_NAME EQ TRG.RDB$TRIGGER_NAME
	{
		QualifiedName triggerName(TRG.RDB$TRIGGER_NAME, TRG.RDB$SCHEMA_NAME);
		MetaName triggerRelationName(TRG.RDB$RELATION_NAME);
		schemaDesc.makeText(triggerName.schema.length(), CS_METADATA, (UCHAR*) triggerName.schema.c_str());
		nameDesc.makeText(triggerName.object.length(), CS_METADATA, (UCHAR*) triggerName.object.c_str());
		DeferredWork* dw2 = DFW_post_work(transaction, dfw_modify_trigger, &nameDesc, &schemaDesc, TRG.RDB$TRIGGER_TYPE);

		nameDesc.dsc_length = triggerRelationName.length();
		nameDesc.dsc_address = (UCHAR*) triggerRelationName.c_str();
		DFW_post_work_arg(transaction, dw2, &nameDesc, &schemaDesc, 0, dfw_arg_check_blr);
	}
	END_FOR

	request.reset(tdbb, irq_m_fields7, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		DEP IN RDB$DEPENDENCIES CROSS
		FUN IN RDB$FUNCTIONS
		WITH DEP.RDB$DEPENDED_ON_SCHEMA_NAME EQ schemaName->dsc_address AND
			 DEP.RDB$DEPENDED_ON_NAME EQ fieldSource->dsc_address AND
			 DEP.RDB$DEPENDED_ON_TYPE EQ obj_field AND
			 DEP.RDB$DEPENDENT_TYPE EQ obj_udf AND
			 DEP.RDB$DEPENDENT_SCHEMA_NAME EQ FUN.RDB$SCHEMA_NAME AND
			 DEP.RDB$DEPENDENT_NAME EQ FUN.RDB$FUNCTION_NAME AND
			 FUN.RDB$PACKAGE_NAME MISSING
	{
		QualifiedName funcName(FUN.RDB$FUNCTION_NAME, FUN.RDB$SCHEMA_NAME);

		schemaDesc.makeText(funcName.schema.length(), CS_METADATA, (UCHAR*) funcName.schema.c_str());
		nameDesc.makeText(funcName.object.length(), CS_METADATA, (UCHAR*) funcName.object.c_str());

		DeferredWork* dw2 =
			DFW_post_work(transaction, dfw_modify_function, &nameDesc, &schemaDesc, FUN.RDB$FUNCTION_ID);
		DFW_post_work_arg(transaction, dw2, nullptr, nullptr, 0, dfw_arg_check_blr);

		MetadataCache::newVersion<Cached::Function>(tdbb, FUN.RDB$FUNCTION_ID);
	}
	END_FOR

	request.reset(tdbb, irq_m_fields9, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		DEP IN RDB$DEPENDENCIES CROSS
		FUN IN RDB$FUNCTIONS
		WITH DEP.RDB$DEPENDED_ON_SCHEMA_NAME EQ schemaName->dsc_address AND
			 DEP.RDB$DEPENDED_ON_NAME EQ fieldSource->dsc_address AND
			 DEP.RDB$DEPENDED_ON_TYPE EQ obj_field AND
			 (DEP.RDB$DEPENDENT_TYPE EQ obj_package_header OR
			 	DEP.RDB$DEPENDENT_TYPE EQ obj_package_body) AND
			 DEP.RDB$DEPENDENT_SCHEMA_NAME EQ FUN.RDB$SCHEMA_NAME AND
			 DEP.RDB$DEPENDENT_NAME EQ FUN.RDB$PACKAGE_NAME
	{
		QualifiedName funcName(FUN.RDB$FUNCTION_NAME, FUN.RDB$SCHEMA_NAME);

		schemaDesc.makeText(funcName.schema.length(), CS_METADATA, (UCHAR*) funcName.schema.c_str());
		nameDesc.makeText(funcName.object.length(), CS_METADATA, (UCHAR*) funcName.object.c_str());

		DeferredWork* dw2 = DFW_post_work(transaction, dfw_modify_function, &nameDesc, &schemaDesc,
			FUN.RDB$FUNCTION_ID, FUN.RDB$PACKAGE_NAME);
		DFW_post_work_arg(transaction, dw2, nullptr, nullptr, 0, dfw_arg_check_blr);

		MetadataCache::newVersion<Cached::Function>(tdbb, FUN.RDB$FUNCTION_ID);
	}
	END_FOR

	return calcFieldRelation;
}


void MET_delete_dependencies(thread_db* tdbb,
							 const QualifiedName& object_name,
							 int dependency_type)
{
/**************************************
 *
 *      M E T _ d e l e t e _ d e p e n d e n c i e s
 *
 **************************************
 *
 * Functional description
 *      Delete all dependencies for the specified
 *      object of given type.
 *
 **************************************/
	SET_TDBB(tdbb);

	if (object_name.isEmpty())
		return;

	AutoCacheRequest request(tdbb, irq_d_deps, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request TRANSACTION_HANDLE tdbb->getTransaction())
		DEP IN RDB$DEPENDENCIES
		WITH DEP.RDB$DEPENDENT_SCHEMA_NAME EQUIV NULLIF(object_name.schema.c_str(), '') AND
			 DEP.RDB$DEPENDENT_NAME = object_name.object.c_str() AND
			 DEP.RDB$DEPENDENT_TYPE = dependency_type
	{
		ERASE DEP;
	}
	END_FOR
}


void MET_delete_shadow(thread_db* tdbb, USHORT shadow_number)
{
/**************************************
 *
 *      M E T _ d e l e t e _ s h a d o w
 *
 **************************************
 *
 * Functional description
 *      When any of the shadows in RDB$FILES for a particular
 *      shadow are deleted, stop shadowing to that file and
 *      remove all other files from the same shadow.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	Database* dbb = tdbb->getDatabase();

	AutoRequest handle;

	FOR(REQUEST_HANDLE handle)
		X IN RDB$FILES WITH X.RDB$SHADOW_NUMBER EQ shadow_number
		ERASE X;
	END_FOR

	for (Shadow* shadow = dbb->dbb_shadow; shadow; shadow = shadow->sdw_next)
	{
		if (shadow->sdw_number == shadow_number) {
			shadow->sdw_flags |= SDW_shutdown;
		}
	}

	// notify other processes to check for shadow deletion
	if (SDW_lck_update(tdbb, 0))
		SDW_notify(tdbb);
}


bool MetadataCache::dsql_cache_use(thread_db* tdbb, sym_type type, const QualifiedName& name)
{
	DSqlCacheItem* item = get_dsql_cache_item(tdbb, type, name);

	bool obsolete = false;
	item->obsoleteMap.get(name, obsolete);

	if (!item->locked)
	{
		// lock to be notified by others when we should mark as obsolete
		LCK_lock(tdbb, item->lock, LCK_SR, LCK_WAIT);
		item->locked = true;
	}

	item->obsoleteMap.put(name, false);

	return obsolete;
}


void MetadataCache::dsql_cache_release(thread_db* tdbb, sym_type type, const QualifiedName& name)
{
	DSqlCacheItem* item = get_dsql_cache_item(tdbb, type, name);

	// release the shared lock
	LCK_release(tdbb, item->lock);

	// notify others through AST to mark as obsolete
	AutoPtr<Lock> tempExLock(FB_NEW_RPT(*tdbb->getDefaultPool(), item->key.length())
		Lock(tdbb, item->key.length(), LCK_dsql_cache));
	memcpy(tempExLock->getKeyPtr(), item->key.c_str(), item->key.length());

	if (LCK_lock(tdbb, tempExLock, LCK_EX, LCK_WAIT))
		LCK_release(tdbb, tempExLock);

	item->locked = false;

	LeftPooledMap<QualifiedName, bool>::Accessor accessor(&item->obsoleteMap);
	for (bool found = accessor.getFirst(); found; found = accessor.getNext())
		accessor.current()->second = accessor.current()->first != name;
}


void MET_error(const TEXT* string, ...)
{
/**************************************
 *
 *      M E T _ e r r o r
 *
 **************************************
 *
 * Functional description
 *      Post an error in a metadata update
 *      Oh, wow.
 *
 **************************************/
	TEXT s[128];
	va_list ptr;

	va_start(ptr, string);
	VSNPRINTF(s, sizeof(s), string, ptr);
	va_end(ptr);

	ERR_post(Arg::Gds(isc_no_meta_update) <<
			 Arg::Gds(isc_random) << Arg::Str(s));
}

Format* MET_format(thread_db* tdbb, RelationPermanent* relation, USHORT number)
{
/**************************************
 *
 *      M E T _ f o r m a t
 *
 **************************************
 *
 * Functional description
 *      Lookup a format for given relation.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	Database* dbb = tdbb->getDatabase();

	Format* format;
	auto formats = relation->getFormats();
	if ((number < formats->getCount()) && (format = formats->value(number)))
	{
		return format;
	}

	// System relations don't have their formats stored inside RDB$FORMATS,
	// so it's absolutely pointless trying to find one there
	fb_assert(!relation->isSystem());
	fb_assert(!(relation->rel_flags & REL_temp_ltt));

	format = NULL;
	AutoCacheRequest request(tdbb, irq_r_format, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		X IN RDB$FORMATS WITH X.RDB$RELATION_ID EQ relation->getId() AND
			X.RDB$FORMAT EQ number
	{
		blb* blob = blb::open(tdbb, attachment->getSysTransaction(), &X.RDB$DESCRIPTOR);

		// Use generic representation of formats with 32-bit offsets

		HalfStaticArray<UCHAR, BUFFER_MEDIUM> buffer;
		blob->BLB_get_data(tdbb, buffer.getBuffer(blob->blb_length), blob->blb_length);
		unsigned bufferPos = 2;
		USHORT count = buffer[0] | (buffer[1] << 8);

		format = Format::newFormat(relation->getPool(), count);

		Array<Ods::Descriptor> odsDescs;
		Ods::Descriptor* odsDesc = odsDescs.getBuffer(count);
		memcpy(odsDesc, buffer.begin() + bufferPos, count * sizeof(Ods::Descriptor));

		for (Format::fmt_desc_iterator desc = format->fmt_desc.begin();
			 desc < format->fmt_desc.end(); ++desc, ++odsDesc)
		{
			*desc = *odsDesc;
			if (odsDesc->dsc_offset)
				format->fmt_length = odsDesc->dsc_offset + desc->dsc_length;
		}

		const UCHAR* p = buffer.begin() + bufferPos + count * sizeof(Ods::Descriptor);
		count = p[0] | (p[1] << 8);
		p += 2;

		Array<UCHAR> tmpArray;	// must be aligned for the maximum datatype align requirement
		while (count-- > 0)
		{
			USHORT offset = p[0] | (p[1] << 8);
			p += 2;

			Ods::Descriptor odsDflDesc;
			memcpy(&odsDflDesc, p, sizeof(odsDflDesc));
			p += sizeof(Ods::Descriptor);

			dsc desc = odsDflDesc;

			desc.dsc_address = tmpArray.getBuffer(desc.dsc_length, false);
			memcpy(desc.dsc_address, p, desc.dsc_length);
			EVL_make_value(tdbb, &desc, &format->fmt_defaults[offset], &relation->getPool());

			p += desc.dsc_length;
		}
	}
	END_FOR

	if (!format)
		format = Format::newFormat(relation->getPool());

	format->fmt_version = number;

	// Link the format block into the world
	relation->addFormat(format);

	return format;
}


// Return:
// true if no errors (and *id is set).
// false if the name could not be resolved.
bool MetadataCache::get_texttype(thread_db* tdbb, TTypeId* id, const QualifiedName& name)
{
	SET_TDBB(tdbb);

	fb_assert(id);

	bool res = resolve_charset_and_collation(tdbb, id, name, {});
	if (!res)
	{
		// Is it a collation name (implying implementation-default character set)
		res = resolve_charset_and_collation(tdbb, id, {}, name);
	}

	return res;
}


bool MET_get_char_coll_subtype_info(thread_db* tdbb, USHORT id, SubtypeInfo* info)
{
/**************************************
 *
 *      M E T _ g e t _ c h a r _ c o l l _ s u b t y p e _ i n f o
 *
 **************************************
 *
 * Functional description
 *      Get charset and collation informations
 *      for a subtype ID.
 *
 **************************************/
	fb_assert(info != NULL);

	const USHORT charset_id = id & 0x00FF;
	const USHORT collation_id = id >> 8;

	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	AutoCacheRequest request(tdbb, irq_l_subtype, IRQ_REQUESTS);
	bool found = false;
	info->charsetName.clear();

	FOR(REQUEST_HANDLE request) FIRST 1
		CL IN RDB$COLLATIONS CROSS
		CS IN RDB$CHARACTER_SETS
		WITH CL.RDB$CHARACTER_SET_ID EQ charset_id AND
			CL.RDB$COLLATION_ID EQ collation_id AND
			CS.RDB$CHARACTER_SET_ID EQ CL.RDB$CHARACTER_SET_ID
	{
		found = true;

		info->charsetName.push(QualifiedName(CS.RDB$CHARACTER_SET_NAME, CS.RDB$SCHEMA_NAME));
		info->collationName = QualifiedName(CL.RDB$COLLATION_NAME, CL.RDB$SCHEMA_NAME);

		if (CL.RDB$BASE_COLLATION_NAME.NULL)
			info->baseCollationName = info->collationName.object.c_str();
		else
			info->baseCollationName = CL.RDB$BASE_COLLATION_NAME;

		if (CL.RDB$SPECIFIC_ATTRIBUTES.NULL)
			info->specificAttributes.clear();
		else
		{
			blb* blob = blb::open(tdbb, attachment->getSysTransaction(), &CL.RDB$SPECIFIC_ATTRIBUTES);
			const ULONG length = blob->blb_length;

			// ASF: Here info->specificAttributes is in UNICODE_FSS charset.
			// It will be converted to the collation charset in intl.cpp
			blob->BLB_get_data(tdbb, info->specificAttributes.getBuffer(length), length);
		}

		info->attributes = (USHORT)CL.RDB$COLLATION_ATTRIBUTES;
		info->ignoreAttributes = CL.RDB$COLLATION_ATTRIBUTES.NULL;
	}
	END_FOR

	return found;
}


DmlNode* MET_get_dependencies(thread_db* tdbb,
							  jrd_rel* relation,
							  const UCHAR* blob,
							  const ULONG blob_length,
							  CompilerScratch* view_csb,
							  bid* blob_id,
							  Statement** statementPtr,
							  CompilerScratch** csb_ptr,
							  const QualifiedName& object_name,
							  int type,
							  USHORT flags,
							  jrd_tra* transaction,
							  const QualifiedName& domain_validation)
{
/**************************************
 *
 *      M E T _ g e t _ d e p e n d e n c i e s
 *
 **************************************
 *
 * Functional description
 *      Get dependencies for an object by parsing
 *      the blr used in its definition.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	fb_assert(domain_validation.object.isEmpty() || object_name == domain_validation); // for now

	MemoryPool& pool = *tdbb->getDefaultPool();
	AutoPtr<CompilerScratch> auto_csb(FB_NEW_POOL(pool) CompilerScratch(pool));
	CompilerScratch* csb = auto_csb;

	csb->csb_g_flags |= (csb_get_dependencies | flags);
	csb->csb_domain_validation = domain_validation;

	DmlNode* node;

	if (blob)
	{
		node = PAR_blr(tdbb, &object_name.schema, getPermanent(relation), blob, blob_length,
			view_csb, &csb, statementPtr, (type == obj_trigger && relation != NULL), 0);
	}
	else
	{
		node = MET_parse_blob(tdbb, &object_name.schema, getPermanent(relation), blob_id, &csb, statementPtr,
			(type == obj_trigger && relation != NULL), type == obj_validation);
	}

	if (type == obj_computed)
	{
		QualifiedName domainName;

		static const CachedRequestId cachedHandleId;
		AutoCacheRequest handle(tdbb, cachedHandleId);

		FOR(REQUEST_HANDLE handle)
			RFL IN RDB$RELATION_FIELDS CROSS
				FLD IN RDB$FIELDS
				WITH RFL.RDB$SCHEMA_NAME EQ relation->getName().schema.c_str() AND
					 RFL.RDB$RELATION_NAME EQ relation->getName().object.c_str() AND
					 RFL.RDB$FIELD_NAME EQ object_name.object.c_str() AND
					 FLD.RDB$SCHEMA_NAME EQ RFL.RDB$FIELD_SOURCE_SCHEMA_NAME AND
					 FLD.RDB$FIELD_NAME EQ RFL.RDB$FIELD_SOURCE
		{
			domainName = QualifiedName(FLD.RDB$FIELD_NAME, FLD.RDB$SCHEMA_NAME);
		}
		END_FOR

		fb_assert(domainName.object.hasData());

		if (type != obj_package_body)
			MET_delete_dependencies(tdbb, domainName, type);

		MET_store_dependencies(tdbb, csb->csb_dependencies, relation, domainName, type, transaction);
	}
	else
	{
		if (type != obj_package_body)
			MET_delete_dependencies(tdbb, object_name, type);

		MET_store_dependencies(tdbb, csb->csb_dependencies, relation, object_name, type, transaction);
	}

	if (csb_ptr)
		*csb_ptr = auto_csb.release();

	return node;
}


jrd_fld* MET_get_field(const jrd_rel* relation, USHORT id)
{
/**************************************
 *
 *      M E T _ g e t _ f i e l d
 *
 **************************************
 *
 * Functional description
 *      Get the field block for a field if possible.  If not,
 *      return NULL;
 *
 **************************************/
	vec<jrd_fld*>* vector;

	if (!relation || !(vector = relation->rel_fields) || id >= vector->count())
		return NULL;

	return (*vector)[id];
}


bool MET_get_repl_state(Jrd::thread_db* tdbb, const QualifiedName& name)
{
/**************************************
 *
 *      M E T _ g e t _ r e p l _ s t a t e
 *
 **************************************
 *
 * Functional description
 *      Return relication state (enabled/disabled)
 *      for either database or given relation.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* const attachment = tdbb->getAttachment();

	AutoRequest handle;
	bool state = false;

	if (name.object.hasData())
	{
		FOR(REQUEST_HANDLE handle)
			PTAB IN RDB$PUBLICATION_TABLES
			WITH PTAB.RDB$TABLE_SCHEMA_NAME EQ name.schema.c_str() AND
				 PTAB.RDB$TABLE_NAME EQ name.object.c_str()
		{
			state = true;
			break;
		}
		END_FOR
	}
	else
	{
		FOR(REQUEST_HANDLE handle)
			PUB IN RDB$PUBLICATIONS
			WITH PUB.RDB$ACTIVE_FLAG EQ 1
		{
			state = true;
			break;
		}
		END_FOR
	}

	return state;
}


void MET_get_shadow_files(thread_db* tdbb, bool delete_files)
{
/**************************************
 *
 *      M E T _ g e t _ s h a d o w _ f i l e s
 *
 **************************************
 *
 * Functional description
 *      Check the shadows found in the database against
 *      our in-memory list: if any new shadow files have
 *      been defined since the last time we looked, start
 *      shadowing to them; if any have been deleted, stop
 *      shadowing to them.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	Database* dbb = tdbb->getDatabase();

	AutoRequest handle;

	FOR(REQUEST_HANDLE handle) X IN RDB$FILES
		WITH X.RDB$SHADOW_NUMBER NOT MISSING
			AND X.RDB$SHADOW_NUMBER NE 0
	{
		if ((X.RDB$FILE_FLAGS & FILE_shadow) && !(X.RDB$FILE_FLAGS & FILE_inactive))
		{
			const USHORT file_flags = X.RDB$FILE_FLAGS;
			SDW_start(tdbb, X.RDB$FILE_NAME, X.RDB$SHADOW_NUMBER, file_flags, delete_files);

			// if the shadow exists, mark the appropriate shadow
			// block as found for the purposes of this routine;
			// if the shadow was conditional and is no longer, note it

			for (Shadow* shadow = dbb->dbb_shadow; shadow; shadow = shadow->sdw_next)
			{
				if ((shadow->sdw_number == X.RDB$SHADOW_NUMBER) && !(shadow->sdw_flags & SDW_IGNORE))
				{
					shadow->sdw_flags |= SDW_found;
					if (!(file_flags & FILE_conditional)) {
						shadow->sdw_flags &= ~SDW_conditional;
					}
					break;
				}
			}
		}
	}
	END_FOR

	// if any current shadows were not defined in database, mark
	// them to be shutdown since they don't exist anymore

	for (Shadow* shadow = dbb->dbb_shadow; shadow; shadow = shadow->sdw_next)
	{
		if (!(shadow->sdw_flags & SDW_found))
			shadow->sdw_flags |= SDW_shutdown;
		else
			shadow->sdw_flags &= ~SDW_found;
	}

	SDW_check(tdbb);
}


ScanResult DbTriggers::scan(thread_db* tdbb, ObjectBase::Flag flags)
{
/********************************************
 *
 *      D b T r i g g e r s :: s c a n
 *
 ********************************************
 *
 * Functional description
 *      Load database-wide triggers from RDB$TRIGGERS.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	Database* dbb = tdbb->getDatabase();
	CHECK_DBB(dbb);

	if (flags & CacheFlag::MINISCAN)
		return ScanResult::REPEAT;

	auto type = perm->getId();
	FB_UINT64 mask = (type == DB_TRIGGER_DDL) ? TRIGGER_TYPE_MASK : ~FB_UINT64(0);
	type = (type == DB_TRIGGER_DDL) ? TRIGGER_TYPE_DDL : type | TRIGGER_TYPE_DB;

	AutoRequest trigger_request;

	FOR(REQUEST_HANDLE trigger_request TRANSACTION_HANDLE attachment->getMetaTransaction(tdbb))
		TRG IN RDB$TRIGGERS
		WITH TRG.RDB$RELATION_NAME MISSING AND
			 TRG.RDB$TRIGGER_INACTIVE EQ 0
		SORTED BY TRG.RDB$TRIGGER_SEQUENCE
	{
		if ((TRG.RDB$TRIGGER_TYPE & mask) == type)
		{
			MET_load_trigger(tdbb, nullptr, QualifiedName(TRG.RDB$TRIGGER_NAME, TRG.RDB$SCHEMA_NAME), [this](int)->Triggers& {return *this;});
		}
	}
	END_FOR

	return ScanResult::COMPLETE;
}


void MetadataCache::loadDbTriggers(thread_db* tdbb, unsigned int type)
{
/**************************************
 *
 *      l o a d _ d b _ t r i g g e r s
 *
 **************************************
 *
 * Functional description
 *      Load database triggers from RDB$TRIGGERS.
 *
 **************************************/

	SET_TDBB(tdbb);

	fb_assert(type < DB_TRIGGERS_COUNT);

	auto* cacheElement = mdc_triggers[type].load(atomics::memory_order_acquire);
	if (!cacheElement)
	{
		// actual type will be taken into an account in DbTriggers::scan
		auto* newCacheElement = FB_NEW_POOL(getPool())
			Cached::Triggers(tdbb, getPool(), type, NoData());
		newCacheElement->makeObject(tdbb, CacheFlag::AUTOCREATE);

		if (!mdc_triggers[type].compare_exchange_strong(cacheElement, newCacheElement,
			atomics::memory_order_release, atomics::memory_order_relaxed))
		{
			newCacheElement->releaseLocks(tdbb);
			newCacheElement->cleanup(tdbb);
			return;
		}
	}
}


void MET_load_trigger(thread_db* tdbb,
					  jrd_rel* relation,
					  const QualifiedName& trigger_name,
					  std::function<Triggers&(int)> triggers)
{
/**************************************
 *
 *      M E T _ l o a d _ t r i g g e r
 *
 **************************************
 *
 * Functional description
 *      Load triggers from RDB$TRIGGERS.  If a requested,
 *      also load triggers from RDB$RELATIONS.
 *
 **************************************/
	TEXT errmsg[MAX_ERRMSG_LEN + 1];

	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	Database* dbb = tdbb->getDatabase();
	CHECK_DBB(dbb);

	if (relation)
	{
		// No need to load table triggers for ReadOnly databases,
		// since INSERT/DELETE/UPDATE statements are not going to be allowed
		// hvlad: GTT with ON COMMIT DELETE ROWS clause is writable

		if (dbb->readOnly() && !(getPermanent(relation)->rel_flags & REL_temp_tran))
			return;
	}

	// Scan RDB$TRIGGERS next

	AutoCacheRequest request(tdbb, irq_s_triggers, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request TRANSACTION_HANDLE attachment->getMetaTransaction(tdbb))
		TRG IN RDB$TRIGGERS
		WITH TRG.RDB$SCHEMA_NAME EQ trigger_name.schema.c_str() AND
			 TRG.RDB$TRIGGER_NAME EQ trigger_name.object.c_str() AND
			 (TRG.RDB$TRIGGER_INACTIVE MISSING OR TRG.RDB$TRIGGER_INACTIVE EQ 0)
	{
		// check if the trigger is to be fired without any permissions
		// checks. Verify such a claim
		USHORT trig_flags = (USHORT) TRG.RDB$FLAGS;

		// if there is an ignore permission flag, see if it is legit
		if ((TRG.RDB$FLAGS & TRG_ignore_perm) && !verify_TRG_ignore_perm(tdbb, trigger_name))
		{
			fb_msg_format(NULL, FB_IMPL_MSG_FACILITY_JRD_BUGCHK, 304, sizeof(errmsg),
							errmsg, MsgFormat::SafeArg() << trigger_name.toQuotedString().c_str());
			ERR_log(FB_IMPL_MSG_FACILITY_JRD_BUGCHK, 304, errmsg);

			trig_flags &= ~TRG_ignore_perm;
		}

		bid debug_blob_id;
		debug_blob_id.clear();

		bid extBodyId;
		extBodyId.clear();

		if (!TRG.RDB$DEBUG_INFO.NULL)	// ODS_11_1
			debug_blob_id = TRG.RDB$DEBUG_INFO;

		MetaName engine;
		string entryPoint;

		if (!TRG.RDB$ENGINE_NAME.NULL)	// ODS_12_0
		{
			engine = TRG.RDB$ENGINE_NAME;
			extBodyId = TRG.RDB$TRIGGER_SOURCE;
		}

		if (!TRG.RDB$ENTRYPOINT.NULL)	// ODS_12_0
			entryPoint = TRG.RDB$ENTRYPOINT;

		TriState ssDefiner;

		// If SQL SECURITY for relation was not specified it will re-use DB default so we should not care about it
		if (!TRG.RDB$SQL_SECURITY.NULL)
			ssDefiner = (bool) TRG.RDB$SQL_SECURITY;
		else if (relation)
			ssDefiner = relation->rel_ss_definer;

		if (TRG.RDB$RELATION_NAME.NULL)
		{
			fb_assert(!relation);

			if ((TRG.RDB$TRIGGER_TYPE & TRIGGER_TYPE_MASK) == TRIGGER_TYPE_DB ||
				(TRG.RDB$TRIGGER_TYPE & TRIGGER_TYPE_MASK) == TRIGGER_TYPE_DDL)
			{
				// this is a database or DDL trigger
				get_trigger(tdbb,
							relation,
							&TRG.RDB$TRIGGER_BLR,
							&debug_blob_id,
							triggers(0),
							trigger_name,
							TRG.RDB$TRIGGER_TYPE,
							TRG.RDB$SYSTEM_FLAG,
							trig_flags,
							engine,
							entryPoint,
							&extBodyId,
							ssDefiner);
			}
		}
		else
		{
			// dimitr: support for the universal triggers
			int trigger_action, slot_index = 0;
			while ((trigger_action = TRIGGER_ACTION_SLOT(TRG.RDB$TRIGGER_TYPE, ++slot_index)) > 0)
			{
				get_trigger(tdbb,
							relation,
							&TRG.RDB$TRIGGER_BLR,
							&debug_blob_id,
							triggers(trigger_action),
							trigger_name,
							(UCHAR) trigger_action,
							TRG.RDB$SYSTEM_FLAG,
							trig_flags,
							engine,
							entryPoint,
							&extBodyId,
							ssDefiner);
			}
		}
	}
	END_FOR
}



void MET_lookup_index_for_cnstrt(thread_db* tdbb,
	QualifiedName& index_name,
	const QualifiedName& constraint_name)
{
/**************************************
*
*      M E T _ l o o k u p _ i n d e x _ f o r _ c n s t r t
*
**************************************
*
* Functional description
*      Lookup index name from constraint name, if one exists.
*      index_name is output parameter.
*
**************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	index_name.clear();

	AutoCacheRequest request(tdbb, irq_l_index_cnstrt, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		X IN RDB$RELATION_CONSTRAINTS
		WITH X.RDB$SCHEMA_NAME EQ constraint_name.schema.c_str() AND
			 X.RDB$CONSTRAINT_NAME EQ constraint_name.object.c_str()
	{
		if (!X.RDB$INDEX_NAME.NULL)
			index_name = QualifiedName(X.RDB$INDEX_NAME, X.RDB$SCHEMA_NAME);
	}
	END_FOR
}


void MET_lookup_cnstrt_for_index(thread_db* tdbb,
								 MetaName& constraint_name,
								 const QualifiedName& index_name)
{
/**************************************
 *
 *      M E T _ l o o k u p _ c n s t r t _ f o r _ i n d e x
 *
 **************************************
 *
 * Functional description
 *      Lookup  constraint name from index name, if one exists.
 *      constraint_name is output parameter.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	constraint_name = "";
	AutoCacheRequest request(tdbb, irq_l_cnstrt, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		X IN RDB$RELATION_CONSTRAINTS
		WITH X.RDB$SCHEMA_NAME EQ index_name.schema.c_str() AND
			 X.RDB$INDEX_NAME EQ index_name.object.c_str()
	{
		constraint_name = X.RDB$CONSTRAINT_NAME;
	}
	END_FOR
}


void MET_lookup_cnstrt_for_trigger(thread_db* tdbb,
								   MetaName& constraint_name,
								   QualifiedName& relation_name,
								   const QualifiedName& trigger_name)
{
/**************************************
 *
 *      M E T _ l o o k u p _ c n s t r t _ f o r _ t r i g g e r
 *
 **************************************
 *
 * Functional description
 *      Lookup  constraint name from trigger name, if one exists.
 *      constraint_name and relation_name are output parameters.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	constraint_name = "";
	relation_name.clear();

	AutoCacheRequest request(tdbb, irq_l_check, IRQ_REQUESTS);
	AutoCacheRequest request2(tdbb, irq_l_check2, IRQ_REQUESTS);

	// utilize two requests rather than one so that we
	// guarantee we always return the name of the relation
	// that the trigger is defined on, even if we don't
	// have a check constraint defined for that trigger

	FOR(REQUEST_HANDLE request)
		Y IN RDB$TRIGGERS
		WITH Y.RDB$SCHEMA_NAME EQ trigger_name.schema.c_str() AND
			 Y.RDB$TRIGGER_NAME EQ trigger_name.object.c_str()
	{
		FOR(REQUEST_HANDLE request2)
			X IN RDB$CHECK_CONSTRAINTS
			WITH X.RDB$SCHEMA_NAME EQ Y.RDB$SCHEMA_NAME AND
				 X.RDB$TRIGGER_NAME EQ Y.RDB$TRIGGER_NAME
		{
			constraint_name = X.RDB$CONSTRAINT_NAME;
		}
		END_FOR

		relation_name = QualifiedName(Y.RDB$RELATION_NAME, Y.RDB$SCHEMA_NAME);
	}
	END_FOR
}


void MET_lookup_exception(thread_db* tdbb,
						  SLONG number,
						  QualifiedName& name,
						  string* message)
{
/**************************************
 *
 *      M E T _ l o o k u p _ e x c e p t i o n
 *
 **************************************
 *
 * Functional description
 *      Lookup exception by number and return its name and message.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	// We need to look up exception in RDB$EXCEPTIONS

	AutoCacheRequest request(tdbb, irq_l_exception, IRQ_REQUESTS);

	name.clear();
	if (message)
		message->clear();

	FOR(REQUEST_HANDLE request)
		X IN RDB$EXCEPTIONS WITH X.RDB$EXCEPTION_NUMBER = number
	{
		if (!X.RDB$EXCEPTION_NAME.NULL)
			name = QualifiedName(X.RDB$EXCEPTION_NAME, X.RDB$SCHEMA_NAME);

		if (!X.RDB$MESSAGE.NULL && message)
			*message = X.RDB$MESSAGE;
	}
	END_FOR
}


bool MET_load_exception(thread_db* tdbb, ExceptionItem& item)
{
/**************************************
 *
 *      M E T _ l o a d _ e x c e p t i o n
 *
 **************************************
 *
 * Functional description
 *      Lookup exception by name and fill the passed instance.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	// We need to look up exception in RDB$EXCEPTIONS

	AutoCacheRequest request(tdbb, irq_l_except_no, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		XCP IN RDB$EXCEPTIONS
		CROSS SCH IN RDB$SCHEMAS
		WITH XCP.RDB$SCHEMA_NAME = item.name.schema.c_str() AND
			 XCP.RDB$EXCEPTION_NAME = item.name.object.c_str() AND
			 SCH.RDB$SCHEMA_NAME = XCP.RDB$SCHEMA_NAME
	{
		item.type = ExceptionItem::XCP_CODE;
		item.code = XCP.RDB$EXCEPTION_NUMBER;
		item.secName = QualifiedName(XCP.RDB$SECURITY_CLASS, SCH.RDB$SECURITY_CLASS);
		return true;
	}
	END_FOR

	return false;
}


ElementBase::ReturnedId MET_lookup_field(thread_db* tdbb, jrd_rel* relation, const MetaName& name)
{
/**************************************
 *
 *      M E T _ l o o k u p _ f i e l d
 *
 **************************************
 *
 * Functional description
 *      Look up a field name.
 *
 *	if the field is not found return -1
 *
 *****************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	// Start by checking field names that we already know
	vec<jrd_fld*>* vector = relation->rel_fields;

	if (vector)
	{
		int id = 0;
		vec<jrd_fld*>::iterator fieldIter = vector->begin();

		for (const vec<jrd_fld*>::const_iterator end = vector->end();  fieldIter < end;
			++fieldIter, ++id)
		{
			if (*fieldIter)
			{
				jrd_fld* field = *fieldIter;
				if (field->fld_name == name)
				{
					return id;
				}
			}
		}
	}

	ElementBase::ReturnedId id = -1;

	if (relation->isLTT())
	{
		if (const auto lttPtr = attachment->att_local_temporary_tables.get(relation->getName()))
		{
			const auto ltt = *lttPtr;

			for (const auto& lttField : ltt->fields)
			{
				if (lttField.name == name)
				{
					id = lttField.id;
					break;
				}
			}
		}

		return id;
	}

	// Not found.  Next, try system relations directly

	static const CachedRequestId request1CacheId;
	AutoCacheRequest request1(tdbb, request1CacheId);

	FOR(REQUEST_HANDLE request1)
		X IN RDB$RELATION_FIELDS
		WITH X.RDB$SCHEMA_NAME EQ relation->getName().schema.c_str() AND
			 X.RDB$RELATION_NAME EQ relation->getName().object.c_str() AND
			 X.RDB$FIELD_ID NOT MISSING AND
			 X.RDB$FIELD_NAME EQ name.c_str()
	{
		id = X.RDB$FIELD_ID;
	}
	END_FOR

	return id;
}


BlobFilter* MET_lookup_filter(thread_db* tdbb, SSHORT from, SSHORT to)
{
/**************************************
 *
 *      M E T _ l o o k u p _ f i l t e r
 *
 **************************************
 *
 * Functional description
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	Database* dbb = tdbb->getDatabase();

	FPTR_BFILTER_CALLBACK filter = NULL;
	BlobFilter* blf = NULL;

	AutoCacheRequest request(tdbb, irq_r_filters, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		X IN RDB$FILTERS WITH X.RDB$INPUT_SUB_TYPE EQ from AND
		X.RDB$OUTPUT_SUB_TYPE EQ to
	{
		filter = (FPTR_BFILTER_CALLBACK)
			Module::lookup(X.RDB$MODULE_NAME, X.RDB$ENTRYPOINT, dbb);
		if (filter)
		{
			blf = FB_NEW_POOL(*dbb->dbb_permanent) BlobFilter(*dbb->dbb_permanent);
			blf->blf_next = NULL;
			blf->blf_from = from;
			blf->blf_to = to;
			blf->blf_filter = filter;
			blf->blf_exception_message.printf(EXCEPTION_MESSAGE,
					X.RDB$FUNCTION_NAME, X.RDB$ENTRYPOINT, X.RDB$MODULE_NAME);
		}
	}
	END_FOR

	return blf;
}


bool MET_load_generator(thread_db* tdbb, GeneratorItem& item, bool* sysGen, SLONG* step)
{
/**************************************
 *
 *      M E T _ l o a d _ g e n e r a t o r
 *
 **************************************
 *
 * Functional description
 *      Lookup generator ID by its name and load its metadata into the passed object.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	if (item.name == QualifiedName(MASTER_GENERATOR, SYSTEM_SCHEMA))
	{
		item.id = 0;
		if (sysGen)
			*sysGen = true;
		if (step)
			*step = 1;
		return true;
	}

	AutoCacheRequest request(tdbb, irq_r_gen_id, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		GEN IN RDB$GENERATORS
		CROSS SCH IN RDB$SCHEMAS
		WITH GEN.RDB$SCHEMA_NAME EQ item.name.schema.c_str() AND
			 GEN.RDB$GENERATOR_NAME EQ item.name.object.c_str() AND
			 SCH.RDB$SCHEMA_NAME = GEN.RDB$SCHEMA_NAME
	{
		item.id = GEN.RDB$GENERATOR_ID;
		item.secName = QualifiedName(GEN.RDB$SECURITY_CLASS, SCH.RDB$SECURITY_CLASS);

		if (sysGen)
			*sysGen = (GEN.RDB$SYSTEM_FLAG == fb_sysflag_system);

		if (step)
			*step = GEN.RDB$GENERATOR_INCREMENT;

		return true;
	}
	END_FOR

	return false;
}

SLONG MET_lookup_generator(thread_db* tdbb, const QualifiedName& name, bool* sysGen, SLONG* step)
{
/**************************************
 *
 *      M E T _ l o o k u p _ g e n e r a t o r
 *
 **************************************
 *
 * Functional description
 *      Lookup generator ID by its name.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	if (name == QualifiedName(MASTER_GENERATOR, SYSTEM_SCHEMA))
	{
		if (sysGen)
			*sysGen = true;
		if (step)
			*step = 1;
		return 0;
	}

	AutoCacheRequest request(tdbb, irq_l_gen_id, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		X IN RDB$GENERATORS
		WITH X.RDB$SCHEMA_NAME EQ name.schema.c_str() AND
			 X.RDB$GENERATOR_NAME EQ name.object.c_str()
	{
		if (sysGen)
			*sysGen = (X.RDB$SYSTEM_FLAG == fb_sysflag_system);
		if (step)
			*step = X.RDB$GENERATOR_INCREMENT;

		return X.RDB$GENERATOR_ID;
	}
	END_FOR

	return -1;
}

bool MET_lookup_generator_id(thread_db* tdbb, SLONG gen_id, QualifiedName& name, bool* sysGen)
{
/**************************************
 *
 *      M E T _ l o o k u p _ g e n e r a t o r _ i d
 *
 **************************************
 *
 * Functional description
 *      Lookup generator (aka gen_id) by ID. It will load
 *		the name in the third parameter.
 *
 **************************************/
	SET_TDBB (tdbb);
	Attachment* attachment = tdbb->getAttachment();

	fb_assert(gen_id != 0);

	name.clear();

	AutoCacheRequest request(tdbb, irq_r_gen_id_num, IRQ_REQUESTS);

	FOR (REQUEST_HANDLE request)
		X IN RDB$GENERATORS WITH X.RDB$GENERATOR_ID EQ gen_id
	{
		if (sysGen)
			*sysGen = (X.RDB$SYSTEM_FLAG == fb_sysflag_system);

		name = QualifiedName(X.RDB$GENERATOR_NAME, X.RDB$SCHEMA_NAME);
	}
	END_FOR

	return name.object.hasData();
}

void MET_update_generator_increment(thread_db* tdbb, SLONG gen_id, SLONG step)
{
/**************************************
 *
 *      M E T _ u p d a t e _ g e n e r a t o r _ i n c r e m e n t
 *
 **************************************
 *
 * Functional description
 *      Update the step in a generator searched by ID.
 *		This function is for legacy code "SET GENERATOR TO value" only!
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	AutoCacheRequest request(tdbb, irq_upd_gen_id_increm, IRQ_REQUESTS);

	FOR (REQUEST_HANDLE request)
		X IN RDB$GENERATORS WITH X.RDB$GENERATOR_ID EQ gen_id

		// We never accept changing the step in sys gens.
		if (X.RDB$SYSTEM_FLAG == fb_sysflag_system)
			return;

		MODIFY X
			X.RDB$GENERATOR_INCREMENT = step;
		END_MODIFY
	END_FOR
}


IndexStatus MetadataCache::getIndexStatus(bool nullFlag, int state)
{
	if (nullFlag)
		return MET_index_active;

	switch (state)
	{
	case MET_index_active:
	case MET_index_inactive:
	case MET_index_deferred_active:
	case MET_index_deferred_drop:
		return (IndexStatus)state;

	default:
		break;
	}

	return MET_index_state_unknown;
}


bool MetadataCache::getIndexActive(bool nullFlag, int state)
{
	if (nullFlag)
		return true;

	switch (state)
	{
	case MET_index_active:
	case MET_index_deferred_drop:
		return true;

	default:
		break;
	}

	return false;
}


ElementBase::ReturnedId MetadataCache::lookup_index_name(thread_db* tdbb, const QualifiedName& index_name,
	MetaId* relationId, IndexStatus* status)
{
/**************************************
 *
 *      M E T _ l o o k u p _ i n d e x _ n a m e
 *
 **************************************
 *
 * Functional description
 *      Lookup index id from index name.
 *
 **************************************/
	ElementBase::ReturnedId id = -1;

	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	for (const auto& lttEntry : attachment->att_local_temporary_tables)
	{
		for (const auto& lttIndex : lttEntry.second->indexes)
		{
			if (lttIndex.name == index_name)
			{
				fb_assert(lttEntry.second->relationId != 0);
				if (relationId)
					*relationId = lttEntry.second->relationId;
				*status = lttIndex.inactive ? MET_index_inactive : MET_index_active;
				return lttIndex.id;
			}
		}

		// WHY Search for index only in first LTT ???????????
		return -1;
	}

	AutoCacheRequest request(tdbb, irq_l_index_name, IRQ_REQUESTS);

	*status = MET_index_state_unknown;

	FOR(REQUEST_HANDLE request)
		X IN RDB$INDICES
		WITH X.RDB$SCHEMA_NAME EQ index_name.schema.c_str() AND
			 X.RDB$INDEX_NAME EQ index_name.object.c_str()
	{
		*status = getIndexStatus(X.RDB$INDEX_INACTIVE.NULL, X.RDB$INDEX_INACTIVE);

		if ((!X.RDB$INDEX_ID.NULL) && X.RDB$INDEX_ID)
			id = X.RDB$INDEX_ID - 1;

		if (relationId)
		{
			auto* relation = MetadataCache::getPerm<Cached::Relation>(tdbb,
				QualifiedName(X.RDB$RELATION_NAME, X.RDB$SCHEMA_NAME), CacheFlag::AUTOCREATE);
			if (relation)
				*relationId = relation->getId();
			else
				id = -1; 		// signal error state
		}
	}
	END_FOR

	return id;
}


void MET_lookup_index_code(thread_db* tdbb, Cached::Relation* relation, index_desc* idx)
{
/***********************************************
*
*	M E T _ l o o k u p _ i n d e x _ c o d e
*
************************************************
*
* Functional description
*	Lookup information about an index.
*
**************************************/
	SET_TDBB(tdbb);

	IndexVersion* idv = relation->lookup_index(tdbb, idx->idx_id, CacheFlag::AUTOCREATE);
	if (idv)
	{
		idx->idx_condition_node = idv->idv_condition;
		idx->idx_condition_statement = idv->idv_condition_statement;

		idx->idx_expression_node = idv->idv_expression;
		idx->idx_expression_statement = idv->idv_expression_statement;
		memcpy(&idx->idx_expression_desc, &idv->idv_expression_desc, sizeof(struct dsc));
	}
}


bool MET_lookup_index_expr_cond_blr(thread_db* tdbb, const QualifiedName& index_name,
	bid& expr_blob_id, bid& cond_blob_id)
{
/**************************************
 *
 *      M E T _ l o o k u p _ i n d e x _ e x p r _ c o n d _ b l r
 *
 **************************************
 *
 * Functional description
 *		Lookup index expression and\or condition blob ID to use it later by many
 *		attachments and avoid of run of same lookup queries by all of them.
 *		Used by parallel index creation code.
 *
 **************************************/

	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	bool found = false;
	AutoCacheRequest request(tdbb, irq_l_exp_index_blr, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		IDX IN RDB$INDICES
		WITH IDX.RDB$SCHEMA_NAME EQ index_name.schema.c_str() AND
			 IDX.RDB$INDEX_NAME EQ index_name.object.c_str()
	{
		found = !IDX.RDB$EXPRESSION_BLR.NULL || !IDX.RDB$CONDITION_BLR.NULL;
		expr_blob_id = IDX.RDB$EXPRESSION_BLR;
		cond_blob_id = IDX.RDB$CONDITION_BLR;
	}
	END_FOR;

	return found;
}


bool MET_lookup_partner(thread_db* tdbb, RelationPermanent* relation, index_desc* idx, const QualifiedName& index_name)
{
/**************************************
 *
 *      M E T _ l o o k u p _ p a r t n e r
 *
 **************************************
 *
 * Functional description
 *      Find partner index participating in a
 *      foreign key relationship.
 *
 **************************************/

	SET_TDBB(tdbb);

	fb_assert(index_name.object.isEmpty() || index_name.schema == relation->getName().schema);

	Attachment* attachment = tdbb->getAttachment();

	if (relation->rel_flags & REL_check_partners)
		relation->scanPartners(tdbb);

	if (idx->idx_flags & idx_foreign)
	{
		if (index_name.object.hasData())
		{
			// Since primary key index names aren't being cached, do a long
			// hard lookup. This is only called during index create for foreign keys.

			bool found = false;
			AutoRequest request;

			FOR(REQUEST_HANDLE request)
				IDX IN RDB$INDICES CROSS
					IND IN RDB$INDICES WITH
					IDX.RDB$SCHEMA_NAME EQ relation->getName().schema.c_str() AND
					IDX.RDB$RELATION_NAME EQ relation->getName().object.c_str() AND
					(IDX.RDB$INDEX_ID EQ idx->idx_id + 1 OR
					 IDX.RDB$INDEX_NAME EQ index_name.object.c_str()) AND
					IND.RDB$SCHEMA_NAME EQ IDX.RDB$FOREIGN_KEY_SCHEMA_NAME AND
					IND.RDB$INDEX_NAME EQ IDX.RDB$FOREIGN_KEY AND
					IND.RDB$UNIQUE_FLAG = 1
			{
				const QualifiedName partnerRelationName(IND.RDB$RELATION_NAME, IND.RDB$SCHEMA_NAME);

				//// ASF: Hack fix for CORE-4304, until nasty interactions between dfw and met are not resolved.
				const auto* partner_relation = relation->getName() == partnerRelationName ?
					relation : MetadataCache::getPerm<Cached::Relation>(tdbb, partnerRelationName, CacheFlag::AUTOCREATE);

				if (partner_relation &&
					MetadataCache::getIndexActive(IDX.RDB$INDEX_INACTIVE.NULL, IDX.RDB$INDEX_INACTIVE) &&
					MetadataCache::getIndexActive(IND.RDB$INDEX_INACTIVE.NULL, IND.RDB$INDEX_INACTIVE))
				{
					idx->idx_primary_relation = partner_relation->getId();
					idx->idx_primary_index = IND.RDB$INDEX_ID - 1;
					fb_assert(idx->idx_primary_index != idx_invalid);
					found = true;
				}
			}
			END_FOR

			return found;
		}

		auto* references = relation->rel_foreign_refs;
		if (references)
		{
			for (auto& dep : *references)
			{
				if (idx->idx_id == dep.dep_reference_id)
				{
					idx->idx_primary_relation = dep.dep_relation;
					idx->idx_primary_index = dep.dep_index;
					return true;
				}
			}
		}
		return false;
	}
	else if (idx->idx_flags & (idx_primary | idx_unique))
	{
		auto* dependencies = relation->rel_primary_dpnds;
		if (dependencies)
		{
			for (auto& dep : *dependencies)
			{
				if (idx->idx_id == dep.dep_reference_id)
				{
					idx->idx_foreign_dep = dep;
					return true;
				}
			}
		}
		return false;
	}

	return false;
}


std::optional<MetaId> jrd_prc::getIdByName(thread_db* tdbb, const QualifiedName& name)
{
/**************************************
 *
 *      M E T _ l o o k u p _ p r o c e d u r e
 *
 **************************************
 *
 * Functional description
 *      Lookup procedure by name.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	std::optional<MetaId> id;

	// We need to look up the procedure name in RDB$PROCEDURES

	AUTO_HANDLE(request);

	FOR(REQUEST_HANDLE request)
		P IN RDB$PROCEDURES
		WITH P.RDB$SCHEMA_NAME EQ name.schema.c_str() AND
			 P.RDB$PROCEDURE_NAME EQ name.object.c_str() AND
			 P.RDB$PACKAGE_NAME EQUIV NULLIF(name.package.c_str(), '')
	{
		fb_assert(!id.has_value());
		id = P.RDB$PROCEDURE_ID;
	}
	END_FOR

	return id;
}


std::optional<MetaId> Function::getIdByName(thread_db* tdbb, const QualifiedName& name)
{
/************************************************
 *
 *      M E T _ l o o k u p _ f u n c t i o n
 *
 ************************************************
 *
 * Functional description
 *      Lookup function by name.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	std::optional<MetaId> id;

	// We need to look up the function in RDB$FUNCTIONS

	AUTO_HANDLE(request);

	FOR(REQUEST_HANDLE request)
		X IN RDB$FUNCTIONS
		WITH X.RDB$FUNCTION_NAME EQ name.object.c_str() AND
			 X.RDB$SCHEMA_NAME EQ name.schema.c_str() AND
			 X.RDB$PACKAGE_NAME EQUIV NULLIF(name.package.c_str(), '')
	{
		fb_assert(!id.has_value());
		id = X.RDB$FUNCTION_ID;
	}
	END_FOR

	return id;
}


std::optional<MetaId> jrd_rel::getIdByName(thread_db* tdbb, const QualifiedName& name)
{
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	std::optional<MetaId> id;

	// We need to look up the relation name in RDB$RELATIONS

	AUTO_HANDLE(request);

	FOR(REQUEST_HANDLE request)
		X IN RDB$RELATIONS
		WITH X.RDB$SCHEMA_NAME EQ name.schema.c_str() AND
			 X.RDB$RELATION_NAME EQ name.object.c_str()
	{
		fb_assert(!id.has_value());
		id = X.RDB$RELATION_ID;
	}
	END_FOR

	return id;
}


DmlNode* MET_parse_blob(thread_db*					tdbb,
						const MetaName*				schema,
						Cached::Relation*			relation,
						bid*						blob_id,
						CompilerScratch**			csb_ptr,
						Statement**					statementPtr,
						const bool					trigger,
						bool 						validationExpr)
{
/**************************************
 *
 *      M E T _ p a r s e _ b l o b
 *
 **************************************
 *
 * Functional description
 *      Parse blr, returning a compiler scratch block with the results.
 *
 * if ignore_perm is true then, the request generated must be set to
 *   ignore all permissions checks. In this case, we call PAR_blr
 *   passing it the csb_ignore_perm flag to generate a request
 *   which must go through without checking any permissions.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	blb* blob = blb::open(tdbb, attachment->getSysTransaction(), blob_id);
	ULONG length = blob->blb_length + 10;
	HalfStaticArray<UCHAR, 512> tmp;
	UCHAR* temp = tmp.getBuffer(length);
	length = blob->BLB_get_data(tdbb, temp, length);

	DmlNode* node = NULL;

	if (validationExpr)
	{
		// The set of MET parse functions needs a rework.
		// For now, our caller chain is not interested in the returned node.
		PAR_validation_blr(tdbb, schema, relation, temp, length, NULL, csb_ptr, 0);
	}
	else
		node = PAR_blr(tdbb, schema, relation, temp, length, NULL, csb_ptr, statementPtr, trigger, 0);

	return node;
}


void MET_prepare(thread_db* tdbb, jrd_tra* transaction, USHORT length, const UCHAR* msg)
{
/**************************************
 *
 *      M E T _ p r e p a r e
 *
 **************************************
 *
 * Functional description
 *      Post a transaction description to RDB$TRANSACTIONS.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	AutoCacheRequest request(tdbb, irq_s_trans, IRQ_REQUESTS);

	STORE(REQUEST_HANDLE request) X IN RDB$TRANSACTIONS
	{
		X.RDB$TRANSACTION_ID = transaction->tra_number;
		X.RDB$TRANSACTION_STATE = RDB$TRANSACTIONS.RDB$TRANSACTION_STATE.LIMBO;
		blb* blob = blb::create(tdbb, attachment->getSysTransaction(), &X.RDB$TRANSACTION_DESCRIPTION);
		blob->BLB_put_segment(tdbb, msg, length);
		blob->BLB_close(tdbb);
	}
	END_STORE
}


jrd_prc* MetadataCache::findProcedure(thread_db* tdbb, MetaId id, ObjectBase::Flag flags)
{
/**************************************
 *
 *      M E T _ p r o c e d u r e
 *
 **************************************
 *
 * Functional description
 *      Find or create a procedure block for a given procedure id.
 *
 **************************************/
	SET_TDBB(tdbb);

	return MetadataCache::get(tdbb)->mdc_procedures.getVersioned(tdbb, id, flags);
}

jrd_prc* jrd_prc::create(thread_db* tdbb, MemoryPool&, Cached::Procedure* perm)
{
	return FB_NEW_POOL(perm->getPool()) jrd_prc(perm);
}

ScanResult jrd_prc::scan(thread_db* tdbb, ObjectBase::Flag flags)
{
	Attachment* attachment = tdbb->getAttachment();
	jrd_tra* metaTransaction = attachment->getMetaTransaction(tdbb);
	Database* dbb = tdbb->getDatabase();
	MetadataCache* mdc = dbb->dbb_mdc;
	bool found = false;

	{
		AutoCacheRequest request(tdbb, irq_r_procedure, IRQ_REQUESTS);

		FOR(REQUEST_HANDLE request TRANSACTION_HANDLE metaTransaction)
			P IN RDB$PROCEDURES
			CROSS SCH IN RDB$SCHEMAS
			OVER RDB$SCHEMA_NAME
			WITH P.RDB$PROCEDURE_ID EQ getId()
		{
			found = true;

			if (getName().toQuotedString().length() == 0)
				getPermanent()->name = QualifiedName(P.RDB$PROCEDURE_NAME, P.RDB$SCHEMA_NAME, P.RDB$PACKAGE_NAME);

			TriState ssDefiner;

			if (!P.RDB$SECURITY_CLASS.NULL)
				getPermanent()->setSecurityName(QualifiedName(P.RDB$SECURITY_CLASS, SCH.RDB$SECURITY_CLASS));
			else if (!P.RDB$PACKAGE_NAME.NULL)
			{
				AutoCacheRequest requestHandle(tdbb, irq_l_procedure_pkg_class, IRQ_REQUESTS);

				FOR (REQUEST_HANDLE requestHandle TRANSACTION_HANDLE metaTransaction)
					PKG IN RDB$PACKAGES
					WITH PKG.RDB$SCHEMA_NAME EQ SCH.RDB$SCHEMA_NAME AND
						 PKG.RDB$PACKAGE_NAME EQ P.RDB$PACKAGE_NAME
				{
					if (!PKG.RDB$SECURITY_CLASS.NULL)
						getPermanent()->setSecurityName(QualifiedName(PKG.RDB$SECURITY_CLASS, SCH.RDB$SECURITY_CLASS));

					if (!PKG.RDB$SQL_SECURITY.NULL)
						ssDefiner = (bool) PKG.RDB$SQL_SECURITY;
				}
				END_FOR
			}

			if (ssDefiner.isUnknown())
			{
				if (!P.RDB$SQL_SECURITY.NULL)
					ssDefiner = (bool) P.RDB$SQL_SECURITY;
				else
					ssDefiner = MET_get_ss_definer(tdbb, P.RDB$SCHEMA_NAME);
			}

			if (getPermanent()->owner.length() == 0)
				getPermanent()->owner = P.RDB$OWNER_NAME;

			if (ssDefiner.asBool())
				invoker = dbb->getUserId(getPermanent()->owner);

			setDefined(true);
			getInputFields().resize(P.RDB$PROCEDURE_INPUTS);
			getOutputFields().resize(P.RDB$PROCEDURE_OUTPUTS);
			setDefaultCount(0);

			AutoCacheRequest request2(tdbb, irq_r_params, IRQ_REQUESTS);

			const MetaName packageName(P.RDB$PACKAGE_NAME.NULL ? NULL : P.RDB$PACKAGE_NAME);

			FOR (REQUEST_HANDLE request2 TRANSACTION_HANDLE metaTransaction)
				PA IN RDB$PROCEDURE_PARAMETERS
				CROSS F IN RDB$FIELDS
				WITH PA.RDB$SCHEMA_NAME = P.RDB$SCHEMA_NAME AND
					 PA.RDB$PACKAGE_NAME EQUIV NULLIF(packageName.c_str(), '') AND
					 PA.RDB$PROCEDURE_NAME = P.RDB$PROCEDURE_NAME AND
					 F.RDB$SCHEMA_NAME = PA.RDB$FIELD_SOURCE_SCHEMA_NAME AND
					 F.RDB$FIELD_NAME = PA.RDB$FIELD_SOURCE

			{
				const SSHORT pa_collation_id_null = PA.RDB$COLLATION_ID.NULL;
				const CollId pa_collation_id(PA.RDB$COLLATION_ID);
				const SSHORT pa_default_value_null = PA.RDB$DEFAULT_VALUE.NULL;
				bid pa_default_value = pa_default_value_null ? F.RDB$DEFAULT_VALUE : PA.RDB$DEFAULT_VALUE;

				Array<NestConst<Parameter> >& paramArray = PA.RDB$PARAMETER_TYPE ?
					getOutputFields() : getInputFields();

				// should be error if field already exists
				Parameter* parameter = FB_NEW_POOL(mdc->getPool()) Parameter(mdc->getPool());
				parameter->prm_number = PA.RDB$PARAMETER_NUMBER;
				paramArray[parameter->prm_number] = parameter;
				parameter->prm_name = PA.RDB$PARAMETER_NAME;
				parameter->prm_nullable = PA.RDB$NULL_FLAG.NULL || PA.RDB$NULL_FLAG == 0;	// ODS_11_1
				parameter->prm_mechanism = PA.RDB$PARAMETER_MECHANISM.NULL ?	// ODS_11_1
					prm_mech_normal : (prm_mech_t) PA.RDB$PARAMETER_MECHANISM;

				if (!PA.RDB$FIELD_SOURCE.NULL)
					parameter->prm_field_source = QualifiedName(PA.RDB$FIELD_SOURCE, PA.RDB$FIELD_SOURCE_SCHEMA_NAME);

				DSC_make_descriptor(&parameter->prm_desc, F.RDB$FIELD_TYPE,
									F.RDB$FIELD_SCALE, F.RDB$FIELD_LENGTH,
									F.RDB$FIELD_SUB_TYPE, CSetId(F.RDB$CHARACTER_SET_ID),
									(pa_collation_id_null ? CollId(F.RDB$COLLATION_ID) : pa_collation_id));

				if (F.RDB$FIELD_TYPE == blr_blob)
					parameter->prm_seg_length = F.RDB$SEGMENT_LENGTH;

				if (parameter->prm_desc.isText() && parameter->prm_desc.getTextType() != CS_NONE)
				{
					if (!pa_collation_id_null || fb_utils::implicit_domain(PA.RDB$FIELD_SOURCE))
						parameter->prm_text_type = parameter->prm_desc.getTextType();
				}

				if (!PA.RDB$RELATION_NAME.NULL)
					parameter->prm_type_of_table = QualifiedName(PA.RDB$RELATION_NAME, PA.RDB$RELATION_SCHEMA_NAME);

				if (!PA.RDB$FIELD_NAME.NULL)
					parameter->prm_type_of_column = PA.RDB$FIELD_NAME;

				if (PA.RDB$PARAMETER_TYPE == 0 &&
					(!pa_default_value_null ||
					 (fb_utils::implicit_domain(F.RDB$FIELD_NAME) && !F.RDB$DEFAULT_VALUE.NULL)))
				{
					setDefaultCount(getDefaultCount() + 1);
					MemoryPool* pool = dbb->createPool();
					Jrd::ContextPoolHolder context(tdbb, pool);

					try
					{
						parameter->prm_default_value = static_cast<ValueExprNode*>(
							MET_parse_blob(tdbb, &getName().schema, nullptr, &pa_default_value,
								NULL, NULL, false, false));
					}
					catch (const Exception&)
					{
						// Here we lose pools created for previous defaults.
						// Probably we should use common pool for defaults and procedure itself.

						dbb->deletePool(pool);
						throw;
					}
				}
			}
			END_FOR

			const bool external = !P.RDB$ENGINE_NAME.NULL;	// ODS_12_0

			auto& paramArray = getOutputFields();
			if (paramArray.hasData() && paramArray[0])
			{
				Format* format = Format::newFormat(mdc->getPool(), getOutputFields().getCount());
				prc_record_format = format;
				ULONG length = FLAG_BYTES(format->fmt_count);
				Format::fmt_desc_iterator desc = format->fmt_desc.begin();
				Array<NestConst<Parameter> >::iterator ptr, end;
				for (ptr = paramArray.begin(), end = paramArray.end(); ptr < end; ++ptr, ++desc)
				{
					const Parameter* parameter = *ptr;
					// check for parameter to be null, this can only happen if the
					// parameter numbers get out of sync. This was added to fix bug
					// 10534. -Shaunak Mistry 12-May-99
					if (parameter)
					{
						*desc = parameter->prm_desc;
						length = MET_align(&(*desc), length);
						desc->dsc_address = (UCHAR *) (IPTR) length;
						length += desc->dsc_length;
					}
				}

				format->fmt_length = length;
			}

			prc_type = P.RDB$PROCEDURE_TYPE.NULL ?
				prc_legacy : (prc_t) P.RDB$PROCEDURE_TYPE;

			if (external || !P.RDB$PROCEDURE_BLR.NULL)
			{
				MemoryPool* const csb_pool = dbb->createPool();
				Jrd::ContextPoolHolder context(tdbb, csb_pool);

				try
				{
					AutoPtr<CompilerScratch> csb(FB_NEW_POOL(*csb_pool) CompilerScratch(*csb_pool));

					if (external)
					{
						HalfStaticArray<char, 512> body;

						if (!P.RDB$PROCEDURE_SOURCE.NULL)
						{
							blb* blob = blb::open(tdbb, attachment->getSysTransaction(),
								&P.RDB$PROCEDURE_SOURCE);
							ULONG len = blob->BLB_get_data(tdbb,
								(UCHAR*) body.getBuffer(blob->blb_length + 1), blob->blb_length + 1);
							body.begin()[MIN(blob->blb_length, len)] = '\0';
						}
						else
							body.getBuffer(1)[0] = '\0';

						dbb->dbb_extManager->makeProcedure(tdbb, csb, this, P.RDB$ENGINE_NAME,
							(P.RDB$ENTRYPOINT.NULL ? "" : P.RDB$ENTRYPOINT), body.begin());

						if (!getExternal())
							setDefined(false);

						setImplemented(true);
					}
					else if (compiling || (flags & CacheFlag::MINISCAN))
						flReload = true;
					else
					{
						fb_assert(!P.RDB$PROCEDURE_BLR.NULL);

						const string name = getName().toQuotedString();
						try
						{
							TraceProcCompile trace(tdbb, name);

							parseBlr(tdbb, csb, &P.RDB$PROCEDURE_BLR,
								P.RDB$DEBUG_INFO.NULL ? NULL : &P.RDB$DEBUG_INFO);

							trace.finish(getStatement(), ITracePlugin::RESULT_SUCCESS);
						}
						catch (const Exception& ex)
						{
							StaticStatusVector temp_status;
							ex.stuffException(temp_status);
							flReload = true;
							(Arg::StatusVector(temp_status.begin()) <<
								Arg::Gds(isc_bad_proc_BLR) << name).raise();
						}
					}
				}
				catch (const Exception&)
				{
					if (getStatement())
						releaseStatement(tdbb);
					else
						dbb->deletePool(csb_pool);

					throw;
				}

				fb_assert((!isDefined()) || flReload || (getStatement()->procedure == this));
			}
			else
			{
				RefPtr<MsgMetadata> inputMetadata(REF_NO_INCR,
					Routine::createMetadata(getInputFields(), false));
				setInputFormat(
					Routine::createFormat(getPermanent()->getPool(), inputMetadata, false));

				RefPtr<MsgMetadata> outputMetadata(REF_NO_INCR,
					Routine::createMetadata(getOutputFields(), false));
				setOutputFormat(
					Routine::createFormat(getPermanent()->getPool(), outputMetadata, true));

				if (compiling || (flags & CacheFlag::MINISCAN))
					flReload = true;
			}

			if (!dbb->readOnly() &&
				!P.RDB$PROCEDURE_BLR.NULL &&
				!P.RDB$VALID_BLR.NULL && P.RDB$VALID_BLR == FALSE)
			{
				// If the BLR was marked as invalid but the procedure was compiled,
				// mark the BLR as valid.

				AutoRequest request;

				FOR(REQUEST_HANDLE request TRANSACTION_HANDLE attachment->getSysTransaction())
					PP IN RDB$PROCEDURES WITH PP.RDB$PROCEDURE_ID EQ getId()
				{
					MODIFY PP USING
						PP.RDB$VALID_BLR = TRUE;
						PP.RDB$VALID_BLR.NULL = FALSE;
					END_MODIFY
				}
				END_FOR
			}
		}
		END_FOR
	}

	return found ? (flReload ? ScanResult::REPEAT : ScanResult::COMPLETE) : ScanResult::MISS;
}

void jrd_prc::checkReload(thread_db* tdbb) const
{
	if (flReload)
		getPermanent()->reload(tdbb, 0);
}

ScanResult jrd_prc::reload(thread_db* tdbb, ObjectBase::Flag /*unused*/)
{
	fb_assert(flReload);

	Attachment* attachment = tdbb->getAttachment();
	AutoCacheRequest request(tdbb, irq_r_proc_blr, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request TRANSACTION_HANDLE attachment->getMetaTransaction(tdbb))
		P IN RDB$PROCEDURES
		WITH P.RDB$PROCEDURE_ID EQ this->getId()
	{
		// sanity check
		if (compiling || P.RDB$PROCEDURE_BLR.NULL)
			return ScanResult::REPEAT;

		MemoryPool* const csb_pool = tdbb->getDatabase()->createPool();
		Jrd::ContextPoolHolder context(tdbb, csb_pool);

		try
		{
			AutoPtr<CompilerScratch> csb(FB_NEW_POOL(*csb_pool) CompilerScratch(*csb_pool));

			try
			{
				this->parseBlr(tdbb, csb, &P.RDB$PROCEDURE_BLR,
					P.RDB$DEBUG_INFO.NULL ? NULL : &P.RDB$DEBUG_INFO);

				return flReload ? ScanResult::REPEAT : ScanResult::COMPLETE;
			}
			catch (const Exception& ex)
			{
				StaticStatusVector temp_status;
				ex.stuffException(temp_status);
				flReload = true;

				(Arg::StatusVector(temp_status.begin()) <<
					Arg::Gds(isc_bad_proc_BLR) << this->getName().toQuotedString()).raise();
			}
		}
		catch (const Exception&)
		{
			tdbb->getDatabase()->deletePool(csb_pool);
			throw;
		}
	}
	END_FOR

	return ScanResult::MISS;
}


void MET_revoke(thread_db* tdbb, jrd_tra* transaction, const QualifiedName& relation,
	const QualifiedName& revokee, const string& privilege)
{
/**************************************
 *
 *      M E T _ r e v o k e
 *
 **************************************
 *
 * Functional description
 *      Execute a recursive revoke.  This is called only when
 *      a revoked privilege had the grant option.
 *
 **************************************/
	SET_TDBB(tdbb);

	// See if the revokee still has the privilege.  If so, there's nothing to do

	USHORT count = 0;

	AutoCacheRequest request(tdbb, irq_revoke1, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request TRANSACTION_HANDLE transaction)
		FIRST 1 P IN RDB$USER_PRIVILEGES
		WITH P.RDB$RELATION_SCHEMA_NAME EQUIV NULLIF(relation.schema.c_str(), '') AND
			 P.RDB$RELATION_NAME EQ relation.object.c_str() AND
			 P.RDB$PRIVILEGE EQ privilege.c_str() AND
			 P.RDB$USER_SCHEMA_NAME EQUIV NULLIF(revokee.schema.c_str(), '') AND
			 P.RDB$USER EQ revokee.object.c_str()
	{
		++count;
	}
	END_FOR

	if (count)
		return;

	request.reset(tdbb, irq_revoke2, IRQ_REQUESTS);

	// User lost privilege.  Take it away from anybody he/she gave it to.

	FOR(REQUEST_HANDLE request TRANSACTION_HANDLE transaction)
		P IN RDB$USER_PRIVILEGES
		WITH P.RDB$RELATION_SCHEMA_NAME EQUIV NULLIF(relation.schema.c_str(), '') AND
			 P.RDB$RELATION_NAME EQ relation.object.c_str() AND
			 P.RDB$PRIVILEGE EQ privilege.c_str() AND
			 P.RDB$GRANTOR EQ revokee.object.c_str()
	{
		ERASE P;
	}
	END_FOR
}


ScanResult jrd_rel::scan(thread_db* tdbb, ObjectBase::Flag& flags)
{
/**************************************
 *
 *      s c a n _ r e l a t i o n
 *
 **************************************
 *
 * Functional description
 *      Scan a relation for view RecordSelExpr, computed by expressions, missing
 *      expressions, and validation expressions.
 *
 **************************************/
	SET_TDBB(tdbb);

	if (rel_perm->rel_flags & REL_temp_ltt)
		return ScanResult::COMPLETE;

	Attachment* attachment = tdbb->getAttachment();
	Database* dbb = tdbb->getDatabase();
	Jrd::ContextPoolHolder context(tdbb, dbb->dbb_permanent);
	blb* blob = NULL;
	jrd_tra* trans = attachment->getMetaTransaction(tdbb);

	if ((flags & CacheFlag::MINISCAN) || getName().isEmpty())
	{
		// New version of relation is created currently.
		// Perform only very basic scan - may be more changes to come.
		// scan() will be called automatically w/o NOCOMMIT
		// on any attempt to use modified relation
		// or on transaction commit.

		bool found = getName().hasData();

		if (!found)
		{
			static const CachedRequestId requestCacheId;
			AutoCacheRequest request(tdbb, requestCacheId);

			FOR(REQUEST_HANDLE request TRANSACTION_HANDLE trans)
				REL IN RDB$RELATIONS WITH REL.RDB$RELATION_ID EQ getId()
			{
				found = true;

				rel_perm->rel_name = QualifiedName(REL.RDB$RELATION_NAME, REL.RDB$SCHEMA_NAME);
				rel_perm->rel_flags |= get_rel_flags_from_FLAGS(REL.RDB$FLAGS);
				if (!REL.RDB$RELATION_TYPE.NULL)
					rel_perm->rel_flags |= MET_get_rel_flags_from_TYPE(REL.RDB$RELATION_TYPE);

				rel_current_fmt = REL.RDB$FORMAT;
			}
			END_FOR
		}

		if (flags & CacheFlag::MINISCAN)
		{
			if (found)
			{
				fb_assert(getName().hasData());		// i.e. correct record in RDB$RELATIONS exists
				if (getName().hasData())
				{
					// Next time reload() will be called
					return ScanResult::REPEAT;
				}
			}

			// something gone wrong
			return ScanResult::MISS;
		}
	}

	bool dependencies = (rel_perm->rel_flags & REL_get_dependencies) ? true : false;

	// If anything errors, cleanup to reset the flag.
	// This will ensure that the error will be caught if the operation is tried again.
	Cleanup onError([&] {
		if (dependencies)
			rel_perm->rel_flags |= REL_get_dependencies;

		if (blob)
			blob->BLB_close(tdbb);
	});

	rel_perm->rel_flags &= ~REL_get_dependencies;

	// Do we need new format version?
	bool triggersLoaded = false;
	if (flags & CacheFlag::DB_VERSION)
	{
		RelationNode::makeVersion(tdbb, tdbb->getTransaction(), getName());
		flags &= ~CacheFlag::DB_VERSION;

		for (int n = 1; n < TRIGGER_MAX; ++n)
		{
			if (rel_triggers[n].hasData())
			{
				triggersLoaded = true;
				break;
			}
		}
	}

	// Since this can be called recursively, find an inactive clone of the request

	AutoCacheRequest request(tdbb, irq_r_fields, IRQ_REQUESTS);
	CompilerScratch* csb = NULL;
	bool found = false;

	FOR(REQUEST_HANDLE request TRANSACTION_HANDLE trans)
		REL IN RDB$RELATIONS
		CROSS SCH IN RDB$SCHEMAS
		WITH REL.RDB$RELATION_ID EQ getId() AND
			 SCH.RDB$SCHEMA_NAME EQ REL.RDB$SCHEMA_NAME
	{
		found = true;

		if (getName().isEmpty())
			rel_perm->rel_name = QualifiedName(REL.RDB$RELATION_NAME, REL.RDB$SCHEMA_NAME);

		rel_perm->rel_flags |= get_rel_flags_from_FLAGS(REL.RDB$FLAGS);
		if (!REL.RDB$RELATION_TYPE.NULL)
			rel_perm->rel_flags |= MET_get_rel_flags_from_TYPE(REL.RDB$RELATION_TYPE);

		// Pick up relation level stuff
		rel_dbkey_length = REL.RDB$DBKEY_LENGTH;
		fb_assert(rel_dbkey_length % 8 == 0);
		if (!rel_dbkey_length)
			rel_dbkey_length = 8;

		rel_current_fmt = REL.RDB$FORMAT;
		rel_fields = vec<jrd_fld*>::newVector(*rel_pool, rel_fields, REL.RDB$FIELD_ID);
		if (rel_perm->rel_security_name.isEmpty() && !REL.RDB$SECURITY_CLASS.NULL)
			rel_perm->rel_security_name = QualifiedName(REL.RDB$SECURITY_CLASS, SCH.RDB$SECURITY_CLASS);

		rel_perm->rel_owner_name = REL.RDB$OWNER_NAME;

		if (!REL.RDB$SQL_SECURITY.NULL)
			rel_ss_definer = (bool) REL.RDB$SQL_SECURITY;
		else
			rel_ss_definer = MET_get_ss_definer(tdbb, REL.RDB$SCHEMA_NAME);

		if (!REL.RDB$VIEW_BLR.isEmpty())
		{
			// parse the view blr, getting dependencies on relations, etc. at the same time

			DmlNode* rseNode;

			if (dependencies)
			{
				rseNode = MET_get_dependencies(tdbb, this, NULL, 0, NULL, &REL.RDB$VIEW_BLR,
					NULL, &csb, getName(), obj_view, 0, trans);
			}
			else
			{
				rseNode = MET_parse_blob(tdbb, &getName().schema, rel_perm, &REL.RDB$VIEW_BLR,
					&csb, NULL, false, false);
			}

			if (rseNode)
			{
				fb_assert(rseNode->getKind() == DmlNode::KIND_REC_SOURCE);
				rel_view_rse = nodeAs<RseNode>(static_cast<RecordSourceNode*>(rseNode));
				fb_assert(rel_view_rse);

				// for very old gbak images...
				rel_perm->rel_flags |= REL_jrd_view;
			}
			else
				rel_view_rse = NULL;

			// retrieve the view context names

			lookup_view_contexts(tdbb, this);
		}

		if (REL.RDB$EXTERNAL_FILE[0] && !rel_perm->getExtFile())
		{
			rel_perm->setExtFile(ExternalFile::create(getPool(), REL.RDB$EXTERNAL_FILE));
		}

		if (!REL.RDB$RELATION_TYPE.NULL)
		{
			switch (REL.RDB$RELATION_TYPE)
			{
				case rel_persistent:
					break;
				case rel_external:
					fb_assert(getExtFile());
					break;
				case rel_view:
					fb_assert(rel_view_rse);
					fb_assert(rel_perm->rel_flags & REL_jrd_view);
					rel_perm->rel_flags |= REL_jrd_view;
					break;
				case rel_virtual:
					fb_assert(rel_perm->rel_flags & REL_virtual);
					rel_perm->rel_flags |= REL_virtual;
					break;
				case rel_temp_preserve:
					fb_assert((rel_perm->rel_flags & (REL_temp_conn | REL_temp_gtt)) == (REL_temp_conn | REL_temp_gtt));
					rel_perm->rel_flags |= REL_temp_conn | REL_temp_gtt;
					break;
				case rel_temp_delete:
					fb_assert((rel_perm->rel_flags & (REL_temp_tran | REL_temp_gtt)) == (REL_temp_tran | REL_temp_gtt));
					rel_perm->rel_flags |= REL_temp_tran | REL_temp_gtt;
					break;
				default:
					fb_assert(false);
			}
		}

		// Pick up field specific stuff

		blob = blb::open(tdbb, trans, &REL.RDB$RUNTIME);
		HalfStaticArray<UCHAR, 256> temp;
		UCHAR* const buffer = temp.getBuffer(blob->getMaxSegment() + 1U);

		jrd_fld* field = NULL;
		ArrayField* array = 0;
		USHORT view_context = 0;
		USHORT field_id = 0;
		for (;;)
		{
			USHORT length = blob->BLB_get_segment(tdbb, buffer, blob->getMaxSegment());
			if (blob->blb_flags & BLB_eof)
			{
				break;
			}
			USHORT n;
			buffer[length] = 0;
			UCHAR* p = (UCHAR*) &n;
			const UCHAR* q = buffer + 1;
			while (q < buffer + 1 + sizeof(SSHORT))
			{
				*p++ = *q++;
			}
			p = buffer + 1;
			--length;
			switch ((rsr_t) buffer[0])
			{
			case RSR_field_id:
				if (field && field->fld_security_name.isEmpty() && !REL.RDB$DEFAULT_CLASS.NULL)
					field->fld_security_name = REL.RDB$DEFAULT_CLASS;
				field_id = n;
				field = (*rel_fields)[field_id];

				if (field)
				{
					field->fld_computation = NULL;
					field->fld_missing_value = NULL;
					field->fld_default_value = NULL;
					field->fld_validation = NULL;
					field->fld_not_null = NULL;
					field->fld_generator_name.clear();
				}

				array = NULL;
				break;

			case RSR_field_name:
				if (field)
				{
					// The field exists.  If its name hasn't changed, then
					// there's no need to copy anything.

					if (field->fld_name == reinterpret_cast<char*>(p))
						break;
				}
				else
				{
					field = FB_NEW_POOL(*rel_pool) jrd_fld(*rel_pool);
					(*rel_fields)[field_id] = field;
				}
				field->fld_name = reinterpret_cast<char*>(p);

				// CVC: Be paranoid and allow the possible trigger(s) to have a
				//   not null security class to work on, even if we only take it
				//   from the relation itself.
				if (field->fld_security_name.isEmpty() && !REL.RDB$DEFAULT_CLASS.NULL)
					field->fld_security_name = REL.RDB$DEFAULT_CLASS;

				break;

			case RSR_field_source:
				field->fld_source_name = QualifiedName::parseSchemaObject(reinterpret_cast<char*>(p));
				break;

			case RSR_view_context:
				view_context = n;
				break;

			case RSR_base_field:
				if (dependencies)
				{
					csb->csb_g_flags |= csb_get_dependencies;
					field->fld_source = PAR_make_field(tdbb, csb, view_context, (TEXT*) p);
					const QualifiedName depName(REL.RDB$RELATION_NAME, REL.RDB$SCHEMA_NAME);
					MET_store_dependencies(tdbb, csb->csb_dependencies, nullptr, depName, obj_view, trans);
				}
				else
					field->fld_source = PAR_make_field(tdbb, csb, view_context, (TEXT*) p);

				{	// scope
					const ViewContexts& ctx = rel_view_contexts;
					FB_SIZE_T pos;

					if (ctx.find(view_context, pos) &&
						(ctx[pos]->vcx_type == VCT_TABLE || ctx[pos]->vcx_type == VCT_VIEW))
					{
						field->fld_source_rel_field = QualifiedNameMetaNamePair(ctx[pos]->vcx_relation_name, (TEXT*) p);
					}
				}

				break;

			case RSR_computed_blr:
				{
					AutoSetRestoreFlag<USHORT> flag(&field->fld_flags, FLD_parse_computed, true);

					DmlNode* nod = dependencies ?
						MET_get_dependencies(tdbb, this, p, length, csb, NULL, NULL, NULL,
							QualifiedName(field->fld_name, getName().schema), obj_computed,
							csb_computed_field, trans) :
						PAR_blr(tdbb, &getName().schema, rel_perm, p, length, csb, NULL, NULL,
							false, csb_computed_field);

					field->fld_computation = static_cast<ValueExprNode*>(nod);
				}
				break;

			case RSR_missing_value:
				field->fld_missing_value = static_cast<ValueExprNode*>(
					PAR_blr(tdbb, &getName().schema, rel_perm, p, length, csb, NULL, NULL, false, 0));
				break;

			case RSR_default_value:
				field->fld_default_value = static_cast<ValueExprNode*>(
					PAR_blr(tdbb, &getName().schema, rel_perm, p, length, csb, NULL, NULL, false, 0));
				break;

			case RSR_validation_blr:
				// AB: 2005-04-25   bug SF#1168898
				// Ignore validation for VIEWs, because fields (domains) which are
				// defined with CHECK constraints and have sub-selects should at least
				// be parsed without view-context information. With view-context
				// information the context-numbers are wrong.
				// Because a VIEW can't have a validation section i ignored the whole call.
				if (!csb)
				{
					field->fld_validation = PAR_validation_blr(tdbb, &getName().schema, rel_perm,
						p, length, csb, NULL, csb_validation);
				}
				break;

			case RSR_field_not_null:
				field->fld_not_null = PAR_validation_blr(tdbb, &getName().schema, rel_perm, p, length,
					csb, NULL, csb_validation);
				break;

			case RSR_security_class:
				field->fld_security_name = (const TEXT*) p;
				break;

			case RSR_trigger_name:
				if (!triggersLoaded)
				{
					MET_load_trigger(tdbb, this, QualifiedName((const TEXT*) p, REL.RDB$SCHEMA_NAME),
						[&](int t)->Triggers& {return rel_triggers[t];});
				}
				break;

			case RSR_dimensions:
				field->fld_array = array = FB_NEW_RPT(*rel_pool, n) ArrayField();
				array->arr_desc.iad_dimensions = n;
				break;

			case RSR_array_desc:
				if (array)
					memcpy(&array->arr_desc, p, length);
				break;

			case RSR_field_generator_name:
				field->fld_generator_name = QualifiedName((const TEXT*) p, REL.RDB$SCHEMA_NAME);
				if (!field->fld_identity_type.has_value())
					field->fld_identity_type = IDENT_TYPE_BY_DEFAULT;
				break;

			case RSR_field_identity_type:
				field->fld_identity_type = static_cast<IdentityType>(n);
				break;

			case RSR_field_length:
				field->fld_length = n;
				break;

			case RSR_segment_length:
				field->fld_segment_length = n;
				break;

			case RSR_field_pos:
				field->fld_pos = n;
				break;

			case RSR_character_length:
				field->fld_character_length = n;
				break;

			default:    // Shut up compiler warning
				break;
			}
		}
		blob->BLB_close(tdbb);
		blob = nullptr;

		if (field && field->fld_security_name.isEmpty() && !REL.RDB$DEFAULT_CLASS.NULL)
			field->fld_security_name = REL.RDB$DEFAULT_CLASS;
	}
	END_FOR

	delete csb;

	rel_current_format = MET_format(tdbb, rel_perm, rel_current_fmt);
	dependencies = false;

	if (rel_fields)
		rel_fields->trimNulls();

	return found ? ScanResult::COMPLETE : ScanResult::MISS;
}


void MET_trigger_msg(thread_db* tdbb, string& msg, const QualifiedName& name, USHORT number)
{
/**************************************
 *
 *      M E T _ t r i g g e r _ m s g
 *
 **************************************
 *
 * Functional description
 *      Look up trigger message using trigger and abort code.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	AutoCacheRequest request(tdbb, irq_s_msgs, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		MSG IN RDB$TRIGGER_MESSAGES
		WITH MSG.RDB$SCHEMA_NAME EQ name.schema.c_str() AND
			 MSG.RDB$TRIGGER_NAME EQ name.object.c_str() AND
			 MSG.RDB$MESSAGE_NUMBER EQ number
	{
		msg = MSG.RDB$MESSAGE;
	}
	END_FOR

	msg.rtrim();
}


void MET_update_shadow(thread_db* tdbb, Shadow* shadow, USHORT file_flags)
{
/**************************************
 *
 *      M E T _ u p d a t e _ s h a d o w
 *
 **************************************
 *
 * Functional description
 *      Update the stored file flags for the specified shadow.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	AutoRequest handle;

	FOR(REQUEST_HANDLE handle)
		FIL IN RDB$FILES WITH FIL.RDB$SHADOW_NUMBER EQ shadow->sdw_number
	{
		MODIFY FIL USING
			FIL.RDB$FILE_FLAGS = file_flags;
		END_MODIFY
	}
	END_FOR
}


void MET_update_transaction(thread_db* tdbb, jrd_tra* transaction, const bool do_commit)
{
/**************************************
 *
 *      M E T _ u p d a t e _ t r a n s a c t i o n
 *
 **************************************
 *
 * Functional description
 *      Update a record in RDB$TRANSACTIONS.  If do_commit is true, this is a
 *      commit; otherwise it is a ROLLBACK.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	AutoCacheRequest request(tdbb, irq_m_trans, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		X IN RDB$TRANSACTIONS
		WITH X.RDB$TRANSACTION_ID EQ transaction->tra_number
	{
		if (do_commit && (transaction->tra_flags & TRA_prepare2))
			ERASE X
		else
		{
			MODIFY X
				X.RDB$TRANSACTION_STATE = do_commit ?
					RDB$TRANSACTIONS.RDB$TRANSACTION_STATE.COMMITTED :
					RDB$TRANSACTIONS.RDB$TRANSACTION_STATE.ROLLED_BACK;
			END_MODIFY
		}
	}
	END_FOR
}


static int blocking_ast_dsql_cache(void* ast_object)
{
/**************************************
 *
 *	b l o c k i n g _ a s t _ d s q l _ c a c h e
 *
 **************************************
 *
 * Functional description
 *	Someone is trying to drop an item from the DSQL cache.
 *	Mark the symbol as obsolete and release the lock.
 *
 **************************************/
	DSqlCacheItem* const item = static_cast<DSqlCacheItem*>(ast_object);

	try
	{
		Database* const dbb = item->lock->lck_dbb;

		AsyncContextHolder tdbb(dbb, FB_FUNCTION, item->lock);

		LeftPooledMap<QualifiedName, bool>::Accessor accessor(&item->obsoleteMap);
		for (bool found = accessor.getFirst(); found; found = accessor.getNext())
			accessor.current()->second = true;

		item->locked = false;
		LCK_release(tdbb, item->lock);
	}
	catch (const Exception&)
	{} // no-op

	return 0;
}


DSqlCacheItem* MetadataCache::get_dsql_cache_item(thread_db* tdbb, sym_type type, const QualifiedName& name)
{
	Database* dbb = tdbb->getDatabase();
	Attachment* attachment = tdbb->getAttachment();
	MetadataCache* mdc = MetadataCache::get(tdbb);

	fb_assert((int) type <= MAX_UCHAR);
	UCHAR ucharType = (UCHAR) type;

	string key("0");	// name (not hash)
	key.append((char*) &ucharType, 1);

	USHORT len = (USHORT) name.object.length();
	key.append((char*) &len, sizeof(len));
	key.append(name.object.c_str(), len);

	len = (USHORT) name.package.length();
	key.append((char*) &len, sizeof(len));
	key.append(name.package.c_str(), len);

	len = (USHORT) name.schema.length();
	key.append((char*) &len, sizeof(len));
	key.append(name.schema.c_str(), len);

	if (key.length() > MAX_UCHAR)
	{
		FB_SIZE_T hash = DefaultHash<char>::hash(key.c_str(), key.length(), sizeof(FB_SIZE_T));
		key = "1";	// hash
		key.append((char*) &ucharType, 1);
		key.append((char*) &hash, sizeof(hash));
	}

	DSqlCacheItem* item = attachment->att_dsql_cache.put(key);
	if (item)
	{
		item->key = key;
		item->lock = FB_NEW_RPT(mdc->getPool(), key.length())
			Lock(tdbb, key.length(), LCK_dsql_cache, item, blocking_ast_dsql_cache);
		memcpy(item->lock->getKeyPtr(), key.c_str(), key.length());
	}
	else
		item = attachment->att_dsql_cache.get(key);

	return item;
}


static ULONG get_rel_flags_from_FLAGS(USHORT flags)
{
/**************************************
 *
 *      g e t _ r e l _ f l a g s _ f r o m _ F L A G S
 *
 **************************************
 *
 * Functional description
 *      Get rel_flags from RDB$FLAGS
 *
 **************************************/
	ULONG ret = 0;

	if (flags & REL_sql) {
		ret |= REL_sql_relation;
	}

	return ret;
}


ULONG MET_get_rel_flags_from_TYPE(USHORT type)
{
/**************************************
 *
 *      M E T _g e t _ r e l _ f l a g s _ f r o m _ T Y P E
 *
 **************************************
 *
 * Functional description
 *      Get rel_flags from RDB$RELATION_TYPE
 *
 **************************************/
	ULONG ret = 0;

	switch (type)
	{
		case rel_persistent:
			break;
		case rel_external:
			break;
		case rel_view:
			ret |= REL_jrd_view;
			break;
		case rel_virtual:
			ret |= REL_virtual;
			break;
		case rel_temp_preserve:
			ret |= REL_temp_conn | REL_temp_gtt;
			break;
		case rel_temp_delete:
			ret |= REL_temp_tran | REL_temp_gtt;
			break;
		default:
			fb_assert(false);
	}

	return ret;
}


static void get_trigger(thread_db* tdbb, jrd_rel* relation,
						bid* blob_id, bid* debug_blob_id, Triggers& triggers,
						const QualifiedName& name, FB_UINT64 type, SSHORT sysTrigger,
						USHORT flags, const MetaName& engine, const string& entryPoint,
						const bid* body, TriState ssDefiner)
{
/**************************************
 *
 *      g e t _ t r i g g e r
 *
 **************************************
 *
 * Functional description
 *      Get trigger.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	if (blob_id->isEmpty() && (engine.isEmpty() || entryPoint.isEmpty()))
		return;

	blb* blrBlob = NULL;
	blb* debugInfoBlob = NULL;

	if (!blob_id->isEmpty())
		blrBlob = blb::open(tdbb, attachment->getMetaTransaction(tdbb), blob_id);

	if (!debug_blob_id->isEmpty())
		debugInfoBlob = blb::open(tdbb, attachment->getMetaTransaction(tdbb), debug_blob_id);

	save_trigger_data(tdbb, triggers, relation, NULL, blrBlob, debugInfoBlob,
					  &name, type, (fb_sysflag)sysTrigger, flags, engine, entryPoint, body, ssDefiner);
}


static bool get_type(thread_db* tdbb, USHORT* id, const MetaName& name, const TEXT* field)
{
/**************************************
 *
 *      g e t _ t y p e
 *
 **************************************
 *
 * Functional description
 *      Resoved a symbolic name in RDB$TYPES.  Returned the value
 *      defined for the name in (*id).  Don't touch (*id) if you
 *      don't find the name.
 *
 *      Return (1) if found, (0) otherwise.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	fb_assert(id);
	fb_assert(field);

	bool found = false;

	AutoRequest handle;

	FOR(REQUEST_HANDLE handle)
		FIRST 1 T IN RDB$TYPES WITH
			T.RDB$FIELD_NAME EQ field AND
			T.RDB$TYPE_NAME EQ name.c_str()
	{
		found = true;
		*id = T.RDB$TYPE;
	}
	END_FOR

	return found;
}


static void lookup_view_contexts( thread_db* tdbb, jrd_rel* view)
{
/**************************************
 *
 *      l o o k u p _ v i e w _ c o n t e x t s
 *
 **************************************
 *
 * Functional description
 *      Lookup view contexts and store in a sorted
 *      array on the relation block.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	Database* dbb = tdbb->getDatabase();
	AutoCacheRequest request(tdbb, irq_view_context, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		V IN RDB$VIEW_RELATIONS
		WITH V.RDB$SCHEMA_NAME EQ view->getName().schema.c_str() AND
			 V.RDB$VIEW_NAME EQ view->getName().object.c_str()
		SORTED BY V.RDB$VIEW_CONTEXT
	{
		// trim trailing spaces
		fb_utils::exact_name_limit(V.RDB$CONTEXT_NAME, sizeof(V.RDB$CONTEXT_NAME));

		ViewContext* view_context = FB_NEW_POOL(*view->rel_pool)
			ViewContext(*view->rel_pool,
				V.RDB$CONTEXT_NAME,
				QualifiedName(V.RDB$RELATION_NAME, V.RDB$RELATION_SCHEMA_NAME),
				V.RDB$VIEW_CONTEXT,
				(V.RDB$CONTEXT_TYPE.NULL ? VCT_TABLE : ViewContextType(V.RDB$CONTEXT_TYPE)));

		view->rel_view_contexts.add(view_context);
	}
	END_FOR
}


static void make_relation_scope_name(const QualifiedName& rel_name, const USHORT rel_flags,
	string& str)
{
/**************************************
 *
 *	m a k e _ r e l a t i o n _ s c o p e _ n a m e
 *
 **************************************
 *
 * Functional description
 *	Make string with relation name and type
 *	of its temporary scope
 *
 **************************************/
	const char *scope = NULL;
	if (rel_flags & REL_temp_conn)
		scope = REL_SCOPE_GTT_PRESERVE;
	else if (rel_flags & REL_temp_tran)
		scope = REL_SCOPE_GTT_DELETE;
	else
		scope = REL_SCOPE_PERSISTENT;

	str.printf(scope, rel_name.toQuotedString().c_str());
}


// Parses default BLR for a field.
static ValueExprNode* parse_field_default_blr(thread_db* tdbb, const MetaName& schema, bid* blob_id)
{
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	MemoryPool& pool = *tdbb->getDefaultPool();
	AutoPtr<CompilerScratch> auto_csb(FB_NEW_POOL(pool) CompilerScratch(pool));
	CompilerScratch* csb = auto_csb;

	blb* blob = blb::open(tdbb, attachment->getSysTransaction(), blob_id);
	ULONG length = blob->blb_length + 10;
	HalfStaticArray<UCHAR, 512> temp;

	length = blob->BLB_get_data(tdbb, temp.getBuffer(length), length);

	DmlNode* const node = PAR_blr(tdbb, &schema, nullptr, temp.begin(), length, NULL, &csb, NULL, false, 0);
	return static_cast<ValueExprNode*>(node);
}


// Parses validation BLR for a field.
static BoolExprNode* parse_field_validation_blr(thread_db* tdbb, bid* blob_id, const QualifiedName& name)
{
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	MemoryPool& pool = *tdbb->getDefaultPool();
	AutoPtr<CompilerScratch> auto_csb(FB_NEW_POOL(pool) CompilerScratch(pool));
	CompilerScratch* csb = auto_csb;

	csb->csb_domain_validation = name;

	blb* blob = blb::open(tdbb, attachment->getSysTransaction(), blob_id);
	ULONG length = blob->blb_length + 10;
	HalfStaticArray<UCHAR, 512> temp;

	length = blob->BLB_get_data(tdbb, temp.getBuffer(length), length);

	return PAR_validation_blr(tdbb, &name.schema, nullptr, temp.begin(), length, NULL, &csb, 0);
}


bool MetadataCache::resolve_charset_and_collation(thread_db* tdbb,
												  TTypeId* id,
												  const QualifiedName& charset,
												  const QualifiedName& collation)
{
/**************************************
 *
 *      r e s o l v e _ c h a r s e t _ a n d _ c o l l a t i o n
 *
 **************************************
 *
 * Functional description
 *      Given ASCII7 name of charset & collation
 *      resolve the specification to a Character set id.
 *      This character set id is also the id of the text_object
 *      that implements the C locale for the Character set.
 *
 * Inputs:
 *      (charset)
 *              ASCII7z name of character set.
 *              NULL (implying unspecified) means use the character set
 *              for defined for (collation).
 *
 *      (collation)
 *              ASCII7z name of collation.
 *              NULL means use the default collation for (charset).
 *
 * Outputs:
 *      (*id)
 *              Set to character set specified by this name (low byte)
 *              Set to collation specified by this name (high byte).
 *
 * Return:
 *      true if no errors (and *id is set).
 *      false if either name not found.
 *        or if names found, but the collation isn't for the specified
 *        character set.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	auto charSetName = charset;
	auto collationName = collation;

	fb_assert(id);

	AutoRequest handle;

	if (charSetName.isEmpty() && collationName.isEmpty())
		charSetName = QualifiedName(DEFAULT_CHARACTER_SET_NAME, SYSTEM_SCHEMA);

	if (charSetName.hasData())
	{
		auto* mdc = MetadataCache::get(tdbb);
		auto* cs = mdc->mdc_charsets.lookup(tdbb,
			[charSetName](CharSetContainer* csc)
			{
				return csc->names.exist(charSetName);
			},
			CacheFlag::AUTOCREATE
		);
		if (!cs)
			return false;

		if (collationName.isEmpty())
		{
			*id = TTypeId(cs->getId());
			return true;
		}

		auto* csVer = cs->getVersioned(tdbb, CacheFlag::AUTOCREATE);
		Collation* coll = csVer->getCollation(collationName);
		if (!coll)
			return false;

		*id = coll->getType();		//TTypeId(cs->getId(), CollId(COL.RDB$COLLATION_ID));
		return true;
	}

	fb_assert(collationName.hasData() && charSetName.isEmpty());

	bool found = false;

	FOR(REQUEST_HANDLE handle)
		FIRST 1 COL IN RDB$COLLATIONS
		WITH COL.RDB$SCHEMA_NAME EQ collationName.schema.c_str() AND
			 COL.RDB$COLLATION_NAME EQ collationName.object.c_str()
	{
		found = true;
		*id = TTypeId(CSetId(COL.RDB$CHARACTER_SET_ID), CollId(COL.RDB$COLLATION_ID));
	}
	END_FOR

	return found;
}


ScanResult CharSetVers::scan(thread_db* tdbb, ObjectBase::Flag flags)
{
	fb_assert(perm->hasData());

	Attachment* attachment = tdbb->getAttachment();

	AutoRequest handle, handle2;

	if (perm->names.getCount() == 0)
	{
		perm->names.push(getName());

		FOR(REQUEST_HANDLE handle)
			T IN RDB$TYPES
			WITH T.RDB$FIELD_NAME EQ "RDB$CHARACTER_SET_NAME"
			 AND T.RDB$TYPE EQ getId()
		{
			QualifiedName aliasName(T.RDB$TYPE_NAME, SYSTEM_SCHEMA);
			if (getName() != aliasName)
				perm->names.push(aliasName);
		}
		END_FOR
	}

	FOR(REQUEST_HANDLE handle2)
		CS IN RDB$CHARACTER_SETS
			CROSS COL IN RDB$COLLATIONS OVER RDB$CHARACTER_SET_ID
		WITH CS.RDB$CHARACTER_SET_ID EQ getId()
	{
		fb_assert(perm->names.exist(QualifiedName(CS.RDB$CHARACTER_SET_NAME, CS.RDB$SCHEMA_NAME)));

		SubtypeInfo info;
		info.charsetName = perm->names;
		info.collationName = QualifiedName(COL.RDB$COLLATION_NAME, COL.RDB$SCHEMA_NAME);
		info.attributes = (USHORT)COL.RDB$COLLATION_ATTRIBUTES;
		info.ignoreAttributes = COL.RDB$COLLATION_ATTRIBUTES.NULL;

		if (COL.RDB$BASE_COLLATION_NAME.NULL)
			info.baseCollationName = info.collationName.object.c_str();
		else
			info.baseCollationName = COL.RDB$BASE_COLLATION_NAME;

		CharSet* charset = perm->getCharSet();
		CollId colId(COL.RDB$COLLATION_ID);
		CSetId id(getId());

		if (COL.RDB$SPECIFIC_ATTRIBUTES.NULL)
			info.specificAttributes.clear();
		else
		{
			blb* blob = blb::open(tdbb, attachment->getSysTransaction(), &COL.RDB$SPECIFIC_ATTRIBUTES);
			const ULONG length = blob->blb_length;

			// ASF: Here info.specificAttributes is in UNICODE_FSS charset.
			blob->BLB_get_data(tdbb, info.specificAttributes.getBuffer(length), length);

			if (id != CS_METADATA)
			{
				Firebird::UCharBuffer specificAttributes;
				ULONG size = info.specificAttributes.getCount() * charset->maxBytesPerChar();

				size = INTL_convert_bytes(tdbb, id,
									  specificAttributes.getBuffer(size), size,
									  CS_METADATA, info.specificAttributes.begin(),
									  info.specificAttributes.getCount(), ERR_post);
				specificAttributes.shrink(size);
				info.specificAttributes = specificAttributes;
			}
		}

		AutoPtr<texttype> tt = FB_NEW_POOL(perm->getPool()) texttype;
		memset(tt, 0, sizeof(texttype));
		INTL_lookup_texttype(tt, &info);

		if (charset_collations.getCount() <= colId)
			charset_collations.grow(colId + 1);

		fb_assert((tt->texttype_canonical_width == 0 && tt->texttype_fn_canonical == NULL) ||
				  (tt->texttype_canonical_width != 0 && tt->texttype_fn_canonical != NULL));

		if (tt->texttype_canonical_width == 0)
		{
			if (charset->isMultiByte())
				tt->texttype_canonical_width = sizeof(ULONG);	// UTF-32
			else
			{
				tt->texttype_canonical_width = charset->minBytesPerChar();
				// canonical is equal to string, then TEXTTYPE_DIRECT_MATCH can be turned on
				tt->texttype_flags |= TEXTTYPE_DIRECT_MATCH;
			}
		}

		Collation* collation = Collation::createInstance(perm->getPool(),
			TTypeId(id, colId), tt, info.attributes, charset);
		collation->name = info.collationName;

		tt.release();
		charset_collations[colId] = collation;
	}
	END_FOR

	return ScanResult::COMPLETE;
}


static void save_trigger_data(thread_db* tdbb, Triggers& vector, jrd_rel* relation,
							  Statement* statement, blb* blrBlob, blb* debugInfoBlob,
							  const QualifiedName* name, FB_UINT64 type, fb_sysflag sysTrigger,
							  USHORT flags, const MetaName& engine, const string& entryPoint,
							  const bid* body, TriState ssDefiner)
{
/**************************************
 *
 *      s a v e _ t r i g g e r _ d a t a
 *
 **************************************
 *
 * Functional description
 *      Save trigger data to passed vector
 *
 **************************************/
	Attachment* attachment = tdbb->getAttachment();
	Database* database = tdbb->getDatabase();
	MemoryPool& pool(*(relation ? relation->rel_pool : database->dbb_permanent));

	Trigger* t = FB_NEW_POOL(pool) Trigger(pool);

	if (blrBlob)
	{
		const ULONG length = blrBlob->blb_length + 10;
		UCHAR* const data = t->blr.getBuffer(length);
		t->blr.resize(blrBlob->BLB_get_data(tdbb, data, length));
	}

	if (debugInfoBlob)
	{
		const ULONG length = debugInfoBlob->blb_length + 10;
		UCHAR* const data = t->debugInfo.getBuffer(length);
		t->debugInfo.resize(debugInfoBlob->BLB_get_data(tdbb, data, length));
	}

	if (name)
		t->name = *name;

	if (body)
	{
		blb* bodyBlob = blb::open(tdbb, attachment->getMetaTransaction(tdbb), body);

		HalfStaticArray<char, 512> temp;
		ULONG length = bodyBlob->BLB_get_data(tdbb, (UCHAR*) temp.getBuffer(bodyBlob->blb_length),
			bodyBlob->blb_length);

		t->extBody.assign(temp.begin(), length);
	}

	t->type = type;
	t->flags = flags;
	t->statement = statement;
	t->relation = relation;			// trigger can't exist longer than relation
	t->engine = engine;
	t->entryPoint = entryPoint;
	t->ssDefiner = ssDefiner;
	t->sysTrigger = sysTrigger;
	t->owner = relation ? relation->getOwnerName() : tdbb->getDatabase()->dbb_owner;

	vector.addTrigger(tdbb, t);
}


void RelationPermanent::scanPartners(thread_db* tdbb)
{
/**************************************
 *
 *      s c a n _ p a r t n e r s
 *
 **************************************
 *
 * Functional description
 *      Scan of foreign references on other relations' primary keys and
 *      scan of primary dependencies on relation's primary key.
 *
 **************************************/
	if (rel_flags & REL_temp_ltt)
		return;

	Attachment* attachment = tdbb->getAttachment();

	if (rel_flags & REL_check_partners)
	{
		LCK_lock(tdbb, rel_partners_lock, LCK_SR, LCK_WAIT);

		// Prepare for rescan of foreign dependencies on relation.

		AutoCacheRequest request(tdbb, irq_foreign1, IRQ_REQUESTS);
		int index_number = 0;

		if (rel_foreign_refs)
		{
			delete rel_foreign_refs;
			rel_foreign_refs = NULL;
		}

		FOR(REQUEST_HANDLE request)
			IDX IN RDB$INDICES CROSS
			RC IN RDB$RELATION_CONSTRAINTS
			OVER RDB$SCHEMA_NAME, RDB$INDEX_NAME CROSS
			IND IN RDB$INDICES WITH
			RC.RDB$CONSTRAINT_TYPE EQ FOREIGN_KEY AND
			IDX.RDB$SCHEMA_NAME EQ getName().schema.c_str() AND
			IDX.RDB$RELATION_NAME EQ getName().object.c_str() AND
			IND.RDB$SCHEMA_NAME EQ IDX.RDB$FOREIGN_KEY_SCHEMA_NAME AND
			IND.RDB$INDEX_NAME EQ IDX.RDB$FOREIGN_KEY AND
			IDX.RDB$INDEX_ID > 0 AND
			IND.RDB$INDEX_ID > 0 AND
			IND.RDB$UNIQUE_FLAG = 1
		{
			const QualifiedName partnerRelationName(IND.RDB$RELATION_NAME, IND.RDB$SCHEMA_NAME);

			//// ASF: Hack fix for CORE-4304, until nasty interactions between dfw and met are not resolved.
			const auto* partner_relation = getName() == partnerRelationName ?
				this : MetadataCache::getPerm<Cached::Relation>(tdbb, partnerRelationName, CacheFlag::AUTOCREATE);

			if (partner_relation &&
				MetadataCache::getIndexActive(IDX.RDB$INDEX_INACTIVE.NULL, IDX.RDB$INDEX_INACTIVE) &&
				MetadataCache::getIndexActive(IND.RDB$INDEX_INACTIVE.NULL, IND.RDB$INDEX_INACTIVE))
			{
				dep deps;
				deps.dep_reference_id = IDX.RDB$INDEX_ID - 1;
				deps.dep_relation = partner_relation->getId();
				deps.dep_index = IND.RDB$INDEX_ID - 1;

				if (!rel_foreign_refs)
					rel_foreign_refs = FB_NEW_POOL(getPool()) ForeignRefs(getPool());

				rel_foreign_refs->push(deps);
			}
		}
		END_FOR

		// Prepare for rescan of primary dependencies on relation's primary key and stale vectors.

		request.reset(tdbb, irq_foreign2, IRQ_REQUESTS);
		if (rel_primary_dpnds)
		{
			delete rel_primary_dpnds;
			rel_primary_dpnds = NULL;
		}

		FOR(REQUEST_HANDLE request)
			IDX IN RDB$INDICES CROSS
			IND IN RDB$INDICES WITH
			IDX.RDB$UNIQUE_FLAG = 1 AND
			IDX.RDB$INDEX_ID > 0 AND
			IND.RDB$INDEX_ID > 0 AND
			IDX.RDB$SCHEMA_NAME EQ getName().schema.c_str() AND
			IDX.RDB$RELATION_NAME EQ getName().object.c_str() AND
			IND.RDB$FOREIGN_KEY_SCHEMA_NAME EQ IDX.RDB$SCHEMA_NAME AND
			IND.RDB$FOREIGN_KEY EQ IDX.RDB$INDEX_NAME
		{
			const QualifiedName partnerRelationName(IND.RDB$RELATION_NAME, IND.RDB$SCHEMA_NAME);

			//// ASF: Hack fix for CORE-4304, until nasty interactions between dfw and met are not resolved.
			const auto* partner_relation = getName() == partnerRelationName ?
				this : MetadataCache::getPerm<Cached::Relation>(tdbb, partnerRelationName, CacheFlag::AUTOCREATE);

			if (partner_relation &&
				MetadataCache::getIndexActive(IDX.RDB$INDEX_INACTIVE.NULL, IDX.RDB$INDEX_INACTIVE) &&
				MetadataCache::getIndexActive(IND.RDB$INDEX_INACTIVE.NULL, IND.RDB$INDEX_INACTIVE))
			{
				dep deps;
				deps.dep_reference_id = IDX.RDB$INDEX_ID - 1;
				deps.dep_relation = partner_relation->getId();
				deps.dep_index = IND.RDB$INDEX_ID - 1;

				if (!rel_primary_dpnds)
					rel_primary_dpnds = FB_NEW_POOL(getPool()) PrimaryDeps(getPool());

				rel_primary_dpnds->push(deps);
			}
		}
		END_FOR

		rel_flags &= ~REL_check_partners;
	}
}


void MET_store_dependencies(thread_db* tdbb,
							Array<Dependency>& dependencies,
							const jrd_rel* dep_rel,
							const QualifiedName& object_name,
							int dependency_type,
							jrd_tra* transaction)
{
/**************************************
 *
 *      s t o r e _ d e p e n d e n c i e s
 *
 **************************************
 *
 * Functional description
 *      Store records in RDB$DEPENDENCIES
 *      corresponding to the objects found during
 *      compilation of blr for a trigger, view, etc.
 *
 **************************************/
	QualifiedName name;

	SET_TDBB(tdbb);

	fb_assert(!dep_rel || !(dep_rel->getPermanent()->rel_flags & REL_temp_ltt));

	const Trigger* t = nullptr;
	const bool checkTableScope =
		(dependency_type == obj_computed) ||
		(dependency_type == obj_trigger) && dep_rel && (t = dep_rel->findTrigger(object_name)) && (t->sysTrigger);

	while (dependencies.hasData())
	{
		Dependency dependency = dependencies.pop();

		if (!dependency.relation && !dependency.function && !dependency.procedure &&
			!dependency.name && !dependency.number)
		{
			continue;
		}

		int dpdo_type = dependency.objType;
		Cached::Relation* relation = nullptr;
		Cached::Procedure* procedure = nullptr;
		const QualifiedName* dpdo_name = NULL;
		SubtypeInfo info;

		switch (dpdo_type)
		{
		case obj_relation:
		case obj_view:
			relation = dependency.relation;
			dpdo_name = &relation->getName();

			fb_assert(dep_rel || !checkTableScope);

			if (checkTableScope &&
				( (dep_rel->getPermanent()->rel_flags & (REL_temp_tran | REL_temp_conn)) !=
				  (relation->rel_flags & (REL_temp_tran | REL_temp_conn)) ))
			{
				if ( !( // master is ON COMMIT PRESERVE, detail is ON COMMIT DELETE
						(dep_rel->getPermanent()->rel_flags & REL_temp_tran) && (relation->rel_flags & REL_temp_conn) ||
						// computed field of a view
						(dependency_type == obj_computed) && dep_rel->isView()
					   ))
				{
					string sMaster, sChild;

					make_relation_scope_name(relation->getName(), relation->rel_flags, sMaster);
					make_relation_scope_name(dep_rel->getName(), dep_rel->getPermanent()->rel_flags, sChild);

					ERR_post(Arg::Gds(isc_no_meta_update) <<
							 Arg::Gds(isc_met_wrong_gtt_scope) << Arg::Str(sChild) <<
																  Arg::Str(sMaster));
				}
			}

			if (relation->isView())
				dpdo_type = obj_view;
			break;

		case obj_procedure:
			procedure = dependency.procedure;
			dpdo_name = &procedure->getName();
			break;

		case obj_collation:
			{
				const USHORT number = dependency.number;
				MET_get_char_coll_subtype_info(tdbb, number, &info);
				dpdo_name = &info.collationName;
			}
			break;

		case obj_exception:
			{
				const SLONG number = dependency.number;
				MET_lookup_exception(tdbb, number, name, NULL);
				dpdo_name = &name;
			}
			break;

		case obj_field:
			dpdo_name = dependency.name;
			break;

		case obj_generator:
			{
				// CVC: Here I'm going to track those pesky things named generators and UDFs.
				// But don't track sys gens.
				bool sysGen = false;
				const SLONG number = dependency.number;
				if (number == 0 || !MET_lookup_generator_id(tdbb, number, name, &sysGen) || sysGen)
					continue;
				dpdo_name = &name;
			}
			break;

		case obj_udf:
			dpdo_name = &dependency.function->getName();
			break;

		case obj_index:
			name = *dependency.name;
			dpdo_name = &name;
			break;
		}

		MetaName field_name;

		if (dependency.subNumber || dependency.subName)
		{
			if (dependency.subNumber)
			{
				const SSHORT fld_id = (SSHORT) dependency.subNumber;
				if (relation)
				{
					const jrd_fld* field = MET_get_field(relation->getVersioned(tdbb, CacheFlag::AUTOCREATE), fld_id);
					if (field)
						field_name = field->fld_name;
				}
				else if (procedure)
				{
					const Parameter* param = procedure->getVersioned(tdbb, CacheFlag::AUTOCREATE)->getOutputFields()[fld_id];
					// CVC: Setting the field var here didn't make sense alone,
					// so I thought the missing code was to try to extract
					// the field name that's in this case an output var from a proc.
					if (param)
						field_name = param->prm_name;
				}
			}
			else
				field_name = *dependency.subName;
		}

		if (field_name.hasData())
		{
			AutoCacheRequest request(tdbb, irq_c_deps_f, IRQ_REQUESTS);
			bool found = false;
			fb_assert(dpdo_name);

			FOR(REQUEST_HANDLE request TRANSACTION_HANDLE transaction)
				X IN RDB$DEPENDENCIES
				WITH X.RDB$DEPENDENT_SCHEMA_NAME = NULLIF(object_name.schema.c_str(), '') AND
					 X.RDB$DEPENDENT_NAME = object_name.object.c_str() AND
					 X.RDB$DEPENDED_ON_SCHEMA_NAME = NULLIF(dpdo_name->schema.c_str(), '') AND
					 X.RDB$DEPENDED_ON_NAME = dpdo_name->object.c_str() AND
					 X.RDB$DEPENDED_ON_TYPE = dpdo_type AND
					 X.RDB$FIELD_NAME = field_name.c_str() AND
					 X.RDB$DEPENDENT_TYPE = dependency_type
			{
				found = true;
			}
			END_FOR

			if (found)
				continue;
		}
		else
		{
			AutoCacheRequest request(tdbb, irq_c_deps, IRQ_REQUESTS);
			bool found = false;

			FOR(REQUEST_HANDLE request TRANSACTION_HANDLE transaction)
				X IN RDB$DEPENDENCIES
				WITH X.RDB$DEPENDENT_SCHEMA_NAME = NULLIF(object_name.schema.c_str(), '') AND
					 X.RDB$DEPENDENT_NAME = object_name.object.c_str() AND
					 X.RDB$DEPENDED_ON_SCHEMA_NAME = NULLIF(dpdo_name->schema.c_str(), '') AND
					 X.RDB$DEPENDED_ON_NAME = dpdo_name->object.c_str() AND
					 X.RDB$DEPENDED_ON_TYPE = dpdo_type AND
					 X.RDB$FIELD_NAME MISSING AND
					 X.RDB$DEPENDENT_TYPE = dependency_type AND
					 X.RDB$PACKAGE_NAME EQUIV NULLIF(dpdo_name->package.c_str(), '')
			{
				found = true;
			}
			END_FOR

			if (found)
				continue;
		}

		AutoCacheRequest request(tdbb, irq_s_deps, IRQ_REQUESTS);

		fb_assert(dpdo_name);

		STORE(REQUEST_HANDLE request TRANSACTION_HANDLE tdbb->getTransaction()) DEP IN RDB$DEPENDENCIES
		{
			if (object_name.schema.hasData())
			{
				DEP.RDB$DEPENDENT_SCHEMA_NAME.NULL = FALSE;
				strcpy(DEP.RDB$DEPENDENT_SCHEMA_NAME, object_name.schema.c_str());
			}
			else
				DEP.RDB$DEPENDENT_SCHEMA_NAME.NULL = TRUE;

			strcpy(DEP.RDB$DEPENDENT_NAME, object_name.object.c_str());

			DEP.RDB$DEPENDED_ON_TYPE = dpdo_type;

			if (dpdo_name->schema.hasData())
			{
				DEP.RDB$DEPENDED_ON_SCHEMA_NAME.NULL = FALSE;
				strcpy(DEP.RDB$DEPENDED_ON_SCHEMA_NAME, dpdo_name->schema.c_str());
			}
			else
				DEP.RDB$DEPENDED_ON_SCHEMA_NAME.NULL = TRUE;

			strcpy(DEP.RDB$DEPENDED_ON_NAME, dpdo_name->object.c_str());

			if (field_name.hasData())
			{
				DEP.RDB$FIELD_NAME.NULL = FALSE;
				strcpy(DEP.RDB$FIELD_NAME, field_name.c_str());
			}
			else
				DEP.RDB$FIELD_NAME.NULL = TRUE;

			if (dpdo_name->package.hasData())
			{
				DEP.RDB$PACKAGE_NAME.NULL = FALSE;
				strcpy(DEP.RDB$PACKAGE_NAME, dpdo_name->package.c_str());
			}
			else
				DEP.RDB$PACKAGE_NAME.NULL = TRUE;

			DEP.RDB$DEPENDENT_TYPE = dependency_type;
		}
		END_STORE
	}
}


static bool verify_TRG_ignore_perm(thread_db* tdbb, const QualifiedName& trig_name)
{
/*****************************************************
 *
 *      v e r i f y _ T R G _ i g n o r e  _ p e r m
 *
 *****************************************************
 *
 * Functional description
 *      Return true if this trigger can go through without any permission
 *      checks. Currently, the only class of triggers that can go
 *      through without permission checks are
 *      (a) two system triggers (RDB$TRIGGERS_34 and RDB$TRIGGERS_35)
 *      (b) those defined for referential integrity actions such as,
 *      set null, set default, and cascade.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	// See if this is a RI trigger

	AutoCacheRequest request(tdbb, irq_c_trg_perm, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		CHK IN RDB$CHECK_CONSTRAINTS CROSS
			REF IN RDB$REF_CONSTRAINTS WITH
			CHK.RDB$SCHEMA_NAME EQ trig_name.schema.c_str() AND
			CHK.RDB$TRIGGER_NAME EQ trig_name.object.c_str() AND
			REF.RDB$SCHEMA_NAME = CHK.RDB$SCHEMA_NAME AND
			REF.RDB$CONSTRAINT_NAME = CHK.RDB$CONSTRAINT_NAME
	{
		fb_utils::exact_name_limit(REF.RDB$UPDATE_RULE, sizeof(REF.RDB$UPDATE_RULE));
		fb_utils::exact_name_limit(REF.RDB$DELETE_RULE, sizeof(REF.RDB$DELETE_RULE));

		if (!strcmp(REF.RDB$UPDATE_RULE, RI_ACTION_CASCADE) ||
			!strcmp(REF.RDB$UPDATE_RULE, RI_ACTION_NULL) ||
			!strcmp(REF.RDB$UPDATE_RULE, RI_ACTION_DEFAULT) ||
			!strcmp(REF.RDB$DELETE_RULE, RI_ACTION_CASCADE) ||
			!strcmp(REF.RDB$DELETE_RULE, RI_ACTION_NULL) ||
			!strcmp(REF.RDB$DELETE_RULE, RI_ACTION_DEFAULT))
		{
			return true;
		}

		return false;
	}
	END_FOR

	return false;
}

int MET_get_linger(thread_db* tdbb)
{
/**************************************
 *
 *	M E T _ g e t _ l i n g e r
 *
 **************************************
 *
 * Functional description
 *      Return linger value for current database
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	int rc = 0;

	AutoCacheRequest request(tdbb, irq_linger, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		DAT IN RDB$DATABASE
	{
		if (!DAT.RDB$LINGER.NULL)
			rc = DAT.RDB$LINGER;
	}
	END_FOR

	return rc;
}

TriState MET_get_ss_definer(Jrd::thread_db* tdbb, const MetaName& schemaName)
{
/**************************************
 *
 *	M E T _ s s _ d e f i n e r
 *
 **************************************
 *
 * Functional description
 *      Return sql security value for current database
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	TriState r;

	AutoCacheRequest request(tdbb, irq_dbb_ss_definer, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		SCH IN RDB$SCHEMAS
		CROSS DBB IN RDB$DATABASE
		WITH SCH.RDB$SCHEMA_NAME EQ schemaName.c_str()
	{
		if (!SCH.RDB$SQL_SECURITY.NULL)
			r = SCH.RDB$SQL_SECURITY;
		else if (!DBB.RDB$SQL_SECURITY.NULL)
			r = DBB.RDB$SQL_SECURITY;
	}
	END_FOR

	return r;
}

MetadataCache::~MetadataCache()
{
}

void MetadataCache::releaseGTTs(thread_db* tdbb)
{
	for (auto relation : mdc_relations)
	{
		if (relation && (relation->rel_flags & REL_temp_conn) &&
			!(relation->isDropped()))
		{
			relation->delPages(tdbb);
		}
	}
}

void MetadataCache::runDBTriggers(thread_db* tdbb, TriggerAction action)
{
	fb_assert(action == TRIGGER_CONNECT || action == TRIGGER_DISCONNECT);
	const MetaId trgKind = (action == TRIGGER_CONNECT) ? DB_TRIGGER_CONNECT : DB_TRIGGER_DISCONNECT;

	auto* element = mdc_triggers[trgKind].load(atomics::memory_order_relaxed);
	if (!element)
		return;

	auto *triggers = element->getVersioned(tdbb, CacheFlag::AUTOCREATE);
	if ((!triggers) || (!*triggers))
		return;

	ThreadStatusGuard temp_status(tdbb);
	jrd_tra* transaction = NULL;

	try
	{
		transaction = TRA_start(tdbb, 0, NULL);
		EXE_execute_db_triggers(tdbb, transaction, action);
		TRA_commit(tdbb, transaction, false);
		return;
	}
	catch (const Exception& /*ex*/)
	{
		Database* dbb = tdbb->getDatabase();
		if (!(dbb->dbb_flags & DBB_bugcheck) && transaction)
		{
			try
			{
				TRA_rollback(tdbb, transaction, false, false);
			}
			catch (const Exception& /*ex2*/)
			{
			}
		}
		throw;
	}
}

void MetadataCache::releaseRelations(thread_db* tdbb)
{
	// Shut down any extern relations

	for (auto relation : mdc_relations)
	{
		if (relation)
		{
			auto* ext = relation->getExtFile();
			if (ext)
				ext->release();
		}
	}
}

void MetadataCache::releaseLocks(thread_db* tdbb)
{
	// Go through relations and indices and release
	// all existence locks that might have been taken.

	for (auto relation : mdc_relations)
	{
		if (relation)
			relation->releaseLocks(tdbb);
	}

	// Release all procedure existence locks that might have been taken

	for (auto procedure : mdc_procedures)
	{
		if (procedure)
			procedure->releaseLocks(tdbb);
	}

	// Release all function existence locks that might have been taken

	for (auto function : mdc_functions)
	{
		if (function)
			function->releaseLocks(tdbb);
	}

	// Release charset locks

	for (auto charset : mdc_charsets)
	{
		if (charset)
			charset->releaseLocks(tdbb);
	}

	// Release database triggers locks

	for (unsigned i = 0; i < DB_TRIGGERS_COUNT; ++i)
	{
		auto* ptr = mdc_triggers[i].load(atomics::memory_order_relaxed);
		if (ptr)
			ptr->releaseLocks(tdbb);
	}
}

void MetadataCache::invalidateReplSet(thread_db* tdbb)
{
	for (auto relation : mdc_relations)
	{
		if (relation)
			relation->rel_repl_state.reset();
	}
}

Cached::Triggers* MetadataCache::getTriggersSet(thread_db* tdbb, MetaId triggerId)
{
	if ((triggerId & TRIGGER_TYPE_MASK) == TRIGGER_TYPE_DB)
	{
		triggerId &= ~TRIGGER_TYPE_MASK;
		return mdc_triggers[triggerId].load(atomics::memory_order_acquire);
	}

	if ((triggerId & TRIGGER_TYPE_MASK) == TRIGGER_TYPE_DDL)
		return mdc_triggers[DB_TRIGGER_DDL].load(atomics::memory_order_acquire);

	return nullptr;
}

const Triggers* MetadataCache::getTriggers(thread_db* tdbb, MetaId triggerId)
{
	auto* tset = getTriggersSet(tdbb, triggerId);
	return tset ? tset->getVersioned(tdbb, CacheFlag::AUTOCREATE) : nullptr;
}

void Trigger::compile(thread_db* tdbb)
{
	if (extTrigger || statement)
		return;

	const auto dbb = tdbb->getDatabase();
	const auto att = tdbb->getAttachment();

	// Allocate statement memory pool
	MemoryPool* new_pool = dbb->createPool();

	// Trigger request is not compiled yet. Lets do it now
	USHORT par_flags = (USHORT) (flags & TRG_ignore_perm) ? csb_ignore_perm : 0;

	if (type & 1)
		par_flags |= csb_pre_trigger;
	else
		par_flags |= csb_post_trigger;

	try
	{
		Jrd::ContextPoolHolder context(tdbb, new_pool);

		AutoPtr<CompilerScratch> auto_csb(FB_NEW_POOL(*new_pool) CompilerScratch(*new_pool));
		CompilerScratch* csb = auto_csb;

		csb->csb_g_flags |= par_flags;

		if (engine.isEmpty())
		{
			TraceTrigCompile trace(tdbb, this);

			if (debugInfo.hasData())
			{
				DBG_parse_debug_info((ULONG) debugInfo.getCount(), debugInfo.begin(),
									 *csb->csb_dbg_info);
			}

			PAR_blr(tdbb, &name.schema, getPermanent(relation), blr.begin(), (ULONG) blr.getCount(), NULL,
					&csb, &statement, (relation ? true : false), par_flags);

			trace.finish(statement, ITracePlugin::RESULT_SUCCESS);
		}
		else
		{
			dbb->dbb_extManager->makeTrigger(tdbb, csb, this, engine, entryPoint, extBody.c_str(),
				(relation ?
					(type & 1 ? IExternalTrigger::TYPE_BEFORE : IExternalTrigger::TYPE_AFTER) :
					IExternalTrigger::TYPE_DATABASE));
		}
	}
	catch (const Exception&)
	{
		if (statement)
		{
			statement->release(tdbb);
			statement = NULL;
		}
		else
			dbb->deletePool(new_pool);

		throw;
	}

	statement->triggerName = name;

	if (ssDefiner.asBool())
		statement->triggerInvoker = dbb->getUserId(owner);

	if (sysTrigger != fb_sysflag_user)
		statement->flags |= Statement::FLAG_SYS_TRIGGER | Statement::FLAG_INTERNAL;

	if (flags & TRG_ignore_perm)
		statement->flags |= Statement::FLAG_IGNORE_PERM;
}

Cached::Relation* MetadataCache::lookupRelation(thread_db* tdbb, MetaId id)
{
	return mdc_relations.getData(tdbb, id, 0);
}

Cached::Relation* MetadataCache::lookupRelationNoChecks(MetaId id)
{
	return mdc_relations.getDataNoChecks(id);
}

Cached::Relation* MetadataCache::ensureRelation(thread_db* tdbb, MetaId id)
{
	MetadataCache* mdc = get(tdbb);
	return mdc->mdc_relations.ensurePermanent(tdbb, id);
}

MetadataCache* MetadataCache::getCache(thread_db* tdbb) noexcept
{
	return tdbb->getDatabase()->dbb_mdc;
}

int jrd_prc::objectType() noexcept
{
	return obj_procedure;
}

MetadataCache::CleanupQueue::CleanupQueue(MemoryPool& p)
	: cq_data(p)
{ }

void MetadataCache::CleanupQueue::enqueue(TraNumber traNum, ElementBase* toClean)
{
	MutexLockGuard g(cq_mutex, FB_FUNCTION);

	if (cq_data.getCount() == 0)
	{
		cq_traNum = traNum;
		fb_assert(cq_pos == 0);
	}
	cq_data.push(Stored(traNum, toClean));
}

void MetadataCache::CleanupQueue::dequeue(thread_db* tdbb, TraNumber oldest)
{
	MutexEnsureUnlock g(cq_mutex, FB_FUNCTION);

	if (!g.tryEnter())
		return;

	while (cq_pos < cq_data.getCount() && oldest > cq_data[cq_pos].t)
	{
		auto* c = cq_data[cq_pos++].c;
		c->releaseLocks(tdbb);
		c->cleanup(tdbb);
	}

	if (cq_data.getCount() <= cq_pos)
	{
		fb_assert(cq_data.getCount() == cq_pos);

		cq_data.clear();
		cq_pos = 0;
		cq_traNum = MAX_TRA_NUMBER;
	}
	else
	{
		if (cq_pos > cq_data.getCount() / 2)
		{
			cq_data.removeCount(0, cq_pos);
			cq_pos = 0;
		}
		cq_traNum = cq_data[cq_pos].t;
	}
}

void MetadataCache::objectCleanup(TraNumber traNum, ElementBase* toClean)
{
	mdc_cleanup_queue.enqueue(traNum, toClean);
}

ScanResult IndexVersion::scan(thread_db* tdbb, ObjectBase::Flag flags)
{
	SET_TDBB(tdbb);

	if (getPermanent()->getRelation()->rel_flags & REL_temp_ltt)
		return ScanResult::COMPLETE;

	Attachment* attachment = tdbb->getAttachment();
	Database* dbb = tdbb->getDatabase();
	jrd_tra* transaction = attachment->getMetaTransaction(tdbb);

	bid expression, condition;
	expression.clear();
	condition.clear();
	MetaId relId = getPermanent()->getRelation()->getId();
	bool found = false;

	Jrd::ContextPoolHolder context(tdbb, dbb->dbb_permanent);

	AutoCacheRequest handle(tdbb, irq_index_scan, IRQ_REQUESTS);
	FOR(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
		IND IN RDB$INDICES
		CROSS REL IN RDB$RELATIONS
			OVER RDB$RELATION_NAME, RDB$SCHEMA_NAME
		WITH IND.RDB$INDEX_ID EQ getId() + 1
			AND REL.RDB$RELATION_ID EQ relId
	{
		found = true;

		idv_name = QualifiedName(IND.RDB$INDEX_NAME, IND.RDB$SCHEMA_NAME);
		idv_uniqFlag = IND.RDB$UNIQUE_FLAG;
		idv_segmentCount = IND.RDB$SEGMENT_COUNT;
		idv_type = IND.RDB$INDEX_TYPE;
		idv_foreignKey = QualifiedName(IND.RDB$FOREIGN_KEY, IND.RDB$FOREIGN_KEY_SCHEMA_NAME);

		idv_active = MetadataCache::getIndexStatus(IND.RDB$INDEX_INACTIVE.NULL, IND.RDB$INDEX_INACTIVE);

		if (!IND.RDB$EXPRESSION_BLR.NULL)
			expression = IND.RDB$EXPRESSION_BLR;
		if (!IND.RDB$CONDITION_BLR.NULL)
			condition = IND.RDB$CONDITION_BLR;
	}
	END_FOR

	if (idv_name.isEmpty())
	{
		idv_active = MET_index_inactive;
		return ScanResult::MISS;
	}

	auto* relation = (expression.hasData() || condition.hasData()) ?
		MetadataCache::getPerm<Cached::Relation>(tdbb, relId, CacheFlag::AUTOCREATE) : nullptr;

	if (expression.hasData())
	{
		MemoryPool* stmtPool = dbb->createPool();
		try
		{
			Jrd::ContextPoolHolder context(tdbb, stmtPool);

			CompilerScratch* csb = nullptr;
			Cleanup cc([csb]() {delete csb;});
			MET_parse_blob(tdbb, &relation->getName().schema, relation, &expression, &csb, nullptr, false, false);
			idv_expression_statement = Statement::makeValueExpression(tdbb, idv_expression, idv_expression_desc, csb, false);
		}
		catch (const Exception&)
		{
			dbb->deletePool(stmtPool);
			throw;
		}
	}

	if (condition.hasData())
	{
		MemoryPool* stmtPool = dbb->createPool();
		try
		{
			Jrd::ContextPoolHolder context(tdbb, stmtPool);

			CompilerScratch* csb = nullptr;
			Cleanup cc([csb]() {delete csb;});
			MET_parse_blob(tdbb, &relation->getName().schema, relation, &condition, &csb, nullptr, false, false);
			idv_condition_statement = Statement::makeBoolExpression(tdbb, idv_condition, csb, false);
		}
		catch (const Exception&)
		{
			dbb->deletePool(stmtPool);
			throw;
		}
	}

	return found ? ScanResult::COMPLETE : ScanResult::MISS;
}

void IndexVersion::setLtt(thread_db* tdbb, LocalTemporaryTable::Index* lttIndex)
{
	SET_TDBB(tdbb);

	fb_assert(getPermanent()->getRelation()->rel_flags & REL_temp_ltt);

	idv_name = lttIndex->name;
	idv_uniqFlag = lttIndex->unique;
	idv_segmentCount = lttIndex->columns.getCount();
	idv_type = lttIndex->descending;
	idv_active = lttIndex->inactive ? MET_index_inactive : MET_index_active;
}

IndexVersion* RelationPermanent::lookup_index(thread_db* tdbb, const QualifiedName& name, ObjectBase::Flag flags)
{
	SET_TDBB(tdbb);

	Attachment* attachment = tdbb->getAttachment();

	// See if we already know the index by name
	auto* idp = rel_indices.lookup(tdbb,
		[tdbb, name, flags](Cached::Index* idp)->Cached::Index*
		{
			if (idp->getName() == name)
			{
				auto* idv = idp->getVersioned(tdbb, flags);
				if (idv && idv->getName() == name)
					return idp;
			}
			return nullptr;
		},
		flags);

	if (idp)
		return idp->getVersioned(tdbb, flags);
	if (!(flags & CacheFlag::AUTOCREATE))
		return nullptr;

	// We need to look up the index in RDB$INDICES
	fb_assert(getName().schema == name.schema);

	AutoCacheRequest request(tdbb, irq_get_index_by_name, IRQ_REQUESTS);
	IndexVersion* idv = nullptr;

	FOR(REQUEST_HANDLE request)
		IDX IN RDB$INDICES
		WITH IDX.RDB$INDEX_NAME EQ name.object.c_str() AND
			IDX.RDB$SCHEMA_NAME EQ getName().schema.c_str() AND
			IDX.RDB$RELATION_NAME EQ getName().object.c_str()
	{
		if (!idv)
			idv = rel_indices.getVersioned(tdbb, IDX.RDB$INDEX_ID - 1, flags);
		else
			fb_assert(false);
	}
	END_FOR

	return idv;
}

Cached::Index* RelationPermanent::lookupIndex(thread_db* tdbb, const QualifiedName& name, ObjectBase::Flag flags)
{
	SET_TDBB(tdbb);

	Attachment* attachment = tdbb->getAttachment();

	// See if we already know the relation by name
	auto* idp = rel_indices.lookup(tdbb,
		[tdbb, name, flags](Cached::Index* idp)
		{
			return idp->getName() == name ? idp : nullptr;
		},
		flags);

	if (idp || !(flags & CacheFlag::AUTOCREATE))
		return idp;

	// We need to look up the index in RDB$INDICES
	AutoCacheRequest request(tdbb, irq_get_index_by_name, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		IDX IN RDB$INDICES
		WITH IDX.RDB$INDEX_NAME EQ name.object.c_str() AND
			IDX.RDB$SCHEMA_NAME EQ getName().schema.c_str() AND
			IDX.RDB$RELATION_NAME EQ getName().object.c_str()
	{
		if (!idp)
		{
			if (auto* idv = rel_indices.getVersioned(tdbb, IDX.RDB$INDEX_ID - 1, flags))
				idp = getPermanent(idv);
		}
		else
			fb_assert(false);
	}
	END_FOR

	return idp;
}

std::optional<ObjectType> MET_qualify_existing_name(thread_db* tdbb, QualifiedName& name,
	std::initializer_list<ObjectType> objTypes, const ObjectsArray<MetaString>* schemaSearchPath)
{
	fb_assert(name.object.hasData() && name.schema.isEmpty());

	const auto attachment = tdbb->getAttachment();
	AutoCacheRequest handle;

	if (!schemaSearchPath)
		schemaSearchPath = attachment->att_schema_search_path;

	for (const auto& searchSchema : *schemaSearchPath)
	{
		bool found = false;

		for (const auto objType : objTypes)
		{
			switch (objType)
			{
				case obj_charset:
				{
					fb_assert(name.package.isEmpty());

					if (schemaSearchPath == attachment->att_schema_search_path.getPtr())
					{
						if (attachment->att_unqualified_charset_resolved_cache_search_path.getPtr() !=
								attachment->att_schema_search_path)
						{
							attachment->att_unqualified_charset_resolved_cache.clear();
							attachment->att_unqualified_charset_resolved_cache_search_path =
								attachment->att_schema_search_path;
						}
						else if (attachment->att_unqualified_charset_resolved_cache.get(name.object, name))
							return objType;
					}

					if (searchSchema == SYSTEM_SCHEMA)
					{
						USHORT charSetId = 0;
						if (get_type(tdbb, &charSetId, name.object, "RDB$CHARACTER_SET_NAME"))
						{
							found = true;
							break;
						}
					}

					static const CachedRequestId charSetHandleId;
					handle.reset(tdbb, charSetHandleId);

					FOR (REQUEST_HANDLE handle)
						CS IN RDB$CHARACTER_SETS
						WITH CS.RDB$SCHEMA_NAME EQ searchSchema.c_str() AND
							 CS.RDB$CHARACTER_SET_NAME EQ name.object.c_str()
					{
						found = true;
						break;
					}
					END_FOR

					break;
				}

				case obj_collation:
				{
					fb_assert(name.package.isEmpty());

					static const CachedRequestId collationHandleId;
					handle.reset(tdbb, collationHandleId);

					FOR (REQUEST_HANDLE handle)
						COLL IN RDB$COLLATIONS
						WITH COLL.RDB$SCHEMA_NAME EQ searchSchema.c_str() AND
							 COLL.RDB$COLLATION_NAME EQ name.object.c_str()
					{
						found = true;
						break;
					}
					END_FOR

					break;
				}

				case obj_exception:
				{
					fb_assert(name.package.isEmpty());

					static const CachedRequestId exceptionHandleId;
					handle.reset(tdbb, exceptionHandleId);

					FOR (REQUEST_HANDLE handle)
						XCP IN RDB$EXCEPTIONS
						WITH XCP.RDB$SCHEMA_NAME EQ searchSchema.c_str() AND
							 XCP.RDB$EXCEPTION_NAME EQ name.object.c_str()
					{
						found = true;
						break;
					}
					END_FOR

					break;
				}

				case obj_field:
				{
					fb_assert(name.package.isEmpty());

					static const CachedRequestId fieldHandleId;
					handle.reset(tdbb, fieldHandleId);

					FOR (REQUEST_HANDLE handle)
						FLD IN RDB$FIELDS
						WITH FLD.RDB$SCHEMA_NAME EQ searchSchema.c_str() AND
							 FLD.RDB$FIELD_NAME EQ name.object.c_str()
					{
						found = true;
						break;
					}
					END_FOR

					break;
				}

				case obj_generator:
				{
					fb_assert(name.package.isEmpty());

					static const CachedRequestId generatorHandleId;
					handle.reset(tdbb, generatorHandleId);

					FOR (REQUEST_HANDLE handle)
						GEN IN RDB$GENERATORS
						WITH GEN.RDB$SCHEMA_NAME EQ searchSchema.c_str() AND
							 GEN.RDB$GENERATOR_NAME EQ name.object.c_str()
					{
						found = true;
						break;
					}
					END_FOR

					break;
				}

				case obj_index:
				{
					fb_assert(name.package.isEmpty());

					// Check LTT indexes first
					for (const auto& lttEntry : attachment->att_local_temporary_tables)
					{
						const auto ltt = lttEntry.second;

						if (ltt->name.schema != searchSchema)
							continue;

						for (const auto& index : ltt->indexes)
						{
							if (index.name.object == name.object)
							{
								found = true;
								break;
							}
						}

						if (found)
							break;
					}

					if (!found)
					{
						static const CachedRequestId indexHandleId;
						handle.reset(tdbb, indexHandleId);

						FOR (REQUEST_HANDLE handle)
							IDX IN RDB$INDICES
							WITH IDX.RDB$SCHEMA_NAME EQ searchSchema.c_str() AND
								 IDX.RDB$INDEX_NAME EQ name.object.c_str()
						{
							found = true;
							break;
						}
						END_FOR
					}

					break;
				}

				case obj_package_header:
				{
					fb_assert(name.package.isEmpty());

					static const CachedRequestId packageHandleId;
					handle.reset(tdbb, packageHandleId);

					FOR (REQUEST_HANDLE handle)
						PKG IN RDB$PACKAGES
						WITH PKG.RDB$SCHEMA_NAME EQ searchSchema.c_str() AND
							 PKG.RDB$PACKAGE_NAME EQ name.object.c_str()
					{
						found = true;
						break;
					}
					END_FOR

					break;
				}

				case obj_procedure:
				{
					static const CachedRequestId procedureHandleId;
					handle.reset(tdbb, procedureHandleId);

					FOR (REQUEST_HANDLE handle)
						PRC IN RDB$PROCEDURES
						WITH PRC.RDB$SCHEMA_NAME EQ searchSchema.c_str() AND
							 PRC.RDB$PROCEDURE_NAME EQ name.object.c_str() AND
							 PRC.RDB$PACKAGE_NAME EQUIV NULLIF(name.package.c_str(), '')
					{
						found = true;
						break;
					}
					END_FOR

					break;
				}

				case obj_relation:
				case obj_view:
					if (name.package.isEmpty())
					{
						// Check LTT first
						for (const auto& lttEntry : attachment->att_local_temporary_tables)
						{
							const auto ltt = lttEntry.second;

							if (ltt->name.schema == searchSchema && ltt->name.object == name.object)
							{
								found = true;
								break;
							}
						}

						if (!found)
						{
							static const CachedRequestId relationHandleId;
							handle.reset(tdbb, relationHandleId);

							FOR (REQUEST_HANDLE handle)
								REL IN RDB$RELATIONS
								WITH REL.RDB$SCHEMA_NAME EQ searchSchema.c_str() AND
									 REL.RDB$RELATION_NAME EQ name.object.c_str()
							{
								found = true;
								break;
							}
							END_FOR
						}
					}

					break;

				case obj_trigger:
				{
					fb_assert(name.package.isEmpty());

					static const CachedRequestId triggerHandleId;
					handle.reset(tdbb, triggerHandleId);

					FOR (REQUEST_HANDLE handle)
						TRG IN RDB$TRIGGERS
						WITH TRG.RDB$SCHEMA_NAME EQ searchSchema.c_str() AND
							 TRG.RDB$TRIGGER_NAME EQ name.object.c_str()
					{
						found = true;
						break;
					}
					END_FOR

					break;
				}

				case obj_udf:
				{
					static const CachedRequestId udfHandleId;
					handle.reset(tdbb, udfHandleId);

					FOR (REQUEST_HANDLE handle)
						FUN IN RDB$FUNCTIONS
						WITH FUN.RDB$SCHEMA_NAME EQ searchSchema.c_str() AND
							 FUN.RDB$FUNCTION_NAME EQ name.object.c_str() AND
							 FUN.RDB$PACKAGE_NAME EQUIV NULLIF(name.package.c_str(), '')
					{
						found = true;
						break;
					}
					END_FOR

					break;
				}

				default:
					fb_assert(false);
			}

			if (found)
			{
				name.schema = searchSchema;

				if (objType == obj_charset && schemaSearchPath == attachment->att_schema_search_path.getPtr())
					attachment->att_unqualified_charset_resolved_cache.put(name.object, name);

				return objType;
			}
		}
	}

	return std::nullopt;
}

bool MET_check_schema_exists(thread_db* tdbb, const MetaName& name)
{
	const auto attachment = tdbb->getAttachment();

	static const CachedRequestId cachedHandleId;
	AutoCacheRequest handle(tdbb, cachedHandleId);

	FOR (REQUEST_HANDLE handle)
		SCH IN RDB$SCHEMAS
		WITH SCH.RDB$SCHEMA_NAME EQ name.c_str()
	{
		return true;
	}
	END_FOR

	return false;
}

bool MET_get_ltt_index(Attachment* attachment, const QualifiedName& indexName,
	LocalTemporaryTable** outLtt, LocalTemporaryTable::Index** outIndex)
{
/**************************************
 *
 *  M E T _ g e t _ l t t _ i n d e x
 *
 **************************************
 *
 * Functional description
 *  Look up an index by name in all LTTs of the current attachment.
 *  If found, returns true and sets outLtt to the owning LocalTemporaryTable
 *  and outIndex to point to the index. If not found, returns false.
 *
 **************************************/

	if (outLtt)
		*outLtt = nullptr;

	if (outIndex)
		*outIndex = nullptr;

	// Search through all LTTs for an index with the given name
	for (auto& lttEntry : attachment->att_local_temporary_tables)
	{
		const auto ltt = lttEntry.second;

		// Only search in LTTs with matching schema
		if (ltt->name.schema != indexName.schema)
			continue;

		for (auto& index : ltt->indexes)
		{
			if (index.name == indexName)
			{
				if (outLtt)
					*outLtt = ltt;
				if (outIndex)
					*outIndex = &index;
				return true;
			}
		}
	}

	return false;
}

jrd_rel* MetadataCache::getLtt(thread_db* tdbb, MetaId id)
{
	Attachment* attachment = tdbb->getAttachment();

	for (const auto& lttEntry : attachment->att_local_temporary_tables)
	{
		const auto ltt = lttEntry.second;
		if (ltt->relationId == id)
			return ltt->relation;
	}

	return nullptr;
}

jrd_rel* MetadataCache::getLtt(thread_db* tdbb, const QualifiedName& name)
{
	Attachment* attachment = tdbb->getAttachment();

	if (const auto lttPtr = attachment->att_local_temporary_tables.get(name))
		return (*lttPtr)->relation;

	return nullptr;
}

