/*
 *  PROGRAM:    Dynamic SQL runtime support
 *  MODULE:     metd.epp
 *  DESCRIPTION:    Meta-data interface
 *
 * The contents of this file are subject to the Interbase Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.Inprise.com/IPL.html
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code was created by Inprise Corporation
 * and its predecessors. Portions created by Inprise Corporation are
 * Copyright (C) Inprise Corporation.
 *
 * All Rights Reserved.
 * Contributor(s): ______________________________________.
 * 2001.11.28 Claudio Valderrama: load not only udfs but udf arguments;
 *   handle possible collisions with udf redefinitions (drop->declare).
 *   This closes SF Bug# 409769.
 * 2001.12.06 Claudio Valderrama: METD_get_charset_bpc() was added to
 *    get only the bytes per char of a field, given its charset id.
 *   This request is not cached.
 * 2001.02.23 Claudio Valderrama: Fix SF Bug #228135 with views spoiling
 *    NULLs in outer joins.
 * 2004.01.16 Vlad Horsun: make METD_get_col_default and
 *   METD_get_domain_default return actual length of default BLR
 * 2004.01.16 Vlad Horsun: added support for default parameters
 */

#include "firebird.h"
#include <string.h>
#include "../dsql/dsql.h"
#include "ibase.h"
#include "../jrd/align.h"
#include "../jrd/intl.h"
#include "../jrd/irq.h"
#include "../jrd/tra.h"
#include "../jrd/met.h"
#include "../dsql/ExprNodes.h"
#include "../dsql/ddl_proto.h"
#include "../dsql/metd_proto.h"
#include "../dsql/make_proto.h"
#include "../dsql/errd_proto.h"
#include "../jrd/blb_proto.h"
#include "../jrd/cmp_proto.h"
#include "../jrd/exe_proto.h"
#include "../yvalve/gds_proto.h"
#include "../jrd/met_proto.h"
#include "../yvalve/why_proto.h"
#include "../common/utils_proto.h"
#include "../common/classes/init.h"
#include "../jrd/LocalTemporaryTable.h"

using namespace Jrd;
using namespace Firebird;

// NOTE: The static definition of DB and gds_trans by gpre will not
// be used by the meta data routines.  Each of those routines has
// its own local definition of these variables.

DATABASE DB = STATIC "yachts.lnk";

static void convert_dtype(TypeClause*, SSHORT);

namespace
{
	inline void validateTransaction(const jrd_tra* transaction)
	{
		if (!transaction || !transaction->checkHandle())
		{
			ERR_post(Arg::Gds(isc_bad_trans_handle));
		}
	}
}


void METD_drop_charset(jrd_tra* transaction, const QualifiedName& metaName)
{
/**************************************
 *
 *  M E T D _ d r o p _ c h a r s e t
 *
 **************************************
 *
 * Functional description
 *  Drop a character set from our metadata, and the next caller who wants it will
 *  look up the new version.
 *  Dropping will be achieved by marking the character set
 *  as dropped.  Anyone with current access can continue
 *  accessing it.
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();
	dsql_dbb* dbb = transaction->getDsqlAttachment();
	dsql_intlsym* charSet;

	if (dbb->dbb_charsets.get(metaName, charSet))
	{
		MetadataCache::dsql_cache_use(tdbb, SYM_intlsym_charset, metaName);
		charSet->intlsym_flags |= INTLSYM_dropped;
		dbb->dbb_charsets.remove(metaName);
		dbb->dbb_charsets_by_id.remove(charSet->intlsym_charset_id);
	}
}


void METD_drop_collation(jrd_tra* transaction, const QualifiedName& name)
{
/**************************************
 *
 *  M E T D _ d r o p _ c o l l a t i o n
 *
 **************************************
 *
 * Functional description
 *  Drop a collation from our metadata, and
 *  the next caller who wants it will
 *  look up the new version.
 *
 *  Dropping will be achieved by marking the collation
 *  as dropped.  Anyone with current access can continue
 *  accessing it.
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();
	dsql_dbb* dbb = transaction->getDsqlAttachment();

	dsql_intlsym* collation;

	if (dbb->dbb_collations.get(name, collation))
	{
		MetadataCache::dsql_cache_use(tdbb, SYM_intlsym_collation, name);
		collation->intlsym_flags |= INTLSYM_dropped;
		dbb->dbb_collations.remove(name);
	}
}


void METD_drop_relation(jrd_tra* transaction, const QualifiedName& name)
{
/**************************************
 *
 *  M E T D _ d r o p _ r e l a t i o n
 *
 **************************************
 *
 * Functional description
 *  Drop a relation from our metadata, and
 *  rely on the next guy who wants it to
 *  look up the new version.
 *
 *      Dropping will be achieved by marking the relation
 *      as dropped.  Anyone with current access can continue
 *      accessing it.
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();

	dsql_rel* relation;

	if (transaction->tra_cache_rels.get(name, relation))
	{
		relation->rel_flags |= REL_dropped;
		transaction->tra_cache_rels.remove(name);
	}
}


dsql_intlsym* METD_get_collation(jrd_tra* transaction, const QualifiedName& name, CSetId charset_id)
{
/**************************************
 *
 *  M E T D _ g e t _ c o l l a t i o n
 *
 **************************************
 *
 * Functional description
 *  Look up an international text type object.
 *  If it doesn't exist, return NULL.
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();

	validateTransaction(transaction);

	dsql_dbb* dbb = transaction->getDsqlAttachment();

	// Start by seeing if symbol is already defined

	dsql_intlsym* symbol;
	if (dbb->dbb_collations.get(name, symbol) && !(symbol->intlsym_flags & INTLSYM_dropped) &&
		symbol->intlsym_charset_id == charset_id)
	{
		if (MetadataCache::dsql_cache_use(tdbb, SYM_intlsym_collation, name))
			symbol->intlsym_flags |= INTLSYM_dropped;
		else
			return symbol;
	}

	// Now see if it is in the database

	symbol = NULL;

	AutoCacheRequest handle(tdbb, irq_collation, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
	X IN RDB$COLLATIONS
		CROSS Y IN RDB$CHARACTER_SETS OVER RDB$CHARACTER_SET_ID
		WITH X.RDB$SCHEMA_NAME EQ name.schema.c_str() AND
			 X.RDB$COLLATION_NAME EQ name.object.c_str() AND
			 X.RDB$CHARACTER_SET_ID EQ charset_id;
	{
		symbol = FB_NEW_POOL(dbb->dbb_pool) dsql_intlsym(dbb->dbb_pool);
		symbol->intlsym_name = name;
		symbol->intlsym_flags = 0;
		symbol->intlsym_charset_id = CSetId(X.RDB$CHARACTER_SET_ID);
		symbol->intlsym_collate_id = CollId(X.RDB$COLLATION_ID);
		symbol->intlsym_ttype =
			TTypeId(symbol->intlsym_charset_id, symbol->intlsym_collate_id);
		symbol->intlsym_bytes_per_char =
			(Y.RDB$BYTES_PER_CHARACTER.NULL) ? 1 : (Y.RDB$BYTES_PER_CHARACTER);
	}
	END_FOR

	if (!symbol)
		return NULL;

	dbb->dbb_collations.put(name, symbol);
	MetadataCache::dsql_cache_use(tdbb, SYM_intlsym_collation, name);

	return symbol;
}


dsql_intlsym* METD_get_charset(jrd_tra* transaction, const QualifiedName& name)
{
/**************************************
 *
 *  M E T D _ g e t _ c h a r s e t
 *
 **************************************
 *
 * Functional description
 *  Look up an international text type object.
 *  If it doesn't exist, return NULL.
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();

	validateTransaction(transaction);

	dsql_dbb* dbb = transaction->getDsqlAttachment();

	// Start by seeing if symbol is already defined

	dsql_intlsym* symbol;
	if (dbb->dbb_charsets.get(name, symbol) && !(symbol->intlsym_flags & INTLSYM_dropped))
	{
		if (MetadataCache::dsql_cache_use(tdbb, SYM_intlsym_charset, name))
			symbol->intlsym_flags |= INTLSYM_dropped;
		else
			return symbol;
	}

	// Now see if it is in the database

	symbol = NULL;

	AutoCacheRequest handle(tdbb, irq_charset, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
		CS IN RDB$CHARACTER_SETS
		CROSS COLL IN RDB$COLLATIONS OVER RDB$CHARACTER_SET_ID
		CROSS T IN RDB$TYPES
		WITH CS.RDB$SCHEMA_NAME EQ name.schema.c_str() AND
			 T.RDB$TYPE_NAME EQ name.object.c_str() AND
			 COLL.RDB$SCHEMA_NAME EQ CS.RDB$DEFAULT_COLLATE_SCHEMA_NAME AND
			 COLL.RDB$COLLATION_NAME EQ CS.RDB$DEFAULT_COLLATE_NAME AND
			 T.RDB$FIELD_NAME EQ "RDB$CHARACTER_SET_NAME" AND
			 T.RDB$TYPE EQ CS.RDB$CHARACTER_SET_ID
	{
		symbol = FB_NEW_POOL(dbb->dbb_pool) dsql_intlsym(dbb->dbb_pool);
		symbol->intlsym_name = name;
		symbol->intlsym_flags = 0;
		symbol->intlsym_charset_id = CSetId(COLL.RDB$CHARACTER_SET_ID);
		symbol->intlsym_collate_id = CollId(COLL.RDB$COLLATION_ID);
		symbol->intlsym_ttype =
			TTypeId(symbol->intlsym_charset_id, symbol->intlsym_collate_id);
		symbol->intlsym_bytes_per_char =
			(CS.RDB$BYTES_PER_CHARACTER.NULL) ? 1 : (CS.RDB$BYTES_PER_CHARACTER);
	}
	END_FOR

	if (!symbol)
		return NULL;

	dbb->dbb_charsets.put(name, symbol);
	dbb->dbb_charsets_by_id.put(symbol->intlsym_charset_id, symbol);
	MetadataCache::dsql_cache_use(tdbb, SYM_intlsym_charset, name);

	return symbol;
}


USHORT METD_get_charset_bpc(jrd_tra* transaction, CSetId charset_id)
{
/**************************************
 *
 *  M E T D _ g e t _ c h a r s e t _ b p c
 *
 **************************************
 *
 * Functional description
 *  Look up an international text type object.
 *  If it doesn't exist, return NULL.
 *  Go directly to system tables & return only the
 *  number of bytes per character. Lookup by
 *  charset' id, not by name.
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();

	dsql_dbb* dbb = transaction->getDsqlAttachment();

	if (charset_id == CS_dynamic)
		charset_id = tdbb->getCharSet();

	dsql_intlsym* symbol = NULL;
	if (!dbb->dbb_charsets_by_id.get(charset_id, symbol))
	{
		const auto cs_name = METD_get_charset_name(transaction, charset_id);
		symbol = METD_get_charset(transaction, cs_name);
	}

	fb_assert(symbol);

	return symbol ? symbol->intlsym_bytes_per_char : 0;
}


QualifiedName METD_get_charset_name(jrd_tra* transaction, CSetId charset_id)
{
/**************************************
 *
 *  M E T D _ g e t _ c h a r s e t _ n a m e
 *
 **************************************
 *
 * Functional description
 *  Look up an international text type object.
 *  If it doesn't exist, return empty string.
 *  Go directly to system tables & return only the
 *  name.
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();

	validateTransaction(transaction);

	dsql_dbb* dbb = transaction->getDsqlAttachment();

	if (charset_id == CS_dynamic)
		charset_id = tdbb->getCharSet();

	dsql_intlsym* sym = NULL;
	if (dbb->dbb_charsets_by_id.get(charset_id, sym))
		return sym->intlsym_name;

	QualifiedName name;

	AutoCacheRequest handle(tdbb, irq_cs_name, IRQ_REQUESTS);

	FOR (REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
		Y IN RDB$CHARACTER_SETS
		WITH Y.RDB$CHARACTER_SET_ID EQ charset_id
	{
		name = QualifiedName(Y.RDB$CHARACTER_SET_NAME, Y.RDB$SCHEMA_NAME);
	}
	END_FOR

	// put new charset into hash table if needed
	METD_get_charset(transaction, name);

	return name;
}


// Find the default character set for a database
QualifiedName METD_get_database_charset(jrd_tra* transaction)
{
	thread_db* tdbb = JRD_get_thread_data();

	validateTransaction(transaction);

	dsql_dbb* dbb = transaction->getDsqlAttachment();
	if (dbb->dbb_no_charset)
		return {};

	if (dbb->dbb_dfl_charset.object.hasData())
		return dbb->dbb_dfl_charset;

	// Now see if it is in the database

	static const CachedRequestId requestHandleId;
	AutoCacheRequest requestHandle(tdbb, requestHandleId);

	FOR(REQUEST_HANDLE requestHandle TRANSACTION_HANDLE transaction)
		FIRST 1 DBB IN RDB$DATABASE
		WITH DBB.RDB$CHARACTER_SET_NAME NOT MISSING
	{
		dbb->dbb_dfl_charset = QualifiedName(DBB.RDB$CHARACTER_SET_NAME, DBB.RDB$CHARACTER_SET_SCHEMA_NAME);
	}
	END_FOR

	if (dbb->dbb_dfl_charset.object.isEmpty())
	{
		fb_assert(false);
		dbb->dbb_no_charset = true;
	}

	return dbb->dbb_dfl_charset;
}


// Find the default character set for a schema
QualifiedName METD_get_schema_charset(jrd_tra* transaction, const MetaName& schema)
{
	thread_db* tdbb = JRD_get_thread_data();

	validateTransaction(transaction);

	dsql_dbb* dbb = transaction->getDsqlAttachment();

	if (const auto charSet = dbb->dbb_schemas_dfl_charset.get(schema))
		return *charSet;

	// Now see if it is in the database

	static const CachedRequestId requestHandleId;
	AutoCacheRequest requestHandle(tdbb, requestHandleId);

	FOR(REQUEST_HANDLE requestHandle TRANSACTION_HANDLE transaction)
		FIRST 1 SCH IN RDB$SCHEMAS
		CROSS DBB IN RDB$DATABASE
		WITH SCH.RDB$SCHEMA_NAME = schema.c_str()
	{
		if (!SCH.RDB$CHARACTER_SET_NAME.NULL)
		{
			QualifiedName charSet(SCH.RDB$CHARACTER_SET_NAME, SCH.RDB$CHARACTER_SET_SCHEMA_NAME);
			dbb->dbb_schemas_dfl_charset.put(schema, charSet);
			return charSet;
		}
		else if (!DBB.RDB$CHARACTER_SET_NAME.NULL)
		{
			QualifiedName charSet(DBB.RDB$CHARACTER_SET_NAME, DBB.RDB$CHARACTER_SET_SCHEMA_NAME);
			return charSet;
		}
	}
	END_FOR

	fb_assert(false);
	return {};
}


bool METD_get_domain(jrd_tra* transaction, TypeClause* field, const QualifiedName& name) // UTF-8
{
/**************************************
 *
 *  M E T D _ g e t _ d o m a i n
 *
 **************************************
 *
 * Functional description
 *  Fetch domain information for field defined as 'name'
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();

	validateTransaction(transaction);

	bool found = false;

	AutoCacheRequest handle(tdbb, irq_domain, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
		FLX IN RDB$FIELDS
		WITH FLX.RDB$SCHEMA_NAME EQ name.schema.c_str() AND
			 FLX.RDB$FIELD_NAME EQ name.object.c_str()
	{
		found = true;
		field->length = FLX.RDB$FIELD_LENGTH;
		field->scale = FLX.RDB$FIELD_SCALE;
		field->subType = FLX.RDB$FIELD_SUB_TYPE;
		field->dimensions = FLX.RDB$DIMENSIONS.NULL ? 0 : FLX.RDB$DIMENSIONS;

		field->charSetId = std::nullopt;
		if (!FLX.RDB$CHARACTER_SET_ID.NULL)
			field->charSetId = CSetId(FLX.RDB$CHARACTER_SET_ID);
		field->collationId = CollId(0);
		if (!FLX.RDB$COLLATION_ID.NULL)
			field->collationId = CollId(FLX.RDB$COLLATION_ID);
		field->charLength = 0;
		if (!FLX.RDB$CHARACTER_LENGTH.NULL)
			field->charLength = FLX.RDB$CHARACTER_LENGTH;

		if (!FLX.RDB$COMPUTED_BLR.NULL)
			field->flags |= FLD_computed;

		if (FLX.RDB$NULL_FLAG.NULL || !FLX.RDB$NULL_FLAG)
			field->flags |= FLD_nullable;

		if (FLX.RDB$SYSTEM_FLAG == 1)
			field->flags |= FLD_system;

		convert_dtype(field, FLX.RDB$FIELD_TYPE);

		if (FLX.RDB$FIELD_TYPE == blr_blob) {
			field->segLength = FLX.RDB$SEGMENT_LENGTH;
		}
	}
	END_FOR

	return found;
}


dsql_udf* METD_get_function(jrd_tra* transaction, DsqlCompilerScratch* dsqlScratch, const QualifiedName& name)
{
/**************************************
 *
 *  M E T D _ g e t _ f u n c t i o n
 *
 **************************************
 *
 * Functional description
 *  Look up a user defined function.  If it doesn't exist,
 *  return NULL.
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();
	validateTransaction(transaction);

	dsql_udf* userFunc = NULL;

	// Start by seeing if symbol is already defined

	if (dsqlScratch->functions.get(name, userFunc))
	{
		if (userFunc->udf_private && name.getSchemaAndPackage() != dsqlScratch->package)
		{
			status_exception::raise(Arg::Gds(isc_private_function) <<
				Arg::Str(name.object) << Arg::Str(name.package));
		}

		return userFunc;
	}

	// now see if it is in the metadata cache

	USHORT return_arg = 0;

	auto* jfunc = MetadataCache::getVersioned<Cached::Function>(tdbb, name, CacheFlag::AUTOCREATE);
	if (jfunc)
	{
		userFunc = FB_NEW_POOL(dsqlScratch->getPool()) dsql_udf(dsqlScratch->getPool(), jfunc);

		if (userFunc->udf_private && name.getSchemaAndPackage() != dsqlScratch->package)
		{
			status_exception::raise(Arg::Gds(isc_private_procedure) <<
				Arg::Str(name.object) << Arg::Str(name.package));
		}

		dsqlScratch->functions.put(userFunc->udf_name, userFunc);
		return userFunc;
	}

	return nullptr;
}


void METD_get_primary_key(jrd_tra* transaction, const QualifiedName& relationName,
	Array<NestConst<FieldNode> >& fields)
{
/**************************************
 *
 *  M E T D _ g e t _ p r i m a r y _ k e y
 *
 **************************************
 *
 * Functional description
 *  Lookup the fields for the primary key
 *  index on a relation, returning a list
 *  node of the fields.
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();
	MemoryPool& pool = *tdbb->getDefaultPool();

	validateTransaction(transaction);

	AutoCacheRequest handle(tdbb, irq_primary_key, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
		X IN RDB$INDICES
		CROSS Y IN RDB$INDEX_SEGMENTS OVER RDB$SCHEMA_NAME, RDB$INDEX_NAME
		CROSS Z IN RDB$RELATION_CONSTRAINTS OVER RDB$SCHEMA_NAME, RDB$INDEX_NAME
		WITH Z.RDB$SCHEMA_NAME EQ relationName.schema.c_str() AND
			 Z.RDB$RELATION_NAME EQ relationName.object.c_str() AND
			 Z.RDB$CONSTRAINT_TYPE EQ "PRIMARY KEY"
		SORTED BY Y.RDB$FIELD_POSITION
	{
		FieldNode* fieldNode = FB_NEW_POOL(pool) FieldNode(pool);
		fieldNode->dsqlName = Y.RDB$FIELD_NAME;
		fields.add(fieldNode);
	}
	END_FOR
}


dsql_prc* METD_get_procedure(jrd_tra* transaction, DsqlCompilerScratch* dsqlScratch, const QualifiedName& name)
{
/**************************************
 *
 *  M E T D _ g e t _ p r o c e d u r e
 *
 **************************************
 *
 * Functional description
 *  Look up a procedure.  If it doesn't exist, return NULL.
 *  If it does, fetch field information as well.
 *  If it is marked dropped, try to read from system tables
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();
	validateTransaction(transaction);

	// Start by seeing if symbol is already defined

	dsql_prc* procedure = NULL;
	if (dsqlScratch->procedures.get(name, procedure))
	{
		if (procedure->prc_private && name.getSchemaAndPackage() != dsqlScratch->package)
		{
			status_exception::raise(Arg::Gds(isc_private_procedure) <<
				Arg::Str(name.object) << Arg::Str(name.package));
		}

		return procedure;
	}

	// now see if it is in the metadata cache

	auto* jproc = MetadataCache::getVersioned<Cached::Procedure>(tdbb, name, CacheFlag::AUTOCREATE);
	if (jproc)
	{
		procedure = FB_NEW_POOL(dsqlScratch->getPool()) dsql_prc(dsqlScratch->getPool(), jproc);

		if (procedure->prc_private && name.getSchemaAndPackage() != dsqlScratch->package)
		{
			status_exception::raise(Arg::Gds(isc_private_procedure) <<
				Arg::Str(name.object) << Arg::Str(name.package));
		}

		dsqlScratch->procedures.put(procedure->prc_name, procedure);
		return procedure;
	}

	return nullptr;
}


dsql_rel* METD_get_relation(jrd_tra* transaction, DsqlCompilerScratch* dsqlScratch,
	const QualifiedName& name)
{
/**************************************
 *
 *  M E T D _ g e t _ r e l a t i o n
 *
 **************************************
 *
 * Functional description
 *  Look up a relation.  If it doesn't exist, return NULL.
 *  If it does, fetch field information as well.
 *
 **************************************/

	thread_db* tdbb = JRD_get_thread_data();

	validateTransaction(transaction);

	// see if the relation is the one currently being defined in this statement

	auto* relation = dsqlScratch->relation;
	if (relation != NULL && relation->rel_name == name)
	{
		return relation;
	}

	// check is regular cache still valid

	if (!dsqlScratch->regularCacheValid)
	{
		auto* mdc = MetadataCache::get(tdbb);
		if (transaction->tra_mdc_version != mdc->getFrontVersion())
		{
			transaction->tra_cache_rels.clear();
			transaction->tra_mdc_version = mdc->getBackVersion();
		}
		dsqlScratch->regularCacheValid = true;
	}

	// see if it is in the regular cache

	if (transaction->tra_cache_rels.get(name, relation))
	{
		return relation;
	}

	// Is it LTT?

	const auto lttPtr = tdbb->getAttachment()->att_local_temporary_tables.get(name);
	const auto ltt = lttPtr ? *lttPtr : nullptr;

	if (ltt)
	{
		if ((dsqlScratch->flags & DsqlCompilerScratch::FLAG_DDL) &&
			!(dsqlScratch->flags & DsqlCompilerScratch::FLAG_ALLOW_LTT_REFERENCES))
		{
			// LTTs cannot be referenced in persistent metadata (DDL other than LTT DDL itself)
			status_exception::raise(Arg::Gds(isc_dsql_ltt_invalid_reference)
				<< name.toQuotedString()
				<< "persistent metadata");
		}

		fb_assert(ltt->relationId);

		relation = FB_NEW_POOL(transaction->getPool()) dsql_rel(transaction->getPool());
		relation->rel_id = ltt->relationId;
		relation->rel_name = name;
		relation->rel_dbkey_length = 8;
		relation->rel_flags = REL_ltt_created;

		dsql_fld** ptr = &relation->rel_fields;

		for (const auto& lttField : ltt->fields)
		{
			dsql_fld* field = FB_NEW_POOL(transaction->getPool()) dsql_fld(transaction->getPool());

			*ptr = field;
			ptr = &field->fld_next;

			field->fld_relation = relation;
			field->fld_id = lttField.id;
			field->fld_name = lttField.name;
			field->fieldSource = lttField.source;

			field->dtype = lttField.desc.dsc_dtype;
			field->length = lttField.desc.dsc_length;
			field->scale = lttField.desc.dsc_scale;
			field->subType = lttField.desc.dsc_sub_type;
			field->segLength = lttField.segLength;
			field->charLength = lttField.charLength;
			field->precision = lttField.precision;

			if (lttField.charSetId.has_value())
				field->charSetId = lttField.charSetId.value();

			if (lttField.collationId.has_value())
				field->collationId = lttField.collationId.value();

			if (!lttField.notNullFlag)
				field->flags |= FLD_nullable;
		}
	}
	else
	{
		// now see if it is in the metadata cache

		auto* jrel = MetadataCache::getVersioned<Cached::Relation>(tdbb, name, CacheFlag::AUTOCREATE);
		if (!jrel)
			return nullptr;

		relation = FB_NEW_POOL(transaction->getPool()) dsql_rel(transaction->getPool(), jrel);
	}

	transaction->tra_cache_rels.put(relation->rel_name, relation);

	return relation;
}


bool METD_get_type(jrd_tra* transaction, const MetaName& name, const char* field, SSHORT* value)
{
/**************************************
 *
 *  M E T D _ g e t _ t y p e
 *
 **************************************
 *
 * Functional description
 *  Look up a symbolic name in RDB$TYPES
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();

	validateTransaction(transaction);

	bool found = false;

	AutoCacheRequest handle(tdbb, irq_type, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
		X IN RDB$TYPES
		WITH X.RDB$FIELD_NAME EQ field AND
			 X.RDB$TYPE_NAME EQ name.c_str()
	{
		found = true;
		*value = X.RDB$TYPE;
	}
	END_FOR

	return found;
}


dsql_rel* METD_get_view_base(jrd_tra* transaction, DsqlCompilerScratch* dsqlScratch,
	const QualifiedName& viewName, MetaNamePairMap& fields)
{
/**************************************
 *
 *  M E T D _ g e t _ v i e w _ b a s e
 *
 **************************************
 *
 * Functional description
 *  Return the base table of a view or NULL if there
 *  is more than one.
 *  If there is only one base, put in fields a map of
 *  top view field name / bottom base field name.
 *  Ignores the field in the case of a base field name
 *  appearing more than one time in a level.
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();

	validateTransaction(transaction);

	auto nextViewName = viewName;
	dsql_rel* relation = nullptr;
	bool first = true;
	bool cont = true;
	MetaNamePairMap previousAux;

	fields.clear();

	while (cont)
	{
		AutoCacheRequest handle1(tdbb, irq_view_base, IRQ_REQUESTS);

		FOR(REQUEST_HANDLE handle1 TRANSACTION_HANDLE transaction)
			X IN RDB$VIEW_RELATIONS
			WITH X.RDB$SCHEMA_NAME EQ nextViewName.schema.c_str() AND
				 X.RDB$VIEW_NAME EQ nextViewName.object.c_str()
		{
			// return NULL if there is more than one context
			if (X.RDB$VIEW_CONTEXT != 1 || X.RDB$CONTEXT_TYPE == VCT_PROCEDURE)
			{
				relation = NULL;
				cont = false;
				break;
			}

			nextViewName = QualifiedName(X.RDB$RELATION_NAME, X.RDB$RELATION_SCHEMA_NAME);
			relation = METD_get_relation(transaction, dsqlScratch, nextViewName);

			Array<MetaName> ambiguities;
			MetaNamePairMap currentAux;

			if (!relation)
			{
				cont = false;
				break;
			}

			AutoCacheRequest handle2(tdbb, irq_view_base_flds, IRQ_REQUESTS);

			FOR(REQUEST_HANDLE handle2 TRANSACTION_HANDLE transaction)
				RFL IN RDB$RELATION_FIELDS
				WITH RFL.RDB$SCHEMA_NAME EQ X.RDB$SCHEMA_NAME AND
					 RFL.RDB$RELATION_NAME EQ X.RDB$VIEW_NAME
			{
				if (RFL.RDB$BASE_FIELD.NULL || RFL.RDB$FIELD_NAME.NULL)
					continue;

				const MetaName baseField(RFL.RDB$BASE_FIELD);
				if (currentAux.exist(baseField))
					ambiguities.add(baseField);
				else
				{
					const MetaName fieldName(RFL.RDB$FIELD_NAME);
					if (first)
					{
						fields.put(fieldName, baseField);
						currentAux.put(baseField, fieldName);
					}
					else
					{
						MetaName field;

						if (previousAux.get(fieldName, field))
						{
							fields.put(field, baseField);
							currentAux.put(baseField, field);
						}
					}
				}
			}
			END_FOR

			for (const MetaName* i = ambiguities.begin(); i != ambiguities.end(); ++i)
			{
				MetaName field;

				if (currentAux.get(*i, field))
				{
					currentAux.remove(*i);
					fields.remove(field);
				}
			}

			previousAux.takeOwnership(currentAux);

			if (!(relation->rel_flags & REL_view))
			{
				cont = false;
				break;
			}

			first = false;
		}
		END_FOR
	}

	if (!relation)
		fields.clear();

	return relation;
}


bool METD_get_view_relation(jrd_tra* transaction, DsqlCompilerScratch* dsqlScratch,
	const Jrd::QualifiedName& view_name, const Jrd::QualifiedName& relation_or_alias,
	dsql_rel*& relation, dsql_prc*& procedure)
{
/**************************************
 *
 *  M E T D _ g e t _ v i e w _ r e l a t i o n
 *
 **************************************
 *
 * Functional description
 *  Return TRUE if the passed view_name represents a
 *  view with the passed relation as a base table
 *  (the relation could be an alias).
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();

	validateTransaction(transaction);

	AutoCacheRequest handle(tdbb, irq_view, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
		X IN RDB$VIEW_RELATIONS
		WITH X.RDB$SCHEMA_NAME EQ view_name.schema.c_str() AND
			 X.RDB$VIEW_NAME EQ view_name.object.c_str()
	{
		QualifiedName relationName(X.RDB$RELATION_NAME, X.RDB$RELATION_SCHEMA_NAME);

		ObjectsArray<QualifiedMetaString> contextName;
		try
		{
			QualifiedMetaString::parseSchemaObjectListNoSep(X.RDB$CONTEXT_NAME, contextName);
		}
		catch (const status_exception&)
		{
			// Legacy (restored from backups) data stored in RDB$CONTEXT_NAME may cause exceptions.
			contextName.clear();
			contextName.push(QualifiedMetaString(X.RDB$CONTEXT_NAME));
		}

		if (PASS1_compare_alias(relationName, relation_or_alias) ||
			(relation_or_alias.schema.isEmpty() &&
				contextName.getCount() == 1 &&
				PASS1_compare_alias(contextName[0], relation_or_alias)))
		{
			if ((relation = METD_get_relation(transaction, dsqlScratch, relationName)))
				return true;

			const QualifiedName procName(X.RDB$RELATION_NAME, X.RDB$RELATION_SCHEMA_NAME, X.RDB$PACKAGE_NAME);

			if ( (procedure = METD_get_procedure(transaction, dsqlScratch, procName)) )
				return true;
		}

		if (METD_get_view_relation(transaction, dsqlScratch, relationName, relation_or_alias, relation, procedure))
			return true;
	}
	END_FOR

	return false;
}


static void convert_dtype(TypeClause* field, SSHORT field_type)
{
/**************************************
 *
 *  c o n v e r t _ d t y p e
 *
 **************************************
 *
 * Functional description
 *  Convert from the blr_<type> stored in system metadata
 *  to the internal dtype_* descriptor.  Also set field
 *  length.
 *
 **************************************/

	// fill out the type descriptor
	switch (field_type)
	{
	case blr_text:
		field->dtype = dtype_text;
		break;
	case blr_varying:
		field->dtype = dtype_varying;
		field->length += sizeof(USHORT);
		break;
	case blr_blob:
		field->dtype = dtype_blob;
		field->length = type_lengths[field->dtype];
		break;
	default:
		field->dtype = gds_cvt_blr_dtype[field_type];
		field->length = type_lengths[field->dtype];

		fb_assert(field->dtype != dtype_unknown);
	}
}

